(function(s) {console.log(s)})('START WEEX HTML5: 0.3.1 Build 20160816');
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _render = __webpack_require__(1);
	
	var _render2 = _interopRequireDefault(_render);
	
	var _root = __webpack_require__(137);
	
	var _root2 = _interopRequireDefault(_root);
	
	var _div = __webpack_require__(138);
	
	var _div2 = _interopRequireDefault(_div);
	
	var _components = __webpack_require__(139);
	
	var _components2 = _interopRequireDefault(_components);
	
	var _api = __webpack_require__(189);
	
	var _api2 = _interopRequireDefault(_api);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * install components and APIs
	 */
	
	
	_render2.default.install(_root2.default);
	_render2.default.install(_div2.default);
	_render2.default.install(_components2.default);
	_render2.default.install(_api2.default);
	
	exports.default = _render2.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global lib, WebSocket */
	
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Weex;
	
	__webpack_require__(2);
	
	__webpack_require__(6);
	
	var _config = __webpack_require__(116);
	
	var _config2 = _interopRequireDefault(_config);
	
	var _loader = __webpack_require__(117);
	
	var _utils = __webpack_require__(83);
	
	var utils = _interopRequireWildcard(_utils);
	
	var _bridge = __webpack_require__(118);
	
	var _component = __webpack_require__(122);
	
	var _component2 = _interopRequireDefault(_component);
	
	var _atomic = __webpack_require__(132);
	
	var _atomic2 = _interopRequireDefault(_atomic);
	
	var _componentManager = __webpack_require__(114);
	
	var _componentManager2 = _interopRequireDefault(_componentManager);
	
	var _register = __webpack_require__(133);
	
	__webpack_require__(134);
	
	__webpack_require__(135);
	
	__webpack_require__(136);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var DEFAULT_DESIGN_WIDTH = 750;
	
	// gesture
	
	var DEFAULT_SCALE = window.innerWidth / DEFAULT_DESIGN_WIDTH;
	var DEFAULT_ROOT_ID = 'weex';
	var DEFAULT_JSONP_CALLBACK_NAME = 'weexJsonpCallback';
	
	global.WXEnvironment = {
	  weexVersion: _config2.default.weexVersion,
	  appName: lib.env.aliapp ? lib.env.aliapp.appname : null,
	  appVersion: lib.env.aliapp ? lib.env.aliapp.version.val : null,
	  platform: 'Web',
	  osName: lib.env.browser ? lib.env.browser.name : null,
	  osVersion: lib.env.browser ? lib.env.browser.version.val : null,
	  deviceWidth: DEFAULT_DESIGN_WIDTH,
	  deviceHeight: window.innerHeight / DEFAULT_SCALE
	};
	
	var _weexInstance = {};
	
	function noop() {}
	
	;(function initializeWithUrlParams() {
	  // in casperjs the protocol is file.
	  if (location.protocol.match(/file/)) {
	    return;
	  }
	
	  var params = lib.httpurl(location.href).params;
	
	  // set global 'debug' config to true if there's a debug flag in current url.
	  var debug = params['debug'];
	  if (debug === true || debug === 'true') {
	    _config2.default.debug = true;
	  }
	
	  !_config2.default.debug && (console.debug = noop);
	})();
	
	function Weex(options) {
	  if (!(this instanceof Weex)) {
	    return new Weex(options);
	  }
	
	  // Width of the root container. Default is window.innerWidth.
	  this.width = options.width || window.innerWidth;
	  this.bundleUrl = options.bundleUrl || location.href;
	  this.instanceId = options.appId;
	  this.rootId = options.rootId || DEFAULT_ROOT_ID + utils.getRandom(10);
	  this.designWidth = options.designWidth || DEFAULT_DESIGN_WIDTH;
	  this.jsonpCallback = options.jsonpCallback || DEFAULT_JSONP_CALLBACK_NAME;
	  this.source = options.source;
	  this.loader = options.loader;
	  this.embed = options.embed;
	
	  this.data = options.data;
	  this.scale = this.width / this.designWidth;
	  _bridge.receiver.init(this);
	  this.sender = new _bridge.Sender(this);
	
	  _weexInstance[this.instanceId] = this;
	
	  // load bundle.
	  (0, _loader.load)({
	    jsonpCallback: this.jsonpCallback,
	    source: this.source,
	    loader: this.loader
	  }, function (err, appCode) {
	    if (!err) {
	      this.createApp(_config2.default, appCode);
	    } else {
	      console.error('load bundle err:', err);
	    }
	  }.bind(this));
	}
	
	Weex.init = function (options) {
	  if (utils.isArray(options)) {
	    options.forEach(function (config) {
	      new Weex(config);
	    });
	  } else if (utils.getType(options) === 'object') {
	    new Weex(options);
	  }
	};
	
	Weex.getInstance = function (instanceId) {
	  return _weexInstance[instanceId];
	};
	
	Weex.prototype = {
	
	  createApp: function createApp(config, appCode) {
	    var root = document.querySelector('#' + this.rootId);
	    if (!root) {
	      root = document.createElement('div');
	      root.id = this.rootId;
	      document.body.appendChild(root);
	    }
	
	    var instance = window.createInstance(this.instanceId, appCode, {
	      bundleUrl: this.bundleUrl,
	      debug: config.debug
	    }, this.data);
	
	    if (!instance) {
	      return console.error('[h5-render] createInstance error: get void for instance.');
	    }
	
	    if (instance instanceof Error) {
	      return console.error('[h5-render]', instance);
	    }
	
	    if (instance instanceof Promise) {
	      return instance.then(function (res) {
	        this.appInstance = res;
	        // Weex._instances[this.instanceId] = this.root
	      }).catch(function (err) {
	        console.error('[h5-render]', err);
	      });
	    }
	
	    this.appInstance = instance;
	
	    // Do not destroy instance before unload, because in most browser
	    // press back button to back to this page will not refresh
	    // the window and the instance will not be recreated then.
	    // window.addEventListener('beforeunload', function (e) {
	    // })
	  },
	
	  getComponentManager: function getComponentManager() {
	    if (!this._componentManager) {
	      this._componentManager = _componentManager2.default.getInstance(this.instanceId);
	    }
	    return this._componentManager;
	  },
	
	  getRoot: function getRoot() {
	    return document.querySelector('#' + this.rootId);
	  }
	};
	
	Weex.stopTheWorld = function (instanceId) {
	  if (!instanceId) {
	    return Object.keys(_weexInstance).map(function (instanceId) {
	      Weex.stopTheWorld(instanceId);
	    });
	  }
	  window.destroyInstance(instanceId);
	}
	
	// for weex-toolkit.
	;(function startRefreshController() {
	  if (location.protocol.match(/file/)) {
	    return;
	  }
	  if (location.search.indexOf('hot-reload_controller') === -1) {
	    return;
	  }
	  if (typeof WebSocket === 'undefined') {
	    console.info('auto refresh need WebSocket support');
	    return;
	  }
	  var host = location.hostname;
	  var port = 8082;
	  var client = new WebSocket('ws://' + host + ':' + port + '/', 'echo-protocol');
	  client.onerror = function () {
	    console.log('refresh controller websocket connection error');
	  };
	  client.onmessage = function (e) {
	    console.log('Received: \'' + e.data + '\'');
	    if (e.data === 'refresh') {
	      location.reload();
	    }
	  };
	})();
	
	(0, _register.bind)(Weex);
	
	utils.extend(Weex, {
	  Component: _component2.default,
	  Atomic: _atomic2.default,
	  ComponentManager: _componentManager2.default,
	  utils: utils,
	  config: _config2.default
	});
	
	global.weex = Weex;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(3);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../node_modules/css-loader/index.js!./base.css", function() {
				var newContent = require("!!./../../../../node_modules/css-loader/index.js!./base.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, "* {\n  margin: 0;\n  padding: 0;\n  text-size-adjust: none;\n}\n\nul, ol {\n  list-style: none;\n}\n\n.weex-container {\n  box-sizing: border-box;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n  flex-shrink: 0;\n  align-items: stretch;\n  box-align: stretch;\n  align-content: flex-start;\n  position: relative;\n  border: 0 solid black;\n  margin: 0;\n  padding: 0;\n  min-width: 0;\n}\n\n.weex-element {\n  box-sizing: border-box;\n  position: relative;\n  flex-shrink: 0;\n  border: 0 solid black;\n  margin: 0;\n  padding: 0;\n  min-width: 0;\n}\n", ""]);
	
	// exports


/***/ },
/* 4 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	__webpack_require__(7);
	
	var _init = __webpack_require__(76);
	
	var _init2 = _interopRequireDefault(_init);
	
	var _config = __webpack_require__(77);
	
	var _config2 = _interopRequireDefault(_config);
	
	var _vdom = __webpack_require__(112);
	
	var _methods = __webpack_require__(113);
	
	var methods = _interopRequireWildcard(_methods);
	
	var _componentManager = __webpack_require__(114);
	
	var _componentManager2 = _interopRequireDefault(_componentManager);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// import { subversion } from '../../../package.json'
	
	
	var config = {
	  Document: _vdom.Document, Element: _vdom.Element, Comment: _vdom.Comment, Listener: _componentManager2.default, frameworks: _config2.default,
	  sendTasks: function sendTasks() {
	    var _global;
	
	    (_global = global).callNative.apply(_global, arguments);
	  }
	};
	// import init from '../../runtime/init'
	
	
	var runtime = (0, _init2.default)(config);
	
	// const { native, transformer } = subversion
	
	var _loop = function _loop(methodName) {
	  global[methodName] = function () {
	    var ret = runtime[methodName].apply(runtime, arguments);
	    if (ret instanceof Error) {
	      console.error(ret.toString());
	    }
	    return ret;
	  };
	};
	
	for (var methodName in runtime) {
	  _loop(methodName);
	}
	
	// global.frameworkVersion = native
	// global.transformVersion = transformer
	
	/**
	 * register methods
	 */
	global.registerMethods(methods);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isPlainObject = exports.isObject = exports.toArray = exports.bind = exports.hasOwn = exports.remove = exports.def = exports.extend = undefined;
	
	var _utils = __webpack_require__(8);
	
	Object.defineProperty(exports, 'extend', {
	  enumerable: true,
	  get: function get() {
	    return _utils.extend;
	  }
	});
	Object.defineProperty(exports, 'def', {
	  enumerable: true,
	  get: function get() {
	    return _utils.def;
	  }
	});
	Object.defineProperty(exports, 'remove', {
	  enumerable: true,
	  get: function get() {
	    return _utils.remove;
	  }
	});
	Object.defineProperty(exports, 'hasOwn', {
	  enumerable: true,
	  get: function get() {
	    return _utils.hasOwn;
	  }
	});
	Object.defineProperty(exports, 'bind', {
	  enumerable: true,
	  get: function get() {
	    return _utils.bind;
	  }
	});
	Object.defineProperty(exports, 'toArray', {
	  enumerable: true,
	  get: function get() {
	    return _utils.toArray;
	  }
	});
	Object.defineProperty(exports, 'isObject', {
	  enumerable: true,
	  get: function get() {
	    return _utils.isObject;
	  }
	});
	Object.defineProperty(exports, 'isPlainObject', {
	  enumerable: true,
	  get: function get() {
	    return _utils.isPlainObject;
	  }
	});
	
	__webpack_require__(9);

/***/ },
/* 8 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.extend = extend;
	exports.def = def;
	exports.remove = remove;
	exports.hasOwn = hasOwn;
	exports.bind = bind;
	exports.toArray = toArray;
	exports.isObject = isObject;
	exports.isPlainObject = isPlainObject;
	/**
	 * Mix properties into target object.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 */
	
	function extend(target) {
	  for (var _len = arguments.length, src = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    src[_key - 1] = arguments[_key];
	  }
	
	  if (typeof Object.assign === 'function') {
	    Object.assign.apply(Object, [target].concat(src));
	  } else {
	    var first = src.shift();
	    for (var key in first) {
	      target[key] = first[key];
	    }
	    if (src.length) {
	      extend.apply(undefined, [target].concat(src));
	    }
	  }
	  return target;
	}
	
	/**
	 * Define a property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 * @param {Boolean} [enumerable]
	 */
	
	function def(obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}
	
	/**
	 * Remove an item from an array
	 *
	 * @param {Array} arr
	 * @param {*} item
	 */
	
	function remove(arr, item) {
	  if (arr.length) {
	    var index = arr.indexOf(item);
	    if (index > -1) {
	      return arr.splice(index, 1);
	    }
	  }
	}
	
	/**
	 * Check whether the object has the property.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @return {Boolean}
	 */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function hasOwn(obj, key) {
	  return hasOwnProperty.call(obj, key);
	}
	
	/**
	 * Simple bind, faster than native
	 *
	 * @param {Function} fn
	 * @param {Object} ctx
	 * @return {Function}
	 */
	
	function bind(fn, ctx) {
	  return function (a) {
	    var l = arguments.length;
	    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
	  };
	}
	
	/**
	 * Convert an Array-like object to a real Array.
	 *
	 * @param {Array-like} list
	 * @param {Number} [start] - start index
	 * @return {Array}
	 */
	
	function toArray(list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret;
	}
	
	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	function isObject(obj) {
	  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
	}
	
	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 *
	 * @param {*} obj
	 * @return {Boolean}
	 */
	
	var toString = Object.prototype.toString;
	var OBJECT_STRING = '[object Object]';
	function isPlainObject(obj) {
	  return toString.call(obj) === OBJECT_STRING;
	}

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	// fix Promise Problem on JSContext of iOS7~8
	// @see https://bugs.webkit.org/show_bug.cgi?id=135866
	// global.Promise = null
	__webpack_require__(10);
	__webpack_require__(30);
	__webpack_require__(56);
	__webpack_require__(60);

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(11)
	  , test    = {};
	test[__webpack_require__(13)('toStringTag')] = 'z';
	if(test + '' != '[object z]'){
	  __webpack_require__(17)(Object.prototype, 'toString', function toString(){
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(12)
	  , TAG = __webpack_require__(13)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 12 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(14)('wks')
	  , uid        = __webpack_require__(16)
	  , Symbol     = __webpack_require__(15).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(15)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 15 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 16 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(15)
	  , hide      = __webpack_require__(18)
	  , has       = __webpack_require__(28)
	  , SRC       = __webpack_require__(16)('src')
	  , TO_STRING = 'toString'
	  , $toString = Function[TO_STRING]
	  , TPL       = ('' + $toString).split(TO_STRING);
	
	__webpack_require__(29).inspectSource = function(it){
	  return $toString.call(it);
	};
	
	(module.exports = function(O, key, val, safe){
	  var isFunction = typeof val == 'function';
	  if(isFunction)has(val, 'name') || hide(val, 'name', key);
	  if(O[key] === val)return;
	  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if(O === global){
	    O[key] = val;
	  } else {
	    if(!safe){
	      delete O[key];
	      hide(O, key, val);
	    } else {
	      if(O[key])O[key] = val;
	      else hide(O, key, val);
	    }
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString(){
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(19)
	  , createDesc = __webpack_require__(27);
	module.exports = __webpack_require__(23) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(20)
	  , IE8_DOM_DEFINE = __webpack_require__(22)
	  , toPrimitive    = __webpack_require__(26)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(23) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(21);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(23) && !__webpack_require__(24)(function(){
	  return Object.defineProperty(__webpack_require__(25)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(24)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 24 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(21)
	  , document = __webpack_require__(15).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(21);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 29 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(31)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(34)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(32)
	  , defined   = __webpack_require__(33);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 32 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 33 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(35)
	  , $export        = __webpack_require__(36)
	  , redefine       = __webpack_require__(17)
	  , hide           = __webpack_require__(18)
	  , has            = __webpack_require__(28)
	  , Iterators      = __webpack_require__(39)
	  , $iterCreate    = __webpack_require__(40)
	  , setToStringTag = __webpack_require__(53)
	  , getPrototypeOf = __webpack_require__(54)
	  , ITERATOR       = __webpack_require__(13)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	module.exports = false;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(15)
	  , core      = __webpack_require__(29)
	  , hide      = __webpack_require__(18)
	  , redefine  = __webpack_require__(17)
	  , ctx       = __webpack_require__(37)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
	    , key, own, out, exp;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if(target)redefine(target, key, out, type & $export.U);
	    // export
	    if(exports[key] != out)hide(exports, key, exp);
	    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(38);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 38 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 39 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(41)
	  , descriptor     = __webpack_require__(27)
	  , setToStringTag = __webpack_require__(53)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(18)(IteratorPrototype, __webpack_require__(13)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(20)
	  , dPs         = __webpack_require__(42)
	  , enumBugKeys = __webpack_require__(51)
	  , IE_PROTO    = __webpack_require__(50)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(25)('iframe')
	    , i      = enumBugKeys.length
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(52).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(19)
	  , anObject = __webpack_require__(20)
	  , getKeys  = __webpack_require__(43);
	
	module.exports = __webpack_require__(23) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(44)
	  , enumBugKeys = __webpack_require__(51);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(28)
	  , toIObject    = __webpack_require__(45)
	  , arrayIndexOf = __webpack_require__(47)(false)
	  , IE_PROTO     = __webpack_require__(50)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(46)
	  , defined = __webpack_require__(33);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(12);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(45)
	  , toLength  = __webpack_require__(48)
	  , toIndex   = __webpack_require__(49);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(32)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(32)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(14)('keys')
	  , uid    = __webpack_require__(16);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 51 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(15).document && document.documentElement;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(19).f
	  , has = __webpack_require__(28)
	  , TAG = __webpack_require__(13)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(28)
	  , toObject    = __webpack_require__(55)
	  , IE_PROTO    = __webpack_require__(50)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(33);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var $iterators    = __webpack_require__(57)
	  , redefine      = __webpack_require__(17)
	  , global        = __webpack_require__(15)
	  , hide          = __webpack_require__(18)
	  , Iterators     = __webpack_require__(39)
	  , wks           = __webpack_require__(13)
	  , ITERATOR      = wks('iterator')
	  , TO_STRING_TAG = wks('toStringTag')
	  , ArrayValues   = Iterators.Array;
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype
	    , key;
	  if(proto){
	    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
	    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
	  }
	}

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(58)
	  , step             = __webpack_require__(59)
	  , Iterators        = __webpack_require__(39)
	  , toIObject        = __webpack_require__(45);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(34)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(13)('unscopables')
	  , ArrayProto  = Array.prototype;
	if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(18)(ArrayProto, UNSCOPABLES, {});
	module.exports = function(key){
	  ArrayProto[UNSCOPABLES][key] = true;
	};

/***/ },
/* 59 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(35)
	  , global             = __webpack_require__(15)
	  , ctx                = __webpack_require__(37)
	  , classof            = __webpack_require__(11)
	  , $export            = __webpack_require__(36)
	  , isObject           = __webpack_require__(21)
	  , anObject           = __webpack_require__(20)
	  , aFunction          = __webpack_require__(38)
	  , anInstance         = __webpack_require__(61)
	  , forOf              = __webpack_require__(62)
	  , setProto           = __webpack_require__(66).set
	  , speciesConstructor = __webpack_require__(69)
	  , task               = __webpack_require__(70).set
	  , microtask          = __webpack_require__(72)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(13)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(73)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(53)($Promise, PROMISE);
	__webpack_require__(74)(PROMISE);
	Wrapper = __webpack_require__(29)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(75)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 61 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(37)
	  , call        = __webpack_require__(63)
	  , isArrayIter = __webpack_require__(64)
	  , anObject    = __webpack_require__(20)
	  , toLength    = __webpack_require__(48)
	  , getIterFn   = __webpack_require__(65)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(20);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(39)
	  , ITERATOR   = __webpack_require__(13)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(11)
	  , ITERATOR  = __webpack_require__(13)('iterator')
	  , Iterators = __webpack_require__(39);
	module.exports = __webpack_require__(29).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(21)
	  , anObject = __webpack_require__(20);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(37)(Function.call, __webpack_require__(67).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(68)
	  , createDesc     = __webpack_require__(27)
	  , toIObject      = __webpack_require__(45)
	  , toPrimitive    = __webpack_require__(26)
	  , has            = __webpack_require__(28)
	  , IE8_DOM_DEFINE = __webpack_require__(22)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(23) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 68 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(20)
	  , aFunction = __webpack_require__(38)
	  , SPECIES   = __webpack_require__(13)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(37)
	  , invoke             = __webpack_require__(71)
	  , html               = __webpack_require__(52)
	  , cel                = __webpack_require__(25)
	  , global             = __webpack_require__(15)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(12)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 71 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(15)
	  , macrotask = __webpack_require__(70).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(12)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(17);
	module.exports = function(target, src, safe){
	  for(var key in src)redefine(target, key, src[key], safe);
	  return target;
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(15)
	  , dP          = __webpack_require__(19)
	  , DESCRIPTORS = __webpack_require__(23)
	  , SPECIES     = __webpack_require__(13)('species');
	
	module.exports = function(KEY){
	  var C = global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(13)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 76 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = init;
	var frameworks = void 0;
	
	var versionRegExp = /^\/\/ *(\{[^\}]*\}) *\r?\n/;
	
	function checkVersion(code) {
	  var info = void 0;
	  var result = versionRegExp.exec(code);
	  if (result) {
	    try {
	      info = JSON.parse(result[1]);
	    } catch (e) {}
	  }
	  return info;
	}
	
	var instanceMap = {};
	
	function createInstance(id, code, config, data) {
	  var info = instanceMap[id];
	  if (!info) {
	    info = checkVersion(code) || {};
	    if (!frameworks[info.framework]) {
	      info.framework = 'Weex';
	    }
	    instanceMap[id] = info;
	    config = config || {};
	    config.bundleVersion = info.version;
	    console.debug('[JS Framework] create an ' + info.framework + '@' + config.bundleVersion + ' instance from ' + config.bundleVersion);
	    return frameworks[info.framework].createInstance(id, code, config, data);
	  }
	  return new Error('invalid instance id "' + id + '"');
	}
	
	var methods = {
	  createInstance: createInstance
	};
	
	function genInit(methodName) {
	  methods[methodName] = function () {
	    for (var name in frameworks) {
	      var framework = frameworks[name];
	      if (framework && framework[methodName]) {
	        framework[methodName].apply(framework, arguments);
	      }
	    }
	  };
	}
	
	function genInstance(methodName) {
	  methods[methodName] = function () {
	    var id = arguments.length <= 0 ? undefined : arguments[0];
	    var info = instanceMap[id];
	    if (info && frameworks[info.framework]) {
	      var _frameworks$info$fram;
	
	      return (_frameworks$info$fram = frameworks[info.framework])[methodName].apply(_frameworks$info$fram, arguments);
	    }
	    return new Error('invalid instance id "' + id + '"');
	  };
	}
	
	function adaptInstance(methodName, nativeMethodName) {
	  methods[nativeMethodName] = function () {
	    var id = arguments.length <= 0 ? undefined : arguments[0];
	    var info = instanceMap[id];
	    if (info && frameworks[info.framework]) {
	      var _frameworks$info$fram2;
	
	      return (_frameworks$info$fram2 = frameworks[info.framework])[methodName].apply(_frameworks$info$fram2, arguments);
	    }
	    return new Error('invalid instance id "' + id + '"');
	  };
	}
	
	function init(config) {
	  frameworks = config.frameworks;
	  for (var name in frameworks) {
	    var framework = frameworks[name];
	    framework.init(config);
	  }
	
	  ;['destroyInstance', 'refreshInstance', 'receiveTasks', 'getRoot'].forEach(genInstance);['registerComponents', 'registerModules', 'registerMethods'].forEach(genInit);
	
	  adaptInstance('receiveTasks', 'callJS');
	
	  return methods;
	}

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _default = __webpack_require__(78);
	
	var Weex = _interopRequireWildcard(_default);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	exports.default = {
	  Weex: Weex
	}; // built by npm run build:config

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _create = __webpack_require__(79);
	
	Object.defineProperty(exports, 'createInstance', {
	  enumerable: true,
	  get: function get() {
	    return _create.createInstance;
	  }
	});
	
	var _life = __webpack_require__(108);
	
	Object.defineProperty(exports, 'init', {
	  enumerable: true,
	  get: function get() {
	    return _life.init;
	  }
	});
	Object.defineProperty(exports, 'refreshInstance', {
	  enumerable: true,
	  get: function get() {
	    return _life.refreshInstance;
	  }
	});
	Object.defineProperty(exports, 'destroyInstance', {
	  enumerable: true,
	  get: function get() {
	    return _life.destroyInstance;
	  }
	});
	
	var _register = __webpack_require__(109);
	
	Object.defineProperty(exports, 'registerComponents', {
	  enumerable: true,
	  get: function get() {
	    return _register.registerComponents;
	  }
	});
	Object.defineProperty(exports, 'registerModules', {
	  enumerable: true,
	  get: function get() {
	    return _register.registerModules;
	  }
	});
	Object.defineProperty(exports, 'registerMethods', {
	  enumerable: true,
	  get: function get() {
	    return _register.registerMethods;
	  }
	});
	
	var _bridge = __webpack_require__(110);
	
	Object.defineProperty(exports, 'receiveTasks', {
	  enumerable: true,
	  get: function get() {
	    return _bridge.receiveTasks;
	  }
	});
	
	var _misc = __webpack_require__(111);
	
	Object.defineProperty(exports, 'getRoot', {
	  enumerable: true,
	  get: function get() {
	    return _misc.getRoot;
	  }
	});

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.createInstance = createInstance;
	
	var _app = __webpack_require__(80);
	
	var _app2 = _interopRequireDefault(_app);
	
	var _map = __webpack_require__(107);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * create a Weex instance
	 *
	 * @param  {string} instanceId
	 * @param  {string} code
	 * @param  {object} [options] option `HAS_LOG` enable print log
	 * @param  {object} [data]
	 */
	function createInstance(instanceId, code, options, data) {
	  var instance = _map.instanceMap[instanceId];
	  options = options || {};
	
	  var result = void 0;
	  if (!instance) {
	    instance = new _app2.default(instanceId, options);
	    _map.instanceMap[instanceId] = instance;
	    result = instance.init(code, data);
	  } else {
	    result = new Error('invalid instance id "' + instanceId + '"');
	  }
	
	  return result || instance;
	}

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _ctrl = __webpack_require__(81);
	
	var ctrl = _interopRequireWildcard(_ctrl);
	
	var _utils = __webpack_require__(83);
	
	var _instance = __webpack_require__(105);
	
	var _instance2 = _interopRequireDefault(_instance);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	(0, _utils.extend)(_instance2.default.prototype, ctrl); /**
	                                                         * @fileOverview
	                                                         * Weex instance constructor & definition
	                                                         */


	exports.default = _instance2.default;

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _init = __webpack_require__(82);
	
	Object.defineProperty(exports, 'init', {
	  enumerable: true,
	  get: function get() {
	    return _init.init;
	  }
	});
	
	var _misc = __webpack_require__(104);
	
	Object.defineProperty(exports, 'updateActions', {
	  enumerable: true,
	  get: function get() {
	    return _misc.updateActions;
	  }
	});
	Object.defineProperty(exports, 'destroy', {
	  enumerable: true,
	  get: function get() {
	    return _misc.destroy;
	  }
	});
	Object.defineProperty(exports, 'getRootElement', {
	  enumerable: true,
	  get: function get() {
	    return _misc.getRootElement;
	  }
	});
	Object.defineProperty(exports, 'fireEvent', {
	  enumerable: true,
	  get: function get() {
	    return _misc.fireEvent;
	  }
	});
	Object.defineProperty(exports, 'callback', {
	  enumerable: true,
	  get: function get() {
	    return _misc.callback;
	  }
	});
	Object.defineProperty(exports, 'refreshData', {
	  enumerable: true,
	  get: function get() {
	    return _misc.refreshData;
	  }
	});

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.init = init;
	
	var _utils = __webpack_require__(83);
	
	var _bundle = __webpack_require__(87);
	
	/**
	 * @fileOverview
	 * instance controls from native
	 *
	 * - init bundle
	 * - fire event
	 * - callback
	 * - destroy
	 *
	 * corresponded with the API of instance manager (framework.js)
	 */
	
	function init(code, data) {
	  var _this = this;
	
	  console.debug('[JS Framework] Intialize an instance with:\n', data);
	
	  var result = void 0;
	  // @see: lib/app/bundle.js
	  var bundleDefine = (0, _utils.bind)(_bundle.define, this);
	  var bundleBootstrap = function bundleBootstrap(name, config, _data) {
	    result = (0, _bundle.bootstrap)(_this, name, config, _data || data);
	    _this.updateActions();
	    _this.doc.listener.createFinish();
	    console.debug('[JS Framework] After intialized an instance(' + _this.id + ')');
	  };
	
	  // backward(register/render)
	  var bundleRegister = (0, _utils.bind)(_bundle.register, this);
	  var bundleRender = function bundleRender(name, _data) {
	    result = (0, _bundle.bootstrap)(_this, name, {}, _data);
	  };
	
	  var bundleRequire = function bundleRequire(name) {
	    return function (_data) {
	      result = (0, _bundle.bootstrap)(_this, name, {}, _data);
	    };
	  };
	
	  var bundleDocument = this.doc;
	
	  var functionBody = void 0;
	  /* istanbul ignore if */
	  if (typeof code === 'function') {
	    // `function () {...}` -> `{...}`
	    // not very strict
	    functionBody = code.toString().substr(12);
	  } else if (code) {
	    functionBody = code.toString();
	  }
	
	  var _global = global;
	  var WXEnvironment = _global.WXEnvironment;
	
	
	  if (WXEnvironment) {
	    var fn = new Function('define', 'require', 'document', 'bootstrap', 'register', 'render', '__weex_define__', // alias for define
	    '__weex_bootstrap__', // alias for bootstrap
	    functionBody);
	
	    fn(bundleDefine, bundleRequire, bundleDocument, bundleBootstrap, bundleRegister, bundleRender, bundleDefine, bundleBootstrap);
	  }
	
	  return result;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/* global Image */
	
	'use strict';
	
	// const WEAPP_STYLE_ID = 'weapp-style'
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.vendors = exports.slice = exports.isArray = exports.typof = exports.isPlainObject = exports.isObject = exports.toArray = exports.bind = exports.hasOwn = exports.remove = exports.def = exports.extend = exports.frameUpdater = undefined;
	
	var _util = __webpack_require__(84);
	
	Object.defineProperty(exports, 'extend', {
	  enumerable: true,
	  get: function get() {
	    return _util.extend;
	  }
	});
	Object.defineProperty(exports, 'def', {
	  enumerable: true,
	  get: function get() {
	    return _util.def;
	  }
	});
	Object.defineProperty(exports, 'remove', {
	  enumerable: true,
	  get: function get() {
	    return _util.remove;
	  }
	});
	Object.defineProperty(exports, 'hasOwn', {
	  enumerable: true,
	  get: function get() {
	    return _util.hasOwn;
	  }
	});
	Object.defineProperty(exports, 'bind', {
	  enumerable: true,
	  get: function get() {
	    return _util.bind;
	  }
	});
	Object.defineProperty(exports, 'toArray', {
	  enumerable: true,
	  get: function get() {
	    return _util.toArray;
	  }
	});
	Object.defineProperty(exports, 'isObject', {
	  enumerable: true,
	  get: function get() {
	    return _util.isObject;
	  }
	});
	Object.defineProperty(exports, 'isPlainObject', {
	  enumerable: true,
	  get: function get() {
	    return _util.isPlainObject;
	  }
	});
	Object.defineProperty(exports, 'typof', {
	  enumerable: true,
	  get: function get() {
	    return _util.typof;
	  }
	});
	exports.getType = getType;
	exports.appendStyle = appendStyle;
	exports.getUniqueFromArray = getUniqueFromArray;
	exports.detectWebp = detectWebp;
	exports.detectSticky = detectSticky;
	exports.getRandom = getRandom;
	exports.getRgb = getRgb;
	exports.loopArray = loopArray;
	exports.throttle = throttle;
	
	var _frameUpdater = __webpack_require__(85);
	
	var _frameUpdater2 = _interopRequireDefault(_frameUpdater);
	
	var _array = __webpack_require__(86);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.frameUpdater = _frameUpdater2.default;
	exports.isArray = _array.isArray;
	exports.slice = _array.slice;
	var vendors = exports.vendors = ['ms', 'moz', 'webkit', 'o'];
	
	var _isWebpSupported = false;(function isSupportWebp() {
	  try {
	    (function () {
	      var webP = new Image();
	      webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdA' + 'SoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';
	      webP.onload = function () {
	        if (webP.height === 2) {
	          _isWebpSupported = true;
	        }
	      };
	    })();
	  } catch (e) {
	    // do nothing.
	  }
	})();
	
	var _isStickySupported = false;(function isSupportSticky() {
	  var element = document.createElement('div');
	  var elementStyle = element.style;
	  elementStyle.cssText = vendors.concat(['']).map(function (vendor) {
	    return 'position:' + (vendor ? '-' + vendor + '-' : '') + 'sticky';
	  }).join(';') + ';';
	  _isStickySupported = elementStyle.position.indexOf('sticky') !== -1;
	})();
	
	// export function extend (to, from) {
	//   for (const key in from) {
	//     to[key] = from[key]
	//   }
	//   return to
	// }
	
	// export function isPlainObject (obj) {
	//   return Object.prototype.toString.call(obj)
	//     .slice(8, -1).toLowerCase() === 'object'
	// }
	
	function getType(obj) {
	  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
	}
	
	function appendStyle(css, styleId, replace) {
	  var style = document.getElementById(styleId);
	  if (style && replace) {
	    style.parentNode.removeChild(style);
	    style = null;
	  }
	  if (!style) {
	    style = document.createElement('style');
	    style.type = 'text/css';
	    styleId && (style.id = styleId);
	    document.getElementsByTagName('head')[0].appendChild(style);
	  }
	  style.appendChild(document.createTextNode(css));
	}
	
	function getUniqueFromArray(arr) {
	  if (!(0, _array.isArray)(arr)) {
	    return [];
	  }
	  var res = [];
	  var unique = {};
	  var val = void 0;
	  for (var i = 0, l = arr.length; i < l; i++) {
	    val = arr[i];
	    if (unique[val]) {
	      continue;
	    }
	    unique[val] = true;
	    res.push(val);
	  }
	  return res;
	}
	
	function detectWebp() {
	  return _isWebpSupported;
	}
	
	function detectSticky() {
	  return _isStickySupported;
	}
	
	function getRandom(num) {
	  var _defaultNum = 10;
	  if (typeof num !== 'number' || num <= 0) {
	    num = _defaultNum;
	  }
	  var _max = Math.pow(10, num);
	  return Math.floor(Date.now() + Math.random() * _max) % _max;
	}
	
	function getRgb(color) {
	  var match = void 0;
	  color = color + '';
	  match = color.match(/#([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})/);
	  if (match) {
	    return {
	      r: parseInt(match[1], 16),
	      g: parseInt(match[2], 16),
	      b: parseInt(match[3], 16)
	    };
	  }
	  match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
	  if (match) {
	    return {
	      r: parseInt(match[1]),
	      g: parseInt(match[2]),
	      b: parseInt(match[3])
	    };
	  }
	}
	
	// direction: 'l' | 'r', default is 'r'
	// num: how many times to loop, should be a positive integer
	function loopArray(arr, num, direction) {
	  if (!(0, _array.isArray)(arr)) {
	    return;
	  }
	  var isLeft = (direction + '').toLowerCase() === 'l';
	  var len = arr.length;
	  num = num % len;
	  if (num < 0) {
	    num = -num;
	    isLeft = !isLeft;
	  }
	  if (num === 0) {
	    return arr;
	  }
	  var lp = void 0,
	      rp = void 0;
	  if (isLeft) {
	    lp = arr.slice(0, num);
	    rp = arr.slice(num);
	  } else {
	    lp = arr.slice(0, len - num);
	    rp = arr.slice(len - num);
	  }
	  return rp.concat(lp);
	}
	
	function throttle(func, wait) {
	  var result = void 0;
	  var timerId = null;
	  var previous = 0;
	  var context = void 0;
	  var args = void 0;
	  var later = function later() {
	    previous = Date.now();
	    timerId = null;
	    result = func.apply(context, args);
	  };
	  return function () {
	    var now = Date.now();
	    var remaining = wait - (now - previous);
	    context = this;
	    args = Array.prototype.slice.call(arguments);
	    if (remaining <= 0) {
	      clearTimeout(timerId);
	      timerId = null;
	      previous = now;
	      result = func.apply(context, args);
	    } else if (!timerId) {
	      timerId = setTimeout(later, remaining);
	    }
	    return result;
	  };
	}

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _utils = __webpack_require__(8);
	
	Object.defineProperty(exports, 'extend', {
	  enumerable: true,
	  get: function get() {
	    return _utils.extend;
	  }
	});
	Object.defineProperty(exports, 'def', {
	  enumerable: true,
	  get: function get() {
	    return _utils.def;
	  }
	});
	Object.defineProperty(exports, 'remove', {
	  enumerable: true,
	  get: function get() {
	    return _utils.remove;
	  }
	});
	Object.defineProperty(exports, 'hasOwn', {
	  enumerable: true,
	  get: function get() {
	    return _utils.hasOwn;
	  }
	});
	Object.defineProperty(exports, 'bind', {
	  enumerable: true,
	  get: function get() {
	    return _utils.bind;
	  }
	});
	Object.defineProperty(exports, 'toArray', {
	  enumerable: true,
	  get: function get() {
	    return _utils.toArray;
	  }
	});
	Object.defineProperty(exports, 'isObject', {
	  enumerable: true,
	  get: function get() {
	    return _utils.isObject;
	  }
	});
	Object.defineProperty(exports, 'isPlainObject', {
	  enumerable: true,
	  get: function get() {
	    return _utils.isPlainObject;
	  }
	});
	exports.isReserved = isReserved;
	exports.cached = cached;
	exports.typof = typof;
	
	
	/**
	 * Check if a string starts with $ or _
	 *
	 * @param {String} str
	 * @return {Boolean}
	 */
	
	function isReserved(str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F;
	}
	
	// can we use __proto__?
	var hasProto = exports.hasProto = '__proto__' in {};
	
	var _Set = void 0;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {
	  // use native Set when available.
	  exports._Set = _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  exports._Set = _Set = function _Set() {
	    this.set = Object.create(null);
	  };
	  _Set.prototype.has = function (key) {
	    return this.set[key] !== undefined;
	  };
	  _Set.prototype.add = function (key) {
	    this.set[key] = 1;
	  };
	  _Set.prototype.clear = function () {
	    this.set = Object.create(null);
	  };
	}
	
	exports._Set = _Set;
	
	/**
	 * Create a cached version of a pure function.
	 *
	 * @param {Function} fn
	 * @return {Function}
	 */
	
	function cached(fn) {
	  var cache = Object.create(null);
	  return function cachedFn(str) {
	    var hit = cache[str];
	    return hit || (cache[str] = fn(str));
	  };
	}
	
	/**
	 * Camelize a hyphen-delmited string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var camelizeRE = /-(\w)/g;
	var camelize = exports.camelize = cached(function (str) {
	  return str.replace(camelizeRE, toUpper);
	});
	
	function toUpper(_, c) {
	  return c ? c.toUpperCase() : '';
	}
	
	/**
	 * Hyphenate a camelCase string.
	 *
	 * @param {String} str
	 * @return {String}
	 */
	
	var hyphenateRE = /([a-z\d])([A-Z])/g;
	var hyphenate = exports.hyphenate = cached(function (str) {
	  return str.replace(hyphenateRE, '$1-$2').toLowerCase();
	});
	
	function typof(v) {
	  var s = Object.prototype.toString.call(v);
	  return s.substring(8, s.length - 1).toLowerCase();
	}

/***/ },
/* 85 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function (calllback) {
	  setTimeout(calllback, 16);
	};
	
	var rafId = void 0;
	var observers = [];
	var paused = false;
	
	exports.default = {
	  start: function start() {
	    if (rafId) {
	      return;
	    }
	
	    rafId = raf(function runLoop() {
	      if (!paused) {
	        for (var i = 0; i < observers.length; i++) {
	          observers[i]();
	        }
	        raf(runLoop);
	      }
	    });
	  },
	
	  isActive: function isActive() {
	    return !paused;
	  },
	
	  pause: function pause() {
	    paused = true;
	    rafId = undefined;
	  },
	
	  resume: function resume() {
	    paused = false;
	    this.start();
	  },
	
	  addUpdateObserver: function addUpdateObserver(observeMethod) {
	    observers.push(observeMethod);
	  }
	};

/***/ },
/* 86 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isArray = isArray;
	exports.slice = slice;
	function isArray(arr) {
	  return Array.isArray ? Array.isArray(arr) : Object.prototype.toString.call(arr) === '[object Array]';
	}
	
	function slice(arr, start, end) {
	  if (isArray(arr)) {
	    return arr.slice(start, end);
	  }
	  var slice = Array.prototype.slice;
	  return slice.call(arr, start, end);
	}

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _bootstrap = __webpack_require__(88);
	
	Object.defineProperty(exports, 'bootstrap', {
	  enumerable: true,
	  get: function get() {
	    return _bootstrap.bootstrap;
	  }
	});
	
	var _define = __webpack_require__(103);
	
	Object.defineProperty(exports, 'clearCommonModules', {
	  enumerable: true,
	  get: function get() {
	    return _define.clearCommonModules;
	  }
	});
	Object.defineProperty(exports, 'define', {
	  enumerable: true,
	  get: function get() {
	    return _define.define;
	  }
	});
	Object.defineProperty(exports, 'register', {
	  enumerable: true,
	  get: function get() {
	    return _define.register;
	  }
	});

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.bootstrap = bootstrap;
	
	var _vm = __webpack_require__(89);
	
	var _vm2 = _interopRequireDefault(_vm);
	
	var _utils = __webpack_require__(83);
	
	var _misc = __webpack_require__(102);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// import * as downgrade from '../downgrade'
	function bootstrap(app, name, config, data) {
	  console.debug('[JS Framework] bootstrap for ' + name);
	
	  var cleanName = void 0;
	
	  if ((0, _misc.isWeexComponent)(name)) {
	    cleanName = (0, _misc.removeWeexPrefix)(name);
	  } else if ((0, _misc.isNpmModule)(name)) {
	    cleanName = (0, _misc.removeJSSurfix)(name);
	    // check if define by old 'define' method
	    /* istanbul ignore if */
	    if (!app.customComponentMap[cleanName]) {
	      return new Error('It\'s not a component: ' + name);
	    }
	  } else {
	    return new Error('Wrong component name: ' + name);
	  }
	
	  config = (0, _utils.isPlainObject)(config) ? config : {};
	
	  console.log('transformerVersion: ' + config.transformerVersion + ', ' + ('available transformerVersion: ' + global.transformVersion));
	
	  // if (typeof config.transformerVersion === 'string' &&
	  //   typeof global.transformerVersion === 'string' &&
	  //   !semver.satisfies(config.transformerVersion,
	  //     global.transformerVersion)) {
	  //   return new Error(`JS Bundle version: ${config.transformerVersion} ` +
	  //     `not compatible with ${global.transformerVersion}`)
	  // }
	
	  // const _checkDowngrade = downgrade.check(config.downgrade)
	  /* istanbul ignore if */
	  // if (_checkDowngrade.isDowngrade) {
	  //   app.callTasks([{
	  //     module: 'instanceWrap',
	  //     method: 'error',
	  //     args: [
	  //       _checkDowngrade.errorType,
	  //       _checkDowngrade.code,
	  //       _checkDowngrade.errorMessage
	  //     ]
	  //   }])
	  //   return new Error(`Downgrade[${_checkDowngrade.code}]: ${_checkDowngrade.errorMessage}`)
	  // }
	
	  app.vm = new _vm2.default(cleanName, null, { _app: app }, null, data);
	} // import semver from 'semver'
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Vm;
	
	var _util = __webpack_require__(84);
	
	var _state = __webpack_require__(90);
	
	var _compiler = __webpack_require__(96);
	
	var _events = __webpack_require__(100);
	
	var _register = __webpack_require__(101);
	
	/**
	 * ViewModel constructor
	 *
	 * @param {string} type
	 * @param {object} options    component options
	 * @param {object} parentVm   which contains _app
	 * @param {object} parentEl   root element or frag block
	 * @param {object} mergedData external data
	 * @param {object} externalEvents external events
	 */
	function Vm(type, options, parentVm, parentEl, mergedData, externalEvents) {
	  this._parent = parentVm._realParent ? parentVm._realParent : parentVm;
	  this._app = parentVm._app;
	  parentVm._childrenVms && parentVm._childrenVms.push(this);
	
	  if (!options) {
	    options = this._app.customComponentMap[type] || {};
	  }
	  var data = options.data || {};
	
	  this._options = options;
	  this._methods = options.methods || {};
	  this._computed = options.computed || {};
	  this._css = options.style || {};
	  this._ids = {};
	  this._vmEvents = {};
	  this._childrenVms = [];
	  this._type = type;
	
	  // bind events and lifecycles
	  (0, _events.initEvents)(this, externalEvents);
	
	  console.debug('[JS Framework] "init" lifecycle in Vm(' + this._type + ')');
	  this.$emit('hook:init');
	  this._inited = true;
	
	  // proxy data and methods
	  // observe data and add this to vms
	  this._data = typeof data === 'function' ? data() : data;
	  if (mergedData) {
	    (0, _util.extend)(this._data, mergedData);
	  }
	  (0, _state.initState)(this);
	
	  console.debug('[JS Framework] "created" lifecycle in Vm(' + this._type + ')');
	  this.$emit('hook:created');
	  this._created = true;
	
	  // backward old ready entry
	  if (options.methods && options.methods.ready) {
	    console.warn('"exports.methods.ready" is deprecated, ' + 'please use "exports.created" instead');
	    options.methods.ready.call(this);
	  }
	
	  // if no parentElement then specify the documentElement
	  this._parentEl = parentEl || this._app.doc.documentElement;
	  (0, _compiler.build)(this);
	} /**
	   * @fileOverview
	   * ViewModel Constructor & definition
	   */
	
	(0, _events.mixinEvents)(Vm.prototype);
	
	(0, _util.extend)(Vm, {
	  registerModules: _register.registerModules,
	  registerMethods: _register.registerMethods
	});

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.initState = initState;
	exports.initData = initData;
	exports.initComputed = initComputed;
	exports.initMethods = initMethods;
	
	var _watcher = __webpack_require__(91);
	
	var _watcher2 = _interopRequireDefault(_watcher);
	
	var _dep = __webpack_require__(93);
	
	var _dep2 = _interopRequireDefault(_dep);
	
	var _observer = __webpack_require__(94);
	
	var _util = __webpack_require__(84);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/* eslint-disable */
	
	function initState(vm) {
	  vm._watchers = [];
	  initData(vm);
	  initComputed(vm);
	  initMethods(vm);
	}
	
	function initData(vm) {
	  var data = vm._data;
	
	  if (!(0, _util.isPlainObject)(data)) {
	    data = {};
	  }
	  // proxy data on instance
	  var keys = Object.keys(data);
	  var i = keys.length;
	  while (i--) {
	    (0, _observer.proxy)(vm, keys[i]);
	  }
	  // observe data
	  (0, _observer.observe)(data, vm);
	}
	
	function noop() {}
	
	function initComputed(vm) {
	  var computed = vm._computed;
	  if (computed) {
	    for (var key in computed) {
	      var userDef = computed[key];
	      var def = {
	        enumerable: true,
	        configurable: true
	      };
	      if (typeof userDef === 'function') {
	        def.get = makeComputedGetter(userDef, vm);
	        def.set = noop;
	      } else {
	        def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, vm) : (0, _util.bind)(userDef.get, vm) : noop;
	        def.set = userDef.set ? (0, _util.bind)(userDef.set, vm) : noop;
	      }
	      Object.defineProperty(vm, key, def);
	    }
	  }
	}
	
	function makeComputedGetter(getter, owner) {
	  var watcher = new _watcher2.default(owner, getter, null, {
	    lazy: true
	  });
	  return function computedGetter() {
	    if (watcher.dirty) {
	      watcher.evaluate();
	    }
	    if (_dep2.default.target) {
	      watcher.depend();
	    }
	    return watcher.value;
	  };
	}
	
	function initMethods(vm) {
	  var methods = vm._methods;
	  if (methods) {
	    for (var key in methods) {
	      vm[key] = methods[key];
	    }
	  }
	}

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Watcher;
	
	var _dep = __webpack_require__(93);
	
	var _dep2 = _interopRequireDefault(_dep);
	
	var _util = __webpack_require__(84);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/* eslint-disable */
	
	var uid = 0;
	// import { pushWatcher } from './batcher'
	
	var prevTarget = void 0;
	
	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 *
	 * @param {Vue} vm
	 * @param {String|Function} expOrFn
	 * @param {Function} cb
	 * @param {Object} options
	 *                 - {Array} filters
	 *                 - {Boolean} twoWay
	 *                 - {Boolean} deep
	 *                 - {Boolean} user
	 *                 - {Boolean} sync
	 *                 - {Boolean} lazy
	 *                 - {Function} [preProcess]
	 *                 - {Function} [postProcess]
	 * @constructor
	 */
	
	function Watcher(vm, expOrFn, cb, options) {
	  // mix in options
	  if (options) {
	    (0, _util.extend)(this, options);
	  }
	  var isFn = typeof expOrFn === 'function';
	  this.vm = vm;
	  vm._watchers.push(this);
	  this.expression = expOrFn;
	  this.cb = cb;
	  this.id = ++uid; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _util._Set();
	  this.newDepIds = new _util._Set();
	  // parse expression for getter
	  if (isFn) {
	    this.getter = expOrFn;
	  } else {
	    this.getter = (0, _util.parsePath)(expOrFn);
	    if (!this.getter) {
	      this.getter = function () {};
	      process.env.NODE_ENV !== 'production' && (0, _util.warn)('Failed watching path: ' + expOrFn + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
	    }
	  }
	  this.value = this.lazy ? undefined : this.get();
	  // state for avoiding false triggers for deep and Array
	  // watchers during vm._digest()
	  this.queued = this.shallow = false;
	}
	
	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	
	Watcher.prototype.get = function () {
	  this.beforeGet();
	  var value = this.getter.call(this.vm, this.vm);
	  // "touch" every property so they are all tracked as
	  // dependencies for deep watching
	  if (this.deep) {
	    traverse(value);
	  }
	  this.afterGet();
	  return value;
	};
	
	/**
	 * Prepare for dependency collection.
	 */
	
	Watcher.prototype.beforeGet = function () {
	  prevTarget = _dep2.default.target;
	  _dep2.default.target = this;
	};
	
	/**
	 * Add a dependency to this directive.
	 *
	 * @param {Dep} dep
	 */
	
	Watcher.prototype.addDep = function (dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};
	
	/**
	 * Clean up for dependency collection.
	 */
	
	Watcher.prototype.afterGet = function () {
	  _dep2.default.target = prevTarget;
	  var i = this.deps.length;
	  while (i--) {
	    var dep = this.deps[i];
	    if (!this.newDepIds.has(dep.id)) {
	      dep.removeSub(this);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};
	
	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 *
	 * @param {Boolean} shallow
	 */
	
	Watcher.prototype.update = function (shallow) {
	  if (this.lazy) {
	    this.dirty = true;
	  } else {
	    this.run();
	  }
	  // } else if (this.sync) {
	  //   this.run()
	  // } else {
	  //   // if queued, only overwrite shallow with non-shallow,
	  //   // but not the other way around.
	  //   this.shallow = this.queued
	  //     ? shallow
	  //       ? this.shallow
	  //       : false
	  //     : !!shallow
	  //   this.queued = true
	  //   pushWatcher(this)
	  // }
	};
	
	/**
	 * Batcher job interface.
	 * Will be called by the batcher.
	 */
	
	Watcher.prototype.run = function () {
	  if (this.active) {
	    var value = this.get();
	    if (value !== this.value ||
	    // Deep watchers and watchers on Object/Arrays should fire even
	    // when the value is the same, because the value may
	    // have mutated; but only do so if this is a
	    // non-shallow update (caused by a vm digest).
	    ((0, _util.isObject)(value) || this.deep) && !this.shallow) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      this.cb.call(this.vm, value, oldValue);
	    }
	    this.queued = this.shallow = false;
	  }
	};
	
	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	
	Watcher.prototype.evaluate = function () {
	  // avoid overwriting another watcher that is being
	  // collected.
	  var current = _dep2.default.target;
	  this.value = this.get();
	  this.dirty = false;
	  _dep2.default.target = current;
	};
	
	/**
	 * Depend on all deps collected by this watcher.
	 */
	
	Watcher.prototype.depend = function () {
	  var i = this.deps.length;
	  while (i--) {
	    this.deps[i].depend();
	  }
	};
	
	/**
	 * Remove self from all dependencies' subcriber list.
	 */
	
	Watcher.prototype.teardown = function () {
	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed or is performing a v-for
	    // re-render (the watcher list is then filtered by v-for).
	    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
	      (0, _util.remove)(this.vm._watchers, this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this.deps[i].removeSub(this);
	    }
	    this.active = false;
	    this.vm = this.cb = this.value = null;
	  }
	};
	
	/**
	 * Recrusively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 *
	 * @param {*} val
	 * @param {Set} seen
	 */
	
	var seenObjects = new _util._Set();
	function traverse(val, seen) {
	  var i = void 0,
	      keys = void 0,
	      isA = void 0,
	      isO = void 0;
	  if (!seen) {
	    seen = seenObjects;
	    seen.clear();
	  }
	  isA = Array.isArray(val);
	  isO = (0, _util.isObject)(val);
	  if (isA || isO) {
	    if (val.__ob__) {
	      var depId = val.__ob__.dep.id;
	      if (seen.has(depId)) {
	        return;
	      } else {
	        seen.add(depId);
	      }
	    }
	    if (isA) {
	      i = val.length;
	      while (i--) {
	        traverse(val[i], seen);
	      }
	    } else if (isO) {
	      keys = Object.keys(val);
	      i = keys.length;
	      while (i--) {
	        traverse(val[keys[i]], seen);
	      }
	    }
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(92)))

/***/ },
/* 92 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Dep;
	
	var _util = __webpack_require__(84);
	
	var uid = 0;
	
	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 *
	 * @constructor
	 */
	
	/* eslint-disable */
	
	function Dep() {
	  this.id = uid++;
	  this.subs = [];
	}
	
	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	
	/**
	 * Add a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.addSub = function (sub) {
	  this.subs.push(sub);
	};
	
	/**
	 * Remove a directive subscriber.
	 *
	 * @param {Directive} sub
	 */
	
	Dep.prototype.removeSub = function (sub) {
	  (0, _util.remove)(this.subs, sub);
	};
	
	/**
	 * Add self as a dependency to the target watcher.
	 */
	
	Dep.prototype.depend = function () {
	  Dep.target.addDep(this);
	};
	
	/**
	 * Notify all subscribers of a new value.
	 */
	
	Dep.prototype.notify = function () {
	  // stablize the subscriber list first
	  var subs = this.subs.slice();
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Observer = Observer;
	exports.observe = observe;
	exports.defineReactive = defineReactive;
	exports.set = set;
	exports.del = del;
	exports.proxy = proxy;
	exports.unproxy = unproxy;
	
	var _dep = __webpack_require__(93);
	
	var _dep2 = _interopRequireDefault(_dep);
	
	var _array = __webpack_require__(95);
	
	var _util = __webpack_require__(84);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var arrayKeys = Object.getOwnPropertyNames(_array.arrayMethods);
	
	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 *
	 * @param {Array|Object} value
	 * @constructor
	 */
	
	/* eslint-disable */
	
	function Observer(value) {
	  this.value = value;
	  this.dep = new _dep2.default();
	  (0, _util.def)(value, '__ob__', this);
	  if (Array.isArray(value)) {
	    var augment = _util.hasProto ? protoAugment : copyAugment;
	    augment(value, _array.arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	}
	
	// Instance methods
	
	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 *
	 * @param {Object} obj
	 */
	
	Observer.prototype.walk = function (obj) {
	  for (var key in obj) {
	    this.convert(key, obj[key]);
	  }
	};
	
	/**
	 * Observe a list of Array items.
	 *
	 * @param {Array} items
	 */
	
	Observer.prototype.observeArray = function (items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};
	
	/**
	 * Convert a property into getter/setter so we can emit
	 * the events when the property is accessed/changed.
	 *
	 * @param {String} key
	 * @param {*} val
	 */
	
	Observer.prototype.convert = function (key, val) {
	  defineReactive(this.value, key, val);
	};
	
	/**
	 * Add an owner vm, so that when $set/$delete mutations
	 * happen we can notify owner vms to proxy the keys and
	 * digest the watchers. This is only called when the object
	 * is observed as an instance's root $data.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.addVm = function (vm) {
	  (this.vms || (this.vms = [])).push(vm);
	};
	
	/**
	 * Remove an owner vm. This is called when the object is
	 * swapped out as an instance's $data object.
	 *
	 * @param {Vue} vm
	 */
	
	Observer.prototype.removeVm = function (vm) {
	  (0, _util.remove)(this.vms, vm);
	};
	
	// helpers
	
	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 *
	 * @param {Object|Array} target
	 * @param {Object} src
	 */
	
	function protoAugment(target, src) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}
	
	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 *
	 * @param {Object|Array} target
	 * @param {Object} proto
	 */
	
	function copyAugment(target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    (0, _util.def)(target, key, src[key]);
	  }
	}
	
	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 *
	 * @param {*} value
	 * @param {Vue} [vm]
	 * @return {Observer|undefined}
	 * @static
	 */
	
	function observe(value, vm) {
	  if (!(0, _util.isObject)(value)) {
	    return;
	  }
	  var ob = void 0;
	  if ((0, _util.hasOwn)(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if ((Array.isArray(value) || (0, _util.isPlainObject)(value)) && Object.isExtensible(value) && !value._isVue) {
	    ob = new Observer(value);
	  }
	  if (ob && vm) {
	    ob.addVm(vm);
	  }
	  return ob;
	}
	
	/**
	 * Define a reactive property on an Object.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 */
	
	function defineReactive(obj, key, val) {
	  var dep = new _dep2.default();
	
	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return;
	  }
	
	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;
	
	  var childOb = observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter() {
	      var value = getter ? getter.call(obj) : val;
	      if (_dep2.default.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (Array.isArray(value)) {
	          for (var e, i = 0, l = value.length; i < l; i++) {
	            e = value[i];
	            e && e.__ob__ && e.__ob__.dep.depend();
	          }
	        }
	      }
	      return value;
	    },
	    set: function reactiveSetter(newVal) {
	      var value = getter ? getter.call(obj) : val;
	      if (newVal === value) {
	        return;
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = observe(newVal);
	      dep.notify();
	    }
	  });
	}
	
	/**
	 * Set a property on an object. Adds the new property and
	 * triggers change notification if the property doesn't
	 * already exist.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 * @param {*} val
	 * @public
	 */
	
	function set(obj, key, val) {
	  if (Array.isArray(obj)) {
	    return obj.splice(key, 1, val);
	  }
	  if ((0, _util.hasOwn)(obj, key)) {
	    obj[key] = val;
	    return;
	  }
	  if (obj._isVue) {
	    set(obj._data, key, val);
	    return;
	  }
	  var ob = obj.__ob__;
	  if (!ob) {
	    obj[key] = val;
	    return;
	  }
	  ob.convert(key, val);
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      proxy(vm, key);
	      vm.$forceUpdate();
	    }
	  }
	  return val;
	}
	
	/**
	 * Delete a property and trigger change if necessary.
	 *
	 * @param {Object} obj
	 * @param {String} key
	 */
	
	function del(obj, key) {
	  if (!(0, _util.hasOwn)(obj, key)) {
	    return;
	  }
	  delete obj[key];
	  var ob = obj.__ob__;
	
	  if (!ob) {
	    if (obj._isVue) {
	      delete obj._data[key];
	      obj.$forceUpdate();
	    }
	    return;
	  }
	  ob.dep.notify();
	  if (ob.vms) {
	    var i = ob.vms.length;
	    while (i--) {
	      var vm = ob.vms[i];
	      unproxy(vm, key);
	      vm.$forceUpdate();
	    }
	  }
	}
	
	var KEY_WORDS = ['$index', '$value', '$event'];
	function proxy(vm, key) {
	  if (KEY_WORDS.indexOf(key) > -1 || !(0, _util.isReserved)(key)) {
	    Object.defineProperty(vm, key, {
	      configurable: true,
	      enumerable: true,
	      get: function proxyGetter() {
	        return vm._data[key];
	      },
	      set: function proxySetter(val) {
	        vm._data[key] = val;
	      }
	    });
	  }
	}
	
	function unproxy(vm, key) {
	  if (!(0, _util.isReserved)(key)) {
	    delete vm[key];
	  }
	}

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.arrayMethods = undefined;
	
	var _util = __webpack_require__(84);
	
	var arrayProto = Array.prototype; /* eslint-disable */
	
	var arrayMethods = exports.arrayMethods = Object.create(arrayProto)
	
	/**
	 * Intercept mutating methods and emit events
	 */
	
	;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  (0, _util.def)(arrayMethods, method, function mutator() {
	    // avoid leaking arguments:
	    // http://jsperf.com/closure-with-arguments
	    var i = arguments.length;
	    var args = new Array(i);
	    while (i--) {
	      args[i] = arguments[i];
	    }
	    var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted = void 0;
	    switch (method) {
	      case 'push':
	        inserted = args;
	        break;
	      case 'unshift':
	        inserted = args;
	        break;
	      case 'splice':
	        inserted = args.slice(2);
	        break;
	    }
	    if (inserted) ob.observeArray(inserted);
	    // notify change
	    ob.dep.notify();
	    return result;
	  });
	});
	
	/**
	 * Swap the element at the given index with a new value
	 * and emits corresponding event.
	 *
	 * @param {Number} index
	 * @param {*} val
	 * @return {*} - replaced element
	 */
	
	(0, _util.def)(arrayProto, '$set', function $set(index, val) {
	  if (index >= this.length) {
	    this.length = index + 1;
	  }
	  return this.splice(index, 1, val)[0];
	});
	
	/**
	 * Convenience method to remove the element at given index.
	 *
	 * @param {Number} index
	 * @param {*} val
	 */
	
	(0, _util.def)(arrayProto, '$remove', function $remove(index) {
	  /* istanbul ignore if */
	  if (!this.length) return;
	  if (typeof index !== 'number') {
	    index = this.indexOf(index);
	  }
	  if (index > -1) {
	    this.splice(index, 1);
	  }
	});

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.build = build;
	
	var _util = __webpack_require__(84);
	
	var _state = __webpack_require__(90);
	
	var _directive = __webpack_require__(97);
	
	var _domHelper = __webpack_require__(99);
	
	/**
	 * build(externalDirs)
	 *   createVm()
	 *   merge(externalDirs, dirs)
	 *   compile(template, parentNode)
	 *     if (type is content) create contentNode
	 *     else if (dirs have v-for) foreach -> create context
	 *       -> compile(templateWithoutFor, parentNode): diff(list) onchange
	 *     else if (dirs have v-if) assert
	 *       -> compile(templateWithoutIf, parentNode): toggle(shown) onchange
	 *     else if (type is dynamic)
	 *       -> compile(templateWithoutDynamicType, parentNode): watch(type) onchange
	 *     else if (type is custom)
	 *       addChildVm(vm, parentVm)
	 *       build(externalDirs)
	 *       foreach childNodes -> compile(childNode, template)
	 *     else if (type is native)
	 *       set(dirs): update(id/attr/style/class) onchange
	 *       append(template, parentNode)
	 *       foreach childNodes -> compile(childNode, template)
	 */
	/**
	 * @fileOverview
	 * ViewModel template parser & data-binding process
	 *
	 * required:
	 * index.js: Vm
	 * dom-helper.js: createElement, createBlock
	 * dom-helper.js: attachTarget, moveTarget, removeTarget
	 * directive.js: bindElement, bindSubVm, setId, watch
	 * events.js: $on
	 */
	
	function build(vm) {
	  var opt = vm._options || {};
	  var template = opt.template || {};
	
	  if (opt.replace) {
	    if (template.children && template.children.length === 1) {
	      compile(vm, template.children[0], vm._parentEl);
	    } else {
	      compile(vm, template.children, vm._parentEl);
	    }
	  } else {
	    compile(vm, template, vm._parentEl);
	  }
	
	  console.debug('[JS Framework] "ready" lifecycle in Vm(' + vm._type + ')');
	  vm.$emit('hook:ready');
	  vm._ready = true;
	}
	
	/**
	 * Generate elements by child or children and append to parent elements.
	 * Root element info would be merged if has. The first argument may be an array
	 * if the root element with options.replace has not only one child.
	 *
	 * @param {object|array} target
	 * @param {object}       dest
	 * @param {object}       meta
	 */
	function compile(vm, target, dest, meta) {
	  var app = vm._app || {};
	
	  if (app.lastSignal === -1) {
	    return;
	  }
	
	  if (targetIsFragment(target)) {
	    compileFragment(vm, target, dest, meta);
	    return;
	  }
	  meta = meta || {};
	  if (targetIsContent(target)) {
	    console.debug('[JS Framework] compile "content" block by', target);
	    vm._content = (0, _domHelper.createBlock)(vm, dest);
	    return;
	  }
	
	  if (targetNeedCheckRepeat(target, meta)) {
	    console.debug('[JS Framework] compile "repeat" logic by', target);
	    compileRepeat(vm, target, dest);
	    return;
	  }
	  if (targetNeedCheckShown(target, meta)) {
	    console.debug('[JS Framework] compile "if" logic by', target);
	    compileShown(vm, target, dest, meta);
	    return;
	  }
	  var typeGetter = meta.type || target.type;
	  if (targetNeedCheckType(typeGetter, meta)) {
	    compileType(vm, target, dest, typeGetter, meta);
	    return;
	  }
	  var type = typeGetter;
	  var component = targetIsComposed(vm, target, type);
	  if (component) {
	    console.debug('[JS Framework] compile composed component by', target);
	    compileCustomComponent(vm, component, target, dest, type, meta);
	    return;
	  }
	  console.debug('[JS Framework] compile native component by', target);
	  compileNativeComponent(vm, target, dest, type);
	}
	
	/**
	 * Check if target is a fragment (an array).
	 *
	 * @param  {object}  target
	 * @return {boolean}
	 */
	function targetIsFragment(target) {
	  return Array.isArray(target);
	}
	
	/**
	 * Check if target type is content/slot.
	 *
	 * @param  {object}  target
	 * @return {boolean}
	 */
	function targetIsContent(target) {
	  return target.type === 'content' || target.type === 'slot';
	}
	
	/**
	 * Check if target need to compile by a list.
	 *
	 * @param  {object}  target
	 * @param  {object}  meta
	 * @return {boolean}
	 */
	function targetNeedCheckRepeat(target, meta) {
	  return !meta.hasOwnProperty('repeat') && target.repeat;
	}
	
	/**
	 * Check if target need to compile by a boolean value.
	 *
	 * @param  {object}  target
	 * @param  {object}  meta
	 * @return {boolean}
	 */
	function targetNeedCheckShown(target, meta) {
	  return !meta.hasOwnProperty('shown') && target.shown;
	}
	
	/**
	 * Check if target need to compile by a dynamic type.
	 *
	 * @param  {string|function} typeGetter
	 * @param  {object}          meta
	 * @return {boolean}
	 */
	function targetNeedCheckType(typeGetter, meta) {
	  return typeof typeGetter === 'function' && !meta.hasOwnProperty('type');
	}
	
	/**
	 * Check if this kind of component is composed.
	 *
	 * @param  {string}  type
	 * @return {boolean}
	 */
	function targetIsComposed(vm, target, type) {
	  var component = void 0;
	  if (vm._app && vm._app.customComponentMap) {
	    component = vm._app.customComponentMap[type];
	  }
	  if (vm._options && vm._options.components) {
	    component = vm._options.components[type];
	  }
	  if (target.component) {
	    component = component || {};
	  }
	  return component;
	}
	
	/**
	 * Compile a list of targets.
	 *
	 * @param {object} target
	 * @param {object} dest
	 * @param {object} meta
	 */
	function compileFragment(vm, target, dest, meta) {
	  var fragBlock = (0, _domHelper.createBlock)(vm, dest);
	  target.forEach(function (child) {
	    compile(vm, child, fragBlock, meta);
	  });
	}
	
	/**
	 * Compile a target with repeat directive.
	 *
	 * @param {object} target
	 * @param {object} dest
	 */
	function compileRepeat(vm, target, dest) {
	  var repeat = target.repeat;
	  var oldStyle = typeof repeat === 'function';
	  var getter = repeat.getter || repeat.expression || repeat;
	  if (typeof getter !== 'function') {
	    getter = function getter() {
	      return [];
	    };
	  }
	  var key = repeat.key || '$index';
	  var value = repeat.value || '$value';
	  var trackBy = repeat.trackBy || target.trackBy || target.attr && target.attr.trackBy;
	
	  var fragBlock = (0, _domHelper.createBlock)(vm, dest);
	  fragBlock.children = [];
	  fragBlock.data = [];
	  fragBlock.vms = [];
	
	  bindRepeat(vm, target, fragBlock, { getter: getter, key: key, value: value, trackBy: trackBy, oldStyle: oldStyle });
	}
	
	/**
	 * Compile a target with if directive.
	 *
	 * @param {object} target
	 * @param {object} dest
	 * @param {object} meta
	 */
	function compileShown(vm, target, dest, meta) {
	  var newMeta = { shown: true };
	  var fragBlock = (0, _domHelper.createBlock)(vm, dest);
	
	  if (dest.element && dest.children) {
	    dest.children.push(fragBlock);
	  }
	
	  if (meta.repeat) {
	    newMeta.repeat = meta.repeat;
	  }
	
	  bindShown(vm, target, fragBlock, newMeta);
	}
	
	/**
	 * Compile a target with dynamic component type.
	 *
	 * @param {object}   target
	 * @param {object}   dest
	 * @param {function} typeGetter
	 */
	function compileType(vm, target, dest, typeGetter, meta) {
	  var type = typeGetter.call(vm);
	  var newMeta = (0, _util.extend)({ type: type }, meta);
	  var fragBlock = (0, _domHelper.createBlock)(vm, dest);
	
	  if (dest.element && dest.children) {
	    dest.children.push(fragBlock);
	  }
	
	  (0, _directive.watch)(vm, typeGetter, function (value) {
	    var newMeta = (0, _util.extend)({ type: value }, meta);
	    (0, _domHelper.removeTarget)(vm, fragBlock, true);
	    compile(vm, target, fragBlock, newMeta);
	  });
	
	  compile(vm, target, fragBlock, newMeta);
	}
	
	/**
	 * Compile a composed component.
	 *
	 * @param {object} target
	 * @param {object} dest
	 * @param {string} type
	 */
	function compileCustomComponent(vm, component, target, dest, type, meta) {
	  var Ctor = vm.constructor;
	  var subVm = new Ctor(type, component, vm, dest, undefined, {
	    'hook:init': function hookInit() {
	      (0, _directive.setId)(vm, null, target.id, this);
	      // bind template earlier because of lifecycle issues
	      this._externalBinding = {
	        parent: vm,
	        template: target
	      };
	    },
	    'hook:created': function hookCreated() {
	      (0, _directive.bindSubVm)(vm, this, target, meta.repeat);
	    },
	    'hook:ready': function hookReady() {
	      if (this._content) {
	        compileChildren(vm, target, this._content);
	      }
	    }
	  });
	  (0, _directive.bindSubVmAfterInitialized)(vm, subVm, target);
	}
	
	/**
	 * Generate element from template and attach to the dest if needed.
	 * The time to attach depends on whether the mode status is node or tree.
	 *
	 * @param {object} template
	 * @param {object} dest
	 * @param {string} type
	 */
	function compileNativeComponent(vm, template, dest, type) {
	  (0, _directive.applyNaitveComponentOptions)(template);
	
	  var element = void 0;
	  if (dest.ref === '_documentElement') {
	    // if its parent is documentElement then it's a body
	    console.debug('[JS Framework] compile to create body for ' + type);
	    element = (0, _domHelper.createBody)(vm, type);
	  } else {
	    console.debug('[JS Framework] compile to create element for ' + type);
	    element = (0, _domHelper.createElement)(vm, type);
	  }
	
	  if (!vm._rootEl) {
	    vm._rootEl = element;
	    // bind event earlier because of lifecycle issues
	    var binding = vm._externalBinding || {};
	    var target = binding.template;
	    var parentVm = binding.parent;
	    if (target && target.events && parentVm && element) {
	      for (var _type in target.events) {
	        var handler = parentVm[target.events[_type]];
	        if (handler) {
	          element.addEvent(_type, (0, _util.bind)(handler, parentVm));
	        }
	      }
	    }
	  }
	
	  (0, _directive.bindElement)(vm, element, template);
	
	  if (template.attr && template.attr.append) {
	    // backward, append prop in attr
	    template.append = template.attr.append;
	  }
	
	  if (template.append) {
	    // give the append attribute for ios adaptation
	    element.attr = element.attr || {};
	    element.attr.append = template.append;
	  }
	
	  var treeMode = template.append === 'tree';
	  var app = vm._app || {};
	  if (app.lastSignal !== -1 && !treeMode) {
	    console.debug('[JS Framework] compile to append single node for', element);
	    app.lastSignal = (0, _domHelper.attachTarget)(vm, element, dest);
	  }
	  if (app.lastSignal !== -1) {
	    compileChildren(vm, template, element);
	  }
	  if (app.lastSignal !== -1 && treeMode) {
	    console.debug('[JS Framework] compile to append whole tree for', element);
	    app.lastSignal = (0, _domHelper.attachTarget)(vm, element, dest);
	  }
	}
	
	/**
	 * Set all children to a certain parent element.
	 *
	 * @param {object} template
	 * @param {object} dest
	 */
	function compileChildren(vm, template, dest) {
	  var app = vm._app || {};
	  var children = template.children;
	  if (children && children.length) {
	    children.every(function (child) {
	      compile(vm, child, dest);
	      return app.lastSignal !== -1;
	    });
	  }
	}
	
	/**
	 * Watch the list update and refresh the changes.
	 *
	 * @param {object} target
	 * @param {object} fragBlock {vms, data, children}
	 * @param {object} info      {getter, key, value, trackBy, oldStyle}
	 */
	function bindRepeat(vm, target, fragBlock, info) {
	  var vms = fragBlock.vms;
	  var children = fragBlock.children;
	  var getter = info.getter;
	  var trackBy = info.trackBy;
	  var oldStyle = info.oldStyle;
	
	  var keyName = info.key;
	  var valueName = info.value;
	
	  function compileItem(item, index, context) {
	    var mergedData = void 0;
	    if (oldStyle) {
	      mergedData = item;
	      if ((0, _util.isObject)(item)) {
	        mergedData[keyName] = index;
	        if (!mergedData.hasOwnProperty('INDEX')) {
	          Object.defineProperty(mergedData, 'INDEX', {
	            value: function value() {
	              console.warn('[JS Framework] "INDEX" in repeat is deprecated, ' + 'please use "$index" instead');
	            }
	          });
	        }
	      } else {
	        console.warn('[JS Framework] Each list item must be an object in old-style repeat, ' + 'please use `repeat={{v in list}}` instead.');
	        mergedData = {};
	        mergedData[keyName] = index;
	        mergedData[valueName] = item;
	      }
	    } else {
	      mergedData = {};
	      mergedData[keyName] = index;
	      mergedData[valueName] = item;
	    }
	    var newContext = mergeContext(context, mergedData);
	    vms.push(newContext);
	    compile(newContext, target, fragBlock, { repeat: item });
	  }
	
	  var list = watchBlock(vm, fragBlock, getter, 'repeat', function (data) {
	    console.debug('[JS Framework] the "repeat" item has changed', data);
	    if (!fragBlock) {
	      return;
	    }
	
	    var oldChildren = children.slice();
	    var oldVms = vms.slice();
	    var oldData = fragBlock.data.slice();
	    // 1. collect all new refs track by
	    var trackMap = {};
	    var reusedMap = {};
	    data.forEach(function (item, index) {
	      var key = trackBy ? item[trackBy] : oldStyle ? item[keyName] : index;
	      /* istanbul ignore if */
	      if (key == null || key === '') {
	        return;
	      }
	      trackMap[key] = item;
	    });
	
	    // 2. remove unused element foreach old item
	    var reusedList = [];
	    oldData.forEach(function (item, index) {
	      var key = trackBy ? item[trackBy] : oldStyle ? item[keyName] : index;
	      if (trackMap.hasOwnProperty(key)) {
	        reusedMap[key] = {
	          item: item, index: index, key: key,
	          target: oldChildren[index],
	          vm: oldVms[index]
	        };
	        reusedList.push(item);
	      } else {
	        (0, _domHelper.removeTarget)(vm, oldChildren[index]);
	      }
	    });
	
	    // 3. create new element foreach new item
	    children.length = 0;
	    vms.length = 0;
	    fragBlock.data = data.slice();
	    fragBlock.updateMark = fragBlock.start;
	
	    data.forEach(function (item, index) {
	      var key = trackBy ? item[trackBy] : oldStyle ? item[keyName] : index;
	      var reused = reusedMap[key];
	      if (reused) {
	        if (reused.item === reusedList[0]) {
	          reusedList.shift();
	        } else {
	          reusedList.$remove(reused.item);
	          (0, _domHelper.moveTarget)(vm, reused.target, fragBlock.updateMark, true);
	        }
	        children.push(reused.target);
	        vms.push(reused.vm);
	        if (oldStyle) {
	          reused.vm = item;
	        } else {
	          reused.vm[valueName] = item;
	        }
	        reused.vm[keyName] = index;
	        fragBlock.updateMark = reused.target;
	      } else {
	        compileItem(item, index, vm);
	      }
	    });
	
	    delete fragBlock.updateMark;
	  });
	
	  fragBlock.data = list.slice(0);
	  list.forEach(function (item, index) {
	    compileItem(item, index, vm);
	  });
	}
	
	/**
	 * Watch the display update and add/remove the element.
	 *
	 * @param  {object} target
	 * @param  {object} fragBlock
	 * @param  {object} context
	 */
	function bindShown(vm, target, fragBlock, meta) {
	  var display = watchBlock(vm, fragBlock, target.shown, 'shown', function (display) {
	    console.debug('[JS Framework] the "if" item was changed', display);
	
	    if (!fragBlock || !!fragBlock.display === !!display) {
	      return;
	    }
	    fragBlock.display = !!display;
	    if (display) {
	      compile(vm, target, fragBlock, meta);
	    } else {
	      (0, _domHelper.removeTarget)(vm, fragBlock, true);
	    }
	  });
	
	  fragBlock.display = !!display;
	  if (display) {
	    compile(vm, target, fragBlock, meta);
	  }
	}
	
	/**
	 * Watch calc value changes and append certain type action to differ.
	 * It is used for if or repeat data-binding generator.
	 *
	 * @param  {object}   fragBlock
	 * @param  {function} calc
	 * @param  {string}   type
	 * @param  {function} handler
	 * @return {any}      init value of calc
	 */
	function watchBlock(vm, fragBlock, calc, type, handler) {
	  var differ = vm && vm._app && vm._app.differ;
	  var config = {};
	  var depth = (fragBlock.element.depth || 0) + 1;
	
	  return (0, _directive.watch)(vm, calc, function (value) {
	    config.latestValue = value;
	    if (differ && !config.recorded) {
	      differ.append(type, depth, fragBlock.blockId, function () {
	        var latestValue = config.latestValue;
	        handler(latestValue);
	        config.recorded = false;
	        config.latestValue = undefined;
	      });
	    }
	    config.recorded = true;
	  });
	}
	
	/**
	 * Clone a context and merge certain data.
	 *
	 * @param  {object} mergedData
	 * @return {object}
	 */
	function mergeContext(context, mergedData) {
	  var newContext = Object.create(context);
	  newContext._data = mergedData;
	  (0, _state.initData)(newContext);
	  (0, _state.initComputed)(newContext);
	  newContext._realParent = context;
	  return newContext;
	}

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /**
	                                                                                                                                                                                                                                                   * @fileOverview
	                                                                                                                                                                                                                                                   * Directive Parser
	                                                                                                                                                                                                                                                   */
	
	exports.applyNaitveComponentOptions = applyNaitveComponentOptions;
	exports.bindElement = bindElement;
	exports.bindSubVm = bindSubVm;
	exports.bindSubVmAfterInitialized = bindSubVmAfterInitialized;
	exports.setId = setId;
	exports.watch = watch;
	
	var _util = __webpack_require__(84);
	
	var _watcher = __webpack_require__(91);
	
	var _watcher2 = _interopRequireDefault(_watcher);
	
	var _config = __webpack_require__(98);
	
	var _config2 = _interopRequireDefault(_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var nativeComponentMap = _config2.default.nativeComponentMap;
	
	
	var SETTERS = {
	  attr: 'setAttr',
	  style: 'setStyle',
	  event: 'addEvent'
	};
	
	/**
	 * apply the native component's options(specified by template.type)
	 * to the template
	 */
	function applyNaitveComponentOptions(template) {
	  var type = template.type;
	
	  var options = nativeComponentMap[type];
	
	  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
	    for (var key in options) {
	      if (template[key] == null) {
	        template[key] = options[key];
	      } else if ((0, _util.typof)(template[key]) === 'object' && (0, _util.typof)(options[key]) === 'object') {
	        for (var subkey in options[key]) {
	          if (template[key][subkey] == null) {
	            template[key][subkey] = options[key][subkey];
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * bind all id, attr, classnames, style, events to an element
	 */
	function bindElement(vm, el, template) {
	  setId(vm, el, template.id, vm);
	  setAttr(vm, el, template.attr);
	  setClass(vm, el, template.classList);
	  setStyle(vm, el, template.style);
	  bindEvents(vm, el, template.events);
	}
	
	/**
	 * bind all props to sub vm and bind all style, events to the root element
	 * of the sub vm if it doesn't have a replaced multi-node fragment
	 */
	function bindSubVm(vm, subVm, template, repeatItem) {
	  subVm = subVm || {};
	  template = template || {};
	
	  var options = subVm._options || {};
	
	  // bind props
	  var props = options.props;
	
	  if (Array.isArray(props)) {
	    props = props.reduce(function (result, value) {
	      result[value] = true;
	      return result;
	    }, {});
	  }
	
	  mergeProps(repeatItem, props, vm, subVm);
	  mergeProps(template.attr, props, vm, subVm);
	}
	
	function bindSubVmAfterInitialized(vm, subVm, template) {
	  mergeClassStyle(template.classList, vm, subVm);
	  mergeStyle(template.style, vm, subVm);
	}
	
	function mergeProps(target, props, vm, subVm) {
	  if (!target) {
	    return;
	  }
	
	  var _loop = function _loop(key) {
	    if (!props || props[key]) {
	      var value = target[key];
	      if (typeof value === 'function') {
	        var returnValue = watch(vm, value, function (v) {
	          subVm[key] = v;
	        });
	        subVm[key] = returnValue;
	      } else {
	        subVm[key] = value;
	      }
	    }
	  };
	
	  for (var key in target) {
	    _loop(key);
	  }
	}
	
	function mergeStyle(target, vm, subVm) {
	  var _loop2 = function _loop2(key) {
	    var value = target[key];
	    if (typeof value === 'function') {
	      var returnValue = watch(vm, value, function (v) {
	        if (subVm._rootEl) {
	          subVm._rootEl.setStyle(key, v);
	        }
	      });
	      subVm._rootEl.setStyle(key, returnValue);
	    } else {
	      if (subVm._rootEl) {
	        subVm._rootEl.setStyle(key, value);
	      }
	    }
	  };
	
	  for (var key in target) {
	    _loop2(key);
	  }
	}
	
	function mergeClassStyle(target, vm, subVm) {
	  var css = vm._options && vm._options.style || {};
	
	  /* istanbul ignore if */
	  if (!subVm._rootEl) {
	    return;
	  }
	
	  if (typeof target === 'function') {
	    var _value = watch(vm, target, function (v) {
	      setClassStyle(subVm._rootEl, css, v);
	    });
	    setClassStyle(subVm._rootEl, css, _value);
	  } else if (target != null) {
	    setClassStyle(subVm._rootEl, css, target);
	  }
	}
	
	/**
	 * bind id to an element
	 * each id is unique in a whole vm
	 */
	function setId(vm, el, id, target) {
	  var map = Object.create(null);
	
	  Object.defineProperties(map, {
	    vm: {
	      value: target,
	      writable: false,
	      configurable: false
	    },
	    el: {
	      get: function get() {
	        return el || target._rootEl;
	      },
	      configurable: false
	    }
	  });
	
	  if (typeof id === 'function') {
	    var handler = id;
	    id = handler.call(vm);
	    if (id) {
	      vm._ids[id] = map;
	    }
	    watch(vm, handler, function (newId) {
	      if (newId) {
	        vm._ids[newId] = map;
	      }
	    });
	  } else if (id && typeof id === 'string') {
	    vm._ids[id] = map;
	  }
	}
	
	/**
	 * bind attr to an element
	 */
	function setAttr(vm, el, attr) {
	  bindDir(vm, el, 'attr', attr);
	}
	
	function setClassStyle(el, css, classList) {
	  var classStyle = {};
	  var length = classList.length;
	
	  for (var i = 0; i < length; i++) {
	    var style = css[classList[i]];
	    if (style) {
	      for (var key in style) {
	        classStyle[key] = style[key];
	      }
	    }
	  }
	  el.setClassStyle(classStyle);
	}
	
	/**
	 * bind classnames to an element
	 */
	function setClass(vm, el, classList) {
	  if (typeof classList !== 'function' && !Array.isArray(classList)) {
	    return;
	  }
	  if (Array.isArray(classList) && !classList.length) {
	    el.setClassStyle({});
	    return;
	  }
	
	  var style = vm._options && vm._options.style || {};
	  if (typeof classList === 'function') {
	    var _value2 = watch(vm, classList, function (v) {
	      setClassStyle(el, style, v);
	    });
	    setClassStyle(el, style, _value2);
	  } else {
	    setClassStyle(el, style, classList);
	  }
	}
	
	/**
	 * bind style to an element
	 */
	function setStyle(vm, el, style) {
	  bindDir(vm, el, 'style', style);
	}
	
	/**
	 * add an event type and handler to an element and generate a dom update
	 */
	function setEvent(vm, el, type, handler) {
	  el.addEvent(type, (0, _util.bind)(handler, vm));
	}
	
	/**
	 * add all events of an element
	 */
	function bindEvents(vm, el, events) {
	  if (!events) {
	    return;
	  }
	  var keys = Object.keys(events);
	  var i = keys.length;
	  while (i--) {
	    var key = keys[i];
	    var handler = events[key];
	    if (typeof handler === 'string') {
	      handler = vm[handler];
	      /* istanbul ignore if */
	      if (!handler) {
	        console.debug('[JS Framework] The method "' + handler + '" is not defined.');
	      }
	    }
	    setEvent(vm, el, key, handler);
	  }
	}
	
	/**
	 * set a series of members as a kind of an element
	 * for example: style, attr, ...
	 * if the value is a function then bind the data changes
	 */
	function bindDir(vm, el, name, data) {
	  if (!data) {
	    return;
	  }
	  var keys = Object.keys(data);
	  var i = keys.length;
	  while (i--) {
	    var key = keys[i];
	    var _value3 = data[key];
	    if (typeof _value3 === 'function') {
	      bindKey(vm, el, name, key, _value3);
	    } else {
	      el[SETTERS[name]](key, _value3);
	    }
	  }
	}
	
	/**
	 * bind data changes to a certain key to a name series in an element
	 */
	function bindKey(vm, el, name, key, calc) {
	  var methodName = SETTERS[name];
	  // watch the calc, and returns a value by calc.call()
	  var value = watch(vm, calc, function (value) {
	    function handler() {
	      el[methodName](key, value);
	    }
	    var differ = vm && vm._app && vm._app.differ;
	    if (differ) {
	      differ.append('element', el.depth, el.ref, handler);
	    } else {
	      handler();
	    }
	  });
	
	  el[methodName](key, value);
	}
	
	/**
	 * watch a calc function and callback if the calc value changes
	 */
	function watch(vm, calc, callback) {
	  var watcher = new _watcher2.default(vm, calc, function (value, oldValue) {
	    /* istanbul ignore if */
	    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' && value === oldValue) {
	      return;
	    }
	    callback(value);
	  });
	
	  return watcher.value;
	}

/***/ },
/* 98 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	  nativeComponentMap: {
	    text: true,
	    image: true,
	    container: true,
	    slider: {
	      type: 'slider',
	      append: 'tree'
	    },
	    cell: {
	      type: 'cell',
	      append: 'tree'
	    }
	  }
	};

/***/ },
/* 99 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.createBody = createBody;
	exports.createElement = createElement;
	exports.createBlock = createBlock;
	exports.attachTarget = attachTarget;
	exports.moveTarget = moveTarget;
	exports.removeTarget = removeTarget;
	/**
	 * @fileOverview Document & Element Helpers.
	 *
	 * required:
	 * Document#: createElement, createComment, getRef
	 * Element#: appendChild, insertBefore, removeChild, nextSibling
	 */
	
	/**
	 * Create a body by type
	 * Using this._app.doc
	 *
	 * @param  {string} type
	 */
	function createBody(vm, type) {
	  var doc = vm._app.doc;
	  return doc.createBody(type);
	}
	
	/**
	 * Create an element by type
	 * Using this._app.doc
	 *
	 * @param  {string} type
	 */
	function createElement(vm, type) {
	  var doc = vm._app.doc;
	  return doc.createElement(type);
	}
	
	/**
	 * Create and return a frag block for an element.
	 * The frag block has a starter, ender and the element itself.
	 *
	 * @param  {object} element
	 */
	function createBlock(vm, element) {
	  var start = createBlockStart(vm);
	  var end = createBlockEnd(vm);
	  var blockId = lastestBlockId++;
	  if (element.element) {
	    var updateMark = element.updateMark;
	    if (updateMark) {
	      if (updateMark.element) {
	        updateMark = updateMark.end;
	      }
	      element.element.insertAfter(end, updateMark);
	      element.element.insertAfter(start, updateMark);
	      element.updateMark = end;
	    } else {
	      element.element.insertBefore(start, element.end);
	      element.element.insertBefore(end, element.end);
	    }
	    element = element.element;
	  } else {
	    element.appendChild(start);
	    element.appendChild(end);
	  }
	  return { start: start, end: end, element: element, blockId: blockId };
	}
	
	var lastestBlockId = 1;
	
	/**
	 * Create and return a block starter.
	 * Using this._app.doc
	 */
	function createBlockStart(vm) {
	  var doc = vm._app.doc;
	  var anchor = doc.createComment('start');
	  return anchor;
	}
	
	/**
	 * Create and return a block ender.
	 * Using this._app.doc
	 */
	function createBlockEnd(vm) {
	  var doc = vm._app.doc;
	  var anchor = doc.createComment('end');
	  return anchor;
	}
	
	/**
	 * Attach target to a certain dest using appendChild by default.
	 * If the dest is a frag block then insert before the ender.
	 * If the target is a frag block then attach the starter and ender in order.
	 *
	 * @param  {object} target
	 * @param  {object} dest
	 */
	function attachTarget(vm, target, dest) {
	  if (dest.element) {
	    var before = dest.end;
	    var after = dest.updateMark;
	    // push new target for watch list update later
	    if (dest.children) {
	      dest.children.push(target);
	    }
	    // for check repeat case
	    if (after) {
	      var signal = moveTarget(vm, target, after);
	      dest.updateMark = target.element ? target.end : target;
	      return signal;
	    } else if (target.element) {
	      dest.element.insertBefore(target.start, before);
	      dest.element.insertBefore(target.end, before);
	    } else {
	      return dest.element.insertBefore(target, before);
	    }
	  } else {
	    if (target.element) {
	      dest.appendChild(target.start);
	      dest.appendChild(target.end);
	    } else {
	      return dest.appendChild(target);
	    }
	  }
	}
	
	/**
	 * Move target before a certain element. The target maybe block or element.
	 *
	 * @param  {object} target
	 * @param  {object} before
	 */
	function moveTarget(vm, target, after) {
	  if (target.element) {
	    return moveBlock(target, after);
	  }
	  return moveElement(target, after);
	}
	
	/**
	 * Move element before a certain element.
	 *
	 * @param  {object} element
	 * @param  {object} before
	 */
	function moveElement(element, after) {
	  var parent = after.parentNode;
	  if (parent) {
	    return parent.insertAfter(element, after);
	  }
	}
	
	/**
	 * Move all elements of the block before a certain element.
	 *
	 * @param  {object} fragBlock
	 * @param  {object} before
	 */
	function moveBlock(fragBlock, after) {
	  var parent = after.parentNode;
	
	  if (parent) {
	    var _ret = function () {
	      var el = fragBlock.start;
	      var signal = void 0;
	      var group = [el];
	
	      while (el && el !== fragBlock.end) {
	        el = el.nextSibling;
	        group.push(el);
	      }
	
	      var temp = after;
	      group.every(function (el) {
	        signal = parent.insertAfter(el, temp);
	        temp = el;
	        return signal !== -1;
	      });
	
	      return {
	        v: signal
	      };
	    }();
	
	    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	  }
	}
	
	/**
	 * Remove target from DOM tree.
	 * If the target is a frag block then call _removeBlock
	 *
	 * @param  {object} target
	 */
	function removeTarget(vm, target) {
	  var preserveBlock = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	
	  if (target.element) {
	    removeBlock(target, preserveBlock);
	  } else {
	    removeElement(target);
	  }
	}
	
	/**
	 * Remove a certain element.
	 * Using this._app.doc
	 *
	 * @param  {object} target
	 */
	function removeElement(target) {
	  var parent = target.parentNode;
	
	  if (parent) {
	    parent.removeChild(target);
	  }
	}
	
	/**
	 * Remove a frag block.
	 * The second param decides whether the block self should be removed too.
	 *
	 * @param  {object}  fragBlock
	 * @param  {Boolean} preserveBlock=false
	 */
	function removeBlock(fragBlock) {
	  var preserveBlock = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	  var result = [];
	  var el = fragBlock.start.nextSibling;
	
	  while (el && el !== fragBlock.end) {
	    result.push(el);
	    el = el.nextSibling;
	  }
	
	  if (!preserveBlock) {
	    removeElement(fragBlock.start);
	  }
	  result.forEach(function (el) {
	    removeElement(el);
	  });
	  if (!preserveBlock) {
	    removeElement(fragBlock.end);
	  }
	}

/***/ },
/* 100 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.$emit = $emit;
	exports.$dispatch = $dispatch;
	exports.$broadcast = $broadcast;
	exports.$on = $on;
	exports.$off = $off;
	exports.initEvents = initEvents;
	exports.mixinEvents = mixinEvents;
	function Evt(type, detail) {
	  if (detail instanceof Evt) {
	    return detail;
	  }
	
	  this.timestamp = Date.now();
	  this.detail = detail;
	  this.type = type;
	
	  var shouldStop = false;
	  this.stop = function () {
	    shouldStop = true;
	  };
	  this.hasStopped = function () {
	    return shouldStop;
	  };
	}
	
	function $emit(type, detail) {
	  var _this = this;
	
	  var events = this._vmEvents;
	  var handlerList = events[type];
	  if (handlerList) {
	    (function () {
	      var evt = new Evt(type, detail);
	      handlerList.forEach(function (handler) {
	        handler.call(_this, evt);
	      });
	    })();
	  }
	}
	
	function $dispatch(type, detail) {
	  var evt = new Evt(type, detail);
	  this.$emit(type, evt);
	
	  if (!evt.hasStopped() && this._parent && this._parent.$dispatch) {
	    this._parent.$dispatch(type, evt);
	  }
	}
	
	function $broadcast(type, detail) {
	  var evt = new Evt(type, detail);
	  this.$emit(type, evt);
	
	  if (!evt.hasStopped() && this._childrenVms) {
	    this._childrenVms.forEach(function (subVm) {
	      subVm.$broadcast(type, evt);
	    });
	  }
	}
	
	function $on(type, handler) {
	  if (!type || typeof handler !== 'function') {
	    return;
	  }
	  var events = this._vmEvents;
	  var handlerList = events[type] || [];
	  handlerList.push(handler);
	  events[type] = handlerList;
	
	  // fixed old version lifecycle design
	  if (type === 'hook:ready' && this._ready) {
	    this.$emit('hook:ready');
	  }
	}
	
	function $off(type, handler) {
	  if (!type) {
	    return;
	  }
	  var events = this._vmEvents;
	  if (!handler) {
	    delete events[type];
	    return;
	  }
	  var handlerList = events[type];
	  if (!handlerList) {
	    return;
	  }
	  handlerList.$remove(handler);
	}
	
	var LIFE_CYCLE_TYPES = ['init', 'created', 'ready'];
	
	function initEvents(vm, externalEvents) {
	  var options = vm._options || {};
	  var events = options.events || {};
	  for (var type1 in events) {
	    vm.$on(type1, events[type1]);
	  }
	  for (var type2 in externalEvents) {
	    vm.$on(type2, externalEvents[type2]);
	  }
	  LIFE_CYCLE_TYPES.forEach(function (type) {
	    vm.$on('hook:' + type, options[type]);
	  });
	}
	
	function mixinEvents(vm) {
	  vm.$emit = $emit;
	  vm.$dispatch = $dispatch;
	  vm.$broadcast = $broadcast;
	  vm.$on = $on;
	  vm.$off = $off;
	}

/***/ },
/* 101 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.clearModules = clearModules;
	exports.getModule = getModule;
	exports.requireModule = requireModule;
	exports.registerModules = registerModules;
	exports.registerMethods = registerMethods;
	exports.requireComponent = requireComponent;
	exports.registerComponent = registerComponent;
	var nativeModules = {};
	
	function assignModules(modules, ifReplace) {
	  var _loop = function _loop(moduleName) {
	    // init `modules[moduleName][]`
	    var methods = nativeModules[moduleName];
	    if (!methods) {
	      methods = {};
	      nativeModules[moduleName] = methods;
	    }
	
	    // push each non-existed new method
	    modules[moduleName].forEach(function (method) {
	      if (typeof method === 'string') {
	        method = {
	          name: method
	        };
	      }
	
	      if (!methods[method.name] || ifReplace) {
	        methods[method.name] = method;
	      }
	    });
	  };
	
	  for (var moduleName in modules) {
	    _loop(moduleName);
	  }
	}
	
	function assignApis(Ctor, apis) {
	  var p = Ctor.prototype;
	
	  for (var apiName in apis) {
	    if (!p.hasOwnProperty(apiName)) {
	      p[apiName] = apis[apiName];
	    }
	  }
	}
	
	function clearModules() {
	  nativeModules = {};
	}
	
	function getModule(moduleName) {
	  return nativeModules[moduleName];
	}
	
	/**
	 * @context a instance of AppInstance
	 */
	function requireModule(moduleName) {
	  var _this = this;
	
	  var methods = nativeModules[moduleName];
	  var target = {};
	
	  var _loop2 = function _loop2(methodName) {
	    target[methodName] = function () {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      return _this.callTasks({
	        module: moduleName,
	        method: methodName,
	        args: args
	      });
	    };
	  };
	
	  for (var methodName in methods) {
	    _loop2(methodName);
	  }
	
	  return target;
	}
	
	/**
	 * @context Vm
	 */
	function registerModules(modules, ifReplace) {
	  assignModules(modules, ifReplace);
	}
	
	/**
	 * @context Vm
	 */
	function registerMethods(apis) {
	  assignApis(this, apis);
	}
	
	/**
	 * @context a instance of AppInstance
	 */
	function requireComponent(name) {
	  var customComponentMap = this.customComponentMap;
	
	  return customComponentMap[name];
	}
	
	/**
	 * @context a instance of AppInstance
	 */
	function registerComponent(name, def) {
	  var customComponentMap = this.customComponentMap;
	
	
	  if (customComponentMap[name]) {
	    console.error('[JS Framework] define a component(' + name + ') that already exists');
	    return;
	  }
	
	  customComponentMap[name] = def;
	}

/***/ },
/* 102 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.removeWeexPrefix = removeWeexPrefix;
	exports.removeJSSurfix = removeJSSurfix;
	var WEEX_COMPONENT_REG = /^@weex-component\//;
	var WEEX_MODULE_REG = /^@weex-module\//;
	var NORMAL_MODULE_REG = /^\.{1,2}\//;
	var JS_SURFIX_REG = /\.js$/;
	
	var isWeexComponent = exports.isWeexComponent = function isWeexComponent(name) {
	  return !!name.match(WEEX_COMPONENT_REG);
	};
	var isWeexModule = exports.isWeexModule = function isWeexModule(name) {
	  return !!name.match(WEEX_MODULE_REG);
	};
	var isNormalModule = exports.isNormalModule = function isNormalModule(name) {
	  return !!name.match(NORMAL_MODULE_REG);
	};
	var isNpmModule = exports.isNpmModule = function isNpmModule(name) {
	  return !isWeexComponent(name) && !isWeexModule(name) && !isNormalModule(name);
	};
	
	function removeWeexPrefix(str) {
	  return str.replace(WEEX_COMPONENT_REG, '').replace(WEEX_MODULE_REG, '');
	}
	
	function removeJSSurfix(str) {
	  return str.replace(JS_SURFIX_REG, '');
	}

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.define = undefined;
	exports.clearCommonModules = clearCommonModules;
	exports.register = register;
	
	var _util = __webpack_require__(84);
	
	var _vm = __webpack_require__(89);
	
	var _vm2 = _interopRequireDefault(_vm);
	
	var _misc = __webpack_require__(102);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	var commonModules = {};
	
	function clearCommonModules() {
	  commonModules = {};
	}
	
	// define(name, factory) for primary usage
	// or
	// define(name, deps, factory) for compatibility
	// Notice: DO NOT use function define() {},
	// it will cause error after builded by webpack
	var define = exports.define = function define(name, deps, factory) {
	  var _this = this;
	
	  console.debug('[JS Framework] define a component ' + name);
	
	  if ((0, _util.typof)(deps) === 'function') {
	    factory = deps;
	    deps = [];
	  }
	
	  var _require = function _require(name) {
	    var cleanName = void 0;
	
	    if ((0, _misc.isWeexComponent)(name)) {
	      cleanName = (0, _misc.removeWeexPrefix)(name);
	      return _this.requireComponent(cleanName);
	    }
	    if ((0, _misc.isWeexModule)(name)) {
	      cleanName = (0, _misc.removeWeexPrefix)(name);
	      return _this.requireModule(cleanName);
	    }
	    if ((0, _misc.isNormalModule)(name)) {
	      cleanName = (0, _misc.removeJSSurfix)(name);
	      return commonModules[name];
	    }
	    if ((0, _misc.isNpmModule)(name)) {
	      cleanName = (0, _misc.removeJSSurfix)(name);
	      return commonModules[name];
	    }
	  };
	  var _module = { exports: {} };
	
	  var cleanName = void 0;
	  if ((0, _misc.isWeexComponent)(name)) {
	    cleanName = (0, _misc.removeWeexPrefix)(name);
	
	    factory(_require, _module.exports, _module);
	
	    this.registerComponent(cleanName, _module.exports);
	  } else if ((0, _misc.isWeexModule)(name)) {
	    cleanName = (0, _misc.removeWeexPrefix)(name);
	
	    factory(_require, _module.exports, _module);
	
	    _vm2.default.registerModules(_defineProperty({}, cleanName, _module.exports));
	  } else if ((0, _misc.isNormalModule)(name)) {
	    cleanName = (0, _misc.removeJSSurfix)(name);
	
	    factory(_require, _module.exports, _module);
	
	    commonModules[cleanName] = _module.exports;
	  } else if ((0, _misc.isNpmModule)(name)) {
	    cleanName = (0, _misc.removeJSSurfix)(name);
	
	    factory(_require, _module.exports, _module);
	
	    var exports = _module.exports;
	    if (exports.template || exports.style || exports.methods) {
	      // downgrade to old define method (define('componentName', factory))
	      // the exports contain one key of template, style or methods
	      // but it has risk!!!
	      this.registerComponent(cleanName, exports);
	    } else {
	      commonModules[cleanName] = _module.exports;
	    }
	  }
	};
	
	/**
	 * @deprecated
	 */
	function register(type, options) {
	  console.warn('[JS Framework] Register is deprecated, please install lastest transformer.');
	  this.registerComponent(type, options);
	}

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.updateActions = updateActions;
	exports.destroy = destroy;
	exports.getRootElement = getRootElement;
	exports.fireEvent = fireEvent;
	exports.callback = callback;
	exports.refreshData = refreshData;
	
	var _util = __webpack_require__(84);
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
	                                                                                                                                                                                                     * @fileOverview
	                                                                                                                                                                                                     * instance controls from native
	                                                                                                                                                                                                     *
	                                                                                                                                                                                                     * - fire event
	                                                                                                                                                                                                     * - callback
	                                                                                                                                                                                                     * - destroy
	                                                                                                                                                                                                     *
	                                                                                                                                                                                                     * corresponded with the API of instance manager (framework.js)
	                                                                                                                                                                                                     */
	
	
	function updateActions() {
	  this.differ.flush();
	  var tasks = [];
	  if (this.doc && this.doc.listener && this.doc.listener.updates.length) {
	    tasks.push.apply(tasks, _toConsumableArray(this.doc.listener.updates));
	    this.doc.listener.updates = [];
	  }
	  if (tasks.length) {
	    return this.callTasks(tasks);
	  }
	}
	
	function destroy() {
	  console.debug('[JS Framework] Destory an instance(' + this.id + ')');
	
	  this.id = '';
	  this.options = null;
	  this.blocks = null;
	  this.vm = null;
	  this.doc = null;
	  this.customComponentMap = null;
	  this.callbacks = null;
	}
	
	function getRootElement() {
	  var doc = this.doc || {};
	  var body = doc.body || {};
	  return body.toJSON ? body.toJSON() : {};
	}
	
	function fireEvent(ref, type, e, domChanges) {
	  var _this = this;
	
	  console.debug('[JS Framework] Fire a "' + type + '" event on an element(' + ref + ') in instance(' + this.id + ')');
	  if (Array.isArray(ref)) {
	    ref.some(function (ref) {
	      return _this.fireEvent(ref, type, e) !== false;
	    });
	    return;
	  }
	
	  var el = this.doc.getRef(ref);
	
	  if (el) {
	    this.doc.close();
	    var result = this.doc.fireEvent(el, type, e, domChanges);
	    this.updateActions();
	    this.doc.listener.updateFinish();
	    this.doc.open();
	    return result;
	  }
	
	  return new Error('invalid element reference "' + ref + '"');
	}
	
	function callback(callbackId, data, ifKeepAlive) {
	  console.debug('[JS Framework] Invoke a callback(' + callbackId + ') with', data, 'in instance(' + this.id + ')');
	
	  var callback = this.callbacks[callbackId];
	
	  if (typeof callback === 'function') {
	    this.doc.close();
	    callback(data); // data is already a object, @see: lib/runtime/index.js
	
	    if (typeof ifKeepAlive === 'undefined' || ifKeepAlive === false) {
	      this.callbacks[callbackId] = undefined;
	    }
	
	    this.updateActions();
	    this.doc.listener.updateFinish();
	    this.doc.open();
	    return;
	  }
	
	  return new Error('invalid callback id "' + callbackId + '"');
	}
	
	function refreshData(data) {
	  console.debug('[JS Framework] Refresh with', data, 'in instance[' + this.id + ']');
	
	  var vm = this.vm;
	
	  if (vm && data) {
	    this.doc.close();
	    if (typeof vm.refreshData === 'function') {
	      vm.refreshData(data);
	    } else {
	      (0, _util.extend)(vm, data);
	    }
	    this.updateActions();
	    this.doc.listener.refreshFinish();
	    this.doc.open();
	    return;
	  }
	
	  return new Error('invalid data "' + data + '"');
	}

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = AppInstance;
	
	var _util = __webpack_require__(84);
	
	var _differ = __webpack_require__(106);
	
	var _differ2 = _interopRequireDefault(_differ);
	
	var _config = __webpack_require__(98);
	
	var _config2 = _interopRequireDefault(_config);
	
	var _register = __webpack_require__(101);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function AppInstance(instanceId, options) {
	  this.id = instanceId;
	  this.options = options || {};
	  this.vm = null;
	  this.customComponentMap = {};
	  this.callbacks = {};
	  this.doc = new _config2.default.Document(instanceId, this.options.bundleUrl, null, _config2.default.Listener);
	  this.differ = new _differ2.default(instanceId);
	  this.uid = 0;
	}
	
	function normalize(app, v) {
	  var type = (0, _util.typof)(v);
	
	  switch (type) {
	    case 'undefined':
	    case 'null':
	      return '';
	    case 'regexp':
	      return v.toString();
	    case 'date':
	      return v.toISOString();
	    case 'number':
	    case 'string':
	    case 'boolean':
	    case 'array':
	    case 'object':
	      if (v instanceof _config2.default.Element) {
	        return v.ref;
	      }
	      return v;
	    case 'function':
	      app.callbacks[++app.uid] = v;
	      return app.uid.toString();
	    default:
	      return JSON.stringify(v);
	  }
	}
	
	AppInstance.prototype.callTasks = function (tasks) {
	  var _this = this;
	
	  if ((0, _util.typof)(tasks) !== 'array') {
	    tasks = [tasks];
	  }
	
	  tasks.forEach(function (task) {
	    task.args = task.args.map(function (arg) {
	      return normalize(_this, arg);
	    });
	  });
	
	  return _config2.default.sendTasks(this.id, tasks, '-1');
	};
	
	(0, _util.extend)(AppInstance.prototype, {
	  registerComponent: _register.registerComponent,
	  requireComponent: _register.requireComponent,
	  requireModule: _register.requireModule
	});

/***/ },
/* 106 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Differ = function () {
	  function Differ(id) {
	    _classCallCheck(this, Differ);
	
	    this.id = id;
	    this.map = [];
	    this.hooks = [];
	  }
	
	  _createClass(Differ, [{
	    key: 'isEmpty',
	    value: function isEmpty() {
	      return this.map.length === 0;
	    }
	  }, {
	    key: 'append',
	    value: function append(type, depth, ref, handler) {
	      var _this = this;
	
	      if (!this.hasTimer) {
	        this.hasTimer = true;
	        setTimeout(function () {
	          _this.hasTimer = false;
	          _this.flush(true);
	        }, 0);
	      }
	      var map = this.map;
	      if (!map[depth]) {
	        map[depth] = {};
	      }
	      var group = map[depth];
	      if (!group[type]) {
	        group[type] = {};
	      }
	      if (type === 'element') {
	        if (!group[type][ref]) {
	          group[type][ref] = [];
	        }
	        group[type][ref].push(handler);
	      } else {
	        group[type][ref] = handler;
	      }
	    }
	  }, {
	    key: 'flush',
	    value: function flush(isTimeout) {
	      var map = this.map.slice();
	      this.map.length = 0;
	      map.forEach(function (group) {
	        callTypeMap(group, 'repeat');
	        callTypeMap(group, 'shown');
	        callTypeList(group, 'element');
	      });
	
	      var hooks = this.hooks.slice();
	      this.hooks.length = 0;
	      hooks.forEach(function (fn) {
	        fn();
	      });
	
	      if (!this.isEmpty()) {
	        this.flush();
	      }
	    }
	  }, {
	    key: 'then',
	    value: function then(fn) {
	      this.hooks.push(fn);
	    }
	  }]);
	
	  return Differ;
	}();
	
	exports.default = Differ;
	
	
	function callTypeMap(group, type) {
	  var map = group[type];
	  for (var ref in map) {
	    map[ref]();
	  }
	}
	
	function callTypeList(group, type) {
	  var map = group[type];
	  for (var ref in map) {
	    var list = map[ref];
	    list.forEach(function (handler) {
	      handler();
	    });
	  }
	}

/***/ },
/* 107 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var instanceMap = exports.instanceMap = {};

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.init = init;
	exports.refreshInstance = refreshInstance;
	exports.destroyInstance = destroyInstance;
	
	var _config = __webpack_require__(98);
	
	var _config2 = _interopRequireDefault(_config);
	
	var _map = __webpack_require__(107);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function init(cfg) {
	  _config2.default.Document = cfg.Document;
	  _config2.default.Element = cfg.Element;
	  _config2.default.Comment = cfg.Comment;
	  _config2.default.sendTasks = cfg.sendTasks;
	  _config2.default.Listener = cfg.Listener;
	}
	
	/**
	 * refresh a Weex instance
	 *
	 * @param  {string} instanceId
	 * @param  {object} data
	 */
	function refreshInstance(instanceId, data) {
	  var instance = _map.instanceMap[instanceId];
	  var result = void 0;
	  if (instance) {
	    result = instance.refreshData(data);
	  } else {
	    result = new Error('invalid instance id "' + instanceId + '"');
	  }
	  return result;
	}
	
	/**
	 * destroy a Weex instance
	 * @param  {string} instanceId
	 */
	function destroyInstance(instanceId) {
	  var instance = _map.instanceMap[instanceId];
	  if (!instance) {
	    return new Error('invalid instance id "' + instanceId + '"');
	  }
	
	  instance.destroy();
	  delete _map.instanceMap[instanceId];
	  return _map.instanceMap;
	}

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.registerComponents = registerComponents;
	exports.registerModules = registerModules;
	exports.registerMethods = registerMethods;
	
	var _vm = __webpack_require__(89);
	
	var _vm2 = _interopRequireDefault(_vm);
	
	var _config = __webpack_require__(98);
	
	var _config2 = _interopRequireDefault(_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var nativeComponentMap = _config2.default.nativeComponentMap;
	
	/**
	 * register the name of each native component
	 * @param  {array} components array of name
	 */
	
	function registerComponents(components) {
	  if (Array.isArray(components)) {
	    components.forEach(function register(name) {
	      /* istanbul ignore if */
	      if (!name) {
	        return;
	      }
	      if (typeof name === 'string') {
	        nativeComponentMap[name] = true;
	      } else if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object' && typeof name.type === 'string') {
	        nativeComponentMap[name.type] = name;
	      }
	    });
	  }
	}
	
	/**
	 * register the name and methods of each module
	 * @param  {object} modules a object of modules
	 */
	function registerModules(modules) {
	  if ((typeof modules === 'undefined' ? 'undefined' : _typeof(modules)) === 'object') {
	    _vm2.default.registerModules(modules);
	  }
	}
	
	/**
	 * register the name and methods of each api
	 * @param  {object} apis a object of apis
	 */
	function registerMethods(apis) {
	  if ((typeof apis === 'undefined' ? 'undefined' : _typeof(apis)) === 'object') {
	    _vm2.default.registerMethods(apis);
	  }
	}
	global.registerMethods = registerMethods;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.receiveTasks = receiveTasks;
	
	var _map = __webpack_require__(107);
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	var jsHandlers = {
	  fireEvent: function fireEvent(instanceId, ref, type, data, domChanges) {
	    var instance = _map.instanceMap[instanceId];
	    return instance.fireEvent(ref, type, data, domChanges);
	  },
	
	  callback: function callback(instanceId, funcId, data, ifLast) {
	    var instance = _map.instanceMap[instanceId];
	    return instance.callback(funcId, data, ifLast);
	  }
	};
	
	/**
	 * accept calls from native (event or callback)
	 *
	 * @param  {string} instanceId
	 * @param  {array} tasks list with `method` and `args`
	 */
	function receiveTasks(instanceId, tasks) {
	  var instance = _map.instanceMap[instanceId];
	  if (instance && Array.isArray(tasks)) {
	    var _ret = function () {
	      var results = [];
	      tasks.forEach(function (task) {
	        var handler = jsHandlers[task.method];
	        var args = [].concat(_toConsumableArray(task.args));
	        if (typeof handler === 'function') {
	          args.unshift(instanceId);
	          results.push(handler.apply(undefined, _toConsumableArray(args)));
	        }
	      });
	      return {
	        v: results
	      };
	    }();
	
	    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	  }
	  return new Error('invalid instance id "' + instanceId + '" or tasks');
	}

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getRoot = getRoot;
	
	var _map = __webpack_require__(107);
	
	/**
	 * get a whole element tree of an instance
	 * for debugging
	 * @param  {string} instanceId
	 * @return {object} a virtual dom tree
	 */
	function getRoot(instanceId) {
	  var instance = _map.instanceMap[instanceId];
	  var result = void 0;
	  if (instance) {
	    result = instance.getRootElement();
	  } else {
	    result = new Error('invalid instance id "' + instanceId + '"');
	  }
	  return result;
	}

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.instanceMap = undefined;
	exports.Document = Document;
	exports.Node = Node;
	exports.Element = Element;
	exports.Comment = Comment;
	
	var _utils = __webpack_require__(8);
	
	var DEFAULT_TAG_NAME = 'div'; /**
	                               * @fileOverview
	                               * A simple virtual dom implementation
	                               */
	// import { extend } from '../shared'
	
	
	var instanceMap = exports.instanceMap = {};
	var nextNodeRef = 1;
	
	function Document(id, url, handler, Listener) {
	  id = id ? id.toString() : '';
	  this.id = id;
	  this.URL = url;
	
	  instanceMap[id] = this;
	  this.nodeMap = {};
	  Listener && (this.listener = new Listener(id, handler || genCallTasks(id)));
	  this.createDocumentElement();
	}
	
	function genCallTasks(id) {
	  return function (tasks) {
	    if (!Array.isArray(tasks)) {
	      tasks = [tasks];
	    }
	    return callNative(id, tasks, '-1');
	  };
	}
	
	Document.prototype.destroy = function () {
	  delete this.listener;
	  delete this.nodeMap;
	  delete instanceMap[this.id];
	};
	
	Document.prototype.open = function () {
	  this.listener.batched = false;
	};
	
	Document.prototype.close = function () {
	  this.listener.batched = true;
	};
	
	Document.prototype.createDocumentElement = function () {
	  var _this = this;
	
	  if (!this.documentElement) {
	    var el = new Element('document');
	    el.docId = this.id;
	    el.ownerDocument = this;
	    el.role = 'documentElement';
	    el.depth = 0;
	    el.ref = '_documentElement';
	    this.nodeMap._documentElement = el;
	    this.documentElement = el;
	    el.appendChild = function (node) {
	      appendBody(_this, node);
	    };
	    el.insertBefore = function (node, before) {
	      appendBody(_this, node, before);
	    };
	  }
	
	  return this.documentElement;
	};
	
	function appendBody(doc, node, before) {
	  var documentElement = doc.documentElement;
	
	
	  if (documentElement.pureChildren.length > 0 || node.parentNode) {
	    return;
	  }
	  var children = documentElement.children;
	  var beforeIndex = children.indexOf(before);
	  if (beforeIndex < 0) {
	    children.push(node);
	  } else {
	    children.splice(beforeIndex, 0, node);
	  }
	
	  if (node.nodeType === 1) {
	    if (node.role === 'body') {
	      node.docId = doc.id;
	      node.ownerDocument = doc;
	      node.parentNode = documentElement;
	    } else {
	      node.children.forEach(function (child) {
	        child.parentNode = node;
	      });
	      setBody(doc, node);
	      node.docId = doc.id;
	      node.ownerDocument = doc;
	      linkParent(node, documentElement);
	      delete doc.nodeMap[node.nodeId];
	    }
	    documentElement.pureChildren.push(node);
	    doc.listener.createBody(node);
	  } else {
	    node.parentNode = documentElement;
	    doc.nodeMap[node.ref] = node;
	  }
	}
	
	function setBody(doc, el) {
	  el.role = 'body';
	  el.depth = 1;
	  delete doc.nodeMap[el.nodeId];
	  el.ref = '_root';
	  doc.nodeMap._root = el;
	  doc.body = el;
	}
	
	Document.prototype.createBody = function (type, props) {
	  if (!this.body) {
	    var el = new Element(type, props);
	    setBody(this, el);
	  }
	
	  return this.body;
	};
	
	Document.prototype.createElement = function (tagName, props) {
	  return new Element(tagName, props);
	};
	
	Document.prototype.createComment = function (text) {
	  return new Comment(text);
	};
	
	Document.prototype.fireEvent = function (el, type, e, domChanges) {
	  if (!el) {
	    return;
	  }
	  e = e || {};
	  e.type = type;
	  e.target = el;
	  e.timestamp = Date.now();
	  if (domChanges) {
	    updateElement(el, domChanges);
	  }
	  return el.fireEvent(type, e);
	};
	
	Document.prototype.getRef = function (ref) {
	  return this.nodeMap[ref];
	};
	
	function updateElement(el, changes) {
	  var attrs = changes.attrs || {};
	  for (var name in attrs) {
	    el.setAttr(name, attrs[name], true);
	  }
	  var style = changes.style || {};
	  for (var _name in style) {
	    el.setStyle(_name, style[_name], true);
	  }
	}
	
	function Node() {
	  this.nodeId = (nextNodeRef++).toString();
	  this.ref = this.nodeId;
	  this.children = [];
	  this.pureChildren = [];
	  this.parentNode = null;
	  this.nextSibling = null;
	  this.previousSibling = null;
	}
	
	Node.prototype.destroy = function () {
	  var doc = instanceMap[this.docId];
	  if (doc) {
	    delete this.docId;
	    delete doc.nodeMap[this.nodeId];
	  }
	  this.children.forEach(function (child) {
	    child.destroy();
	  });
	};
	
	function Element() {
	  var type = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_TAG_NAME : arguments[0];
	  var props = arguments[1];
	
	  props = props || {};
	  this.nodeType = 1;
	  this.nodeId = (nextNodeRef++).toString();
	  this.ref = this.nodeId;
	  this.type = type;
	  this.attr = props.attr || {};
	  this.classStyle = props.classStyle || {};
	  this.style = props.style || {};
	  this.event = {};
	  this.children = [];
	  this.pureChildren = [];
	}
	
	Element.prototype = new Node();
	
	Element.prototype.appendChild = function (node) {
	  if (node.parentNode && node.parentNode !== this) {
	    return;
	  }
	  if (!node.parentNode) {
	    linkParent(node, this);
	    insertIndex(node, this.children, this.children.length, true);
	    if (this.docId) {
	      registerNode(this.docId, node);
	    }
	    if (node.nodeType === 1) {
	      insertIndex(node, this.pureChildren, this.pureChildren.length);
	      if (this.docId) {
	        var listener = instanceMap[this.docId].listener;
	        return listener.addElement(node, this.ref, -1);
	      }
	    }
	  } else {
	    moveIndex(node, this.children, this.children.length, true);
	    if (node.nodeType === 1) {
	      var index = moveIndex(node, this.pureChildren, this.pureChildren.length);
	      if (this.docId && index >= 0) {
	        var _listener = instanceMap[this.docId].listener;
	        return _listener.moveElement(node.ref, this.ref, index);
	      }
	    }
	  }
	};
	
	Element.prototype.insertBefore = function (node, before) {
	  if (node.parentNode && node.parentNode !== this) {
	    return;
	  }
	  if (node === before || node.nextSibling === before) {
	    return;
	  }
	  if (!node.parentNode) {
	    linkParent(node, this);
	    insertIndex(node, this.children, this.children.indexOf(before), true);
	    if (this.docId) {
	      registerNode(this.docId, node);
	    }
	    if (node.nodeType === 1) {
	      var pureBefore = nextElement(before);
	      var index = insertIndex(node, this.pureChildren, pureBefore ? this.pureChildren.indexOf(pureBefore) : this.pureChildren.length);
	      if (this.docId) {
	        var listener = instanceMap[this.docId].listener;
	        return listener.addElement(node, this.ref, index);
	      }
	    }
	  } else {
	    moveIndex(node, this.children, this.children.indexOf(before), true);
	    if (node.nodeType === 1) {
	      var _pureBefore = nextElement(before);
	      var _index = moveIndex(node, this.pureChildren, _pureBefore ? this.pureChildren.indexOf(_pureBefore) : this.pureChildren.length);
	      if (this.docId && _index >= 0) {
	        var _listener2 = instanceMap[this.docId].listener;
	        return _listener2.moveElement(node.ref, this.ref, _index);
	      }
	    }
	  }
	};
	
	Element.prototype.insertAfter = function (node, after) {
	  if (node.parentNode && node.parentNode !== this) {
	    return;
	  }
	  if (node === after || node.previousSibling === after) {
	    return;
	  }
	  if (!node.parentNode) {
	    linkParent(node, this);
	    insertIndex(node, this.children, this.children.indexOf(after) + 1, true);
	    if (this.docId) {
	      registerNode(this.docId, node);
	    }
	    if (node.nodeType === 1) {
	      var index = insertIndex(node, this.pureChildren, this.pureChildren.indexOf(previousElement(after)) + 1);
	      if (this.docId) {
	        var listener = instanceMap[this.docId].listener;
	        return listener.addElement(node, this.ref, index);
	      }
	    }
	  } else {
	    moveIndex(node, this.children, this.children.indexOf(after) + 1, true);
	    if (node.nodeType === 1) {
	      var _index2 = moveIndex(node, this.pureChildren, this.pureChildren.indexOf(previousElement(after)) + 1);
	      if (this.docId && _index2 >= 0) {
	        var _listener3 = instanceMap[this.docId].listener;
	        return _listener3.moveElement(node.ref, this.ref, _index2);
	      }
	    }
	  }
	};
	
	Element.prototype.removeChild = function (node, preserved) {
	  if (node.parentNode) {
	    removeIndex(node, this.children, true);
	    if (node.nodeType === 1) {
	      removeIndex(node, this.pureChildren);
	      if (this.docId) {
	        var listener = instanceMap[this.docId].listener;
	        listener.removeElement(node.ref);
	      }
	    }
	  }
	  if (!preserved) {
	    node.destroy();
	  }
	};
	
	Element.prototype.clear = function () {
	  var _this2 = this;
	
	  if (this.docId) {
	    (function () {
	      var listener = instanceMap[_this2.docId].listener;
	      _this2.pureChildren.forEach(function (node) {
	        listener.removeElement(node.ref);
	      });
	    })();
	  }
	  this.children.forEach(function (node) {
	    node.destroy();
	  });
	  this.children.length = 0;
	  this.pureChildren.length = 0;
	};
	
	function nextElement(node) {
	  while (node) {
	    if (node.nodeType === 1) {
	      return node;
	    }
	    node = node.nextSibling;
	  }
	}
	
	function previousElement(node) {
	  while (node) {
	    if (node.nodeType === 1) {
	      return node;
	    }
	    node = node.previousSibling;
	  }
	}
	
	function linkParent(node, parent) {
	  node.parentNode = parent;
	  if (parent.docId) {
	    node.docId = parent.docId;
	    node.ownerDocument = parent.ownerDocument;
	    node.ownerDocument.nodeMap[node.nodeId] = node;
	    node.depth = parent.depth + 1;
	  }
	  node.children.forEach(function (child) {
	    linkParent(child, node);
	  });
	}
	
	function registerNode(docId, node) {
	  var doc = instanceMap[docId];
	  doc.nodeMap[node.nodeId] = node;
	}
	
	function insertIndex(target, list, newIndex, changeSibling) {
	  if (newIndex < 0) {
	    newIndex = 0;
	  }
	  var before = list[newIndex - 1];
	  var after = list[newIndex];
	  list.splice(newIndex, 0, target);
	  if (changeSibling) {
	    before && (before.nextSibling = target);
	    target.previousSibling = before;
	    target.nextSibling = after;
	    after && (after.previousSibling = target);
	  }
	  return newIndex;
	}
	
	function moveIndex(target, list, newIndex, changeSibling) {
	  var index = list.indexOf(target);
	  if (index < 0) {
	    return -1;
	  }
	  if (changeSibling) {
	    var before = list[index - 1];
	    var after = list[index + 1];
	    before && (before.nextSibling = after);
	    after && (after.previousSibling = before);
	  }
	  list.splice(index, 1);
	  var newIndexAfter = newIndex;
	  if (index <= newIndex) {
	    newIndexAfter = newIndex - 1;
	  }
	  var beforeNew = list[newIndexAfter - 1];
	  var afterNew = list[newIndexAfter];
	  list.splice(newIndexAfter, 0, target);
	  if (changeSibling) {
	    beforeNew && (beforeNew.nextSibling = target);
	    target.previousSibling = beforeNew;
	    target.nextSibling = afterNew;
	    afterNew && (afterNew.previousSibling = target);
	  }
	  if (index === newIndexAfter) {
	    return -1;
	  }
	  return newIndex;
	}
	
	function removeIndex(target, list, changeSibling) {
	  var index = list.indexOf(target);
	  if (index < 0) {
	    return;
	  }
	  if (changeSibling) {
	    var before = list[index - 1];
	    var after = list[index + 1];
	    before && (before.nextSibling = after);
	    after && (after.previousSibling = before);
	  }
	  list.splice(index, 1);
	}
	
	Element.prototype.setAttr = function (key, value, silent) {
	  if (this.attr[key] === value) {
	    return;
	  }
	  this.attr[key] = value;
	  if (!silent && this.docId) {
	    var listener = instanceMap[this.docId].listener;
	    listener.setAttr(this.ref, key, value);
	  }
	};
	
	Element.prototype.setStyle = function (key, value, silent) {
	  if (this.style[key] === value) {
	    return;
	  }
	  this.style[key] = value;
	  if (!silent && this.docId) {
	    var listener = instanceMap[this.docId].listener;
	    listener.setStyle(this.ref, key, value);
	  }
	};
	
	Element.prototype.setClassStyle = function (classStyle) {
	  this.classStyle = classStyle;
	  if (this.docId) {
	    var listener = instanceMap[this.docId].listener;
	    listener.setStyles(this.ref, this.toStyle());
	  }
	};
	
	Element.prototype.addEvent = function (type, handler) {
	  if (!this.event[type]) {
	    this.event[type] = handler;
	    if (this.docId) {
	      var listener = instanceMap[this.docId].listener;
	      listener.addEvent(this.ref, type);
	    }
	  }
	};
	
	Element.prototype.removeEvent = function (type) {
	  if (this.event[type]) {
	    delete this.event[type];
	    if (this.docId) {
	      var listener = instanceMap[this.docId].listener;
	      listener.removeEvent(this.ref, type);
	    }
	  }
	};
	
	Element.prototype.fireEvent = function (type, e) {
	  var handler = this.event[type];
	  if (handler) {
	    return handler.call(this, e);
	  }
	};
	
	Element.prototype.toStyle = function () {
	  return (0, _utils.extend)({}, this.classStyle, this.style);
	};
	
	Element.prototype.toJSON = function () {
	  var result = {
	    ref: this.ref.toString(),
	    type: this.type,
	    attr: this.attr,
	    style: this.toStyle()
	  };
	  var event = Object.keys(this.event);
	  if (event.length) {
	    result.event = event;
	  }
	  if (this.pureChildren.length) {
	    result.children = this.pureChildren.map(function (child) {
	      return child.toJSON();
	    });
	  }
	  return result;
	};
	
	Element.prototype.toString = function () {
	  return '<' + this.type + ' attr=' + JSON.stringify(this.attr) + ' style=' + JSON.stringify(this.toStyle()) + '>' + this.pureChildren.map(function (child) {
	    return child.toString();
	  }).join('') + '</' + this.type + '>';
	};
	
	function Comment(value) {
	  this.nodeType = 8;
	  this.nodeId = (nextNodeRef++).toString();
	  this.ref = this.nodeId;
	  this.type = 'comment';
	  this.value = value;
	  this.children = [];
	  this.pureChildren = [];
	}
	
	Comment.prototype = new Node();
	
	Comment.prototype.toString = function () {
	  return '<!-- ' + this.value + ' -->';
	};

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.$ = $;
	exports.$el = $el;
	exports.$vm = $vm;
	exports.$renderThen = $renderThen;
	exports.$scrollTo = $scrollTo;
	exports.$transition = $transition;
	exports.$getConfig = $getConfig;
	exports.$sendHttp = $sendHttp;
	exports.$openURL = $openURL;
	exports.$setTitle = $setTitle;
	exports.$call = $call;
	
	var _util = __webpack_require__(84);
	
	/**
	 * ==========================================================
	 * common
	 * ==========================================================
	 */
	
	/**
	 * @deprecated use $vm instead
	 * find the vm by id
	 * Note: there is only one id in whole component
	 * @param  {string} id
	 * @return {Vm}
	 */
	function $(id) {
	  console.warn('[JS Framework] Vm#$ is deprecated, please use Vm#$vm instead');
	  var info = this._ids[id];
	  if (info) {
	    return info.vm;
	  }
	}
	
	/**
	 * find the element by id
	 * Note: there is only one id in whole component
	 * @param  {string} id
	 * @return {Element}
	 */
	/**
	 * @fileOverview The api for invoking with "$" prefix
	 */
	function $el(id) {
	  var info = this._ids[id];
	  if (info) {
	    return info.el;
	  }
	}
	
	/**
	 * find the vm of the custom component by id
	 * Note: there is only one id in whole component
	 * @param  {string} id
	 * @return {Vm}
	 */
	function $vm(id) {
	  var info = this._ids[id];
	  if (info) {
	    return info.vm;
	  }
	}
	
	/**
	 * Fire when differ rendering finished
	 *
	 * @param  {Function} fn
	 */
	function $renderThen(fn) {
	  var app = this._app;
	  var differ = app.differ;
	  return differ.then(function () {
	    fn();
	  });
	}
	
	/**
	 * scroll an element specified by id into view,
	 * moreover specify a number of offset optionally
	 * @param  {string} id
	 * @param  {number} offset
	 */
	function $scrollTo(id, offset) {
	  console.warn('[JS Framework] Vm#$scrollTo is deprecated, ' + 'please use "require(\'@weex-module/dom\')' + '.scrollTo(el, options)" instead');
	  var el = this.$el(id);
	  if (el) {
	    var dom = this._app.requireModule('dom');
	    dom.scrollToElement(el.ref, { offset: offset });
	  }
	}
	
	/**
	 * perform transition animation on an element specified by id
	 * @param  {string}   id
	 * @param  {object}   options
	 * @param  {object}   options.styles
	 * @param  {object}   options.duration(ms)
	 * @param  {object}   [options.timingFunction]
	 * @param  {object}   [options.delay=0(ms)]
	 * @param  {Function} callback
	 */
	function $transition(id, options, callback) {
	  var _this = this;
	
	  var el = this.$el(id);
	  if (el && options && options.styles) {
	    var animation = this._app.requireModule('animation');
	    animation.transition(el.ref, options, function () {
	      _this._setStyle(el, options.styles);
	      callback && callback.apply(undefined, arguments);
	    });
	  }
	}
	
	/**
	 * get some config
	 * @return {object} some config for app instance
	 * @property {string} bundleUrl
	 * @property {boolean} debug
	 * @property {object} env
	 * @property {string} env.weexVersion(ex. 1.0.0)
	 * @property {string} env.appName(ex. TB/TM)
	 * @property {string} env.appVersion(ex. 5.0.0)
	 * @property {string} env.platform(ex. iOS/Android)
	 * @property {string} env.osVersion(ex. 7.0.0)
	 * @property {string} env.deviceModel **native only**
	 * @property {number} env.[deviceWidth=750]
	 * @property {number} env.deviceHeight
	 */
	function $getConfig(callback) {
	  var config = (0, _util.extend)({
	    env: global.WXEnvironment || {}
	  }, this._app.options);
	  if ((0, _util.typof)(callback) === 'function') {
	    console.warn('[JS Framework] the callback of Vm#$getConfig(callback) is deprecated, ' + 'this api now can directly RETURN config info.');
	    callback(config);
	  }
	  return config;
	}
	
	/**
	 * @deprecated
	 * request network via http protocol
	 * @param  {object}   params
	 * @param  {Function} callback
	 */
	function $sendHttp(params, callback) {
	  console.warn('[JS Framework] Vm#$sendHttp is deprecated, ' + 'please use "require(\'@weex-module/stream\')' + '.sendHttp(params, callback)" instead');
	  var stream = this._app.requireModule('stream');
	  stream.sendHttp(params, callback);
	}
	
	/**
	 * @deprecated
	 * open a url
	 * @param  {string} url
	 */
	function $openURL(url) {
	  console.warn('[JS Framework] Vm#$openURL is deprecated, ' + 'please use "require(\'@weex-module/event\')' + '.openURL(url)" instead');
	  var event = this._app.requireModule('event');
	  event.openURL(url);
	}
	
	/**
	 * @deprecated
	 * set a title for page
	 * @param  {string} title
	 */
	function $setTitle(title) {
	  console.warn('[JS Framework] Vm#$setTitle is deprecated, ' + 'please use "require(\'@weex-module/pageInfo\')' + '.setTitle(title)" instead');
	  var pageInfo = this._app.requireModule('pageInfo');
	  pageInfo.setTitle(title);
	}
	
	/**
	 * @deprecated use "require('@weex-module/moduleName') instead"
	 * invoke a native method by specifing the name of module and method
	 * @param  {string} moduleName
	 * @param  {string} methodName
	 * @param  {...*} the rest arguments
	 */
	function $call(moduleName, methodName) {
	  console.warn('[JS Framework] Vm#$call is deprecated, ' + 'please use "require(\'@weex-module/moduleName\')" instead');
	  var module = this._app.requireModule(moduleName);
	  if (module && module[methodName]) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }
	
	    module[methodName].apply(module, args);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global Event */
	
	'use strict';
	
	// const FrameUpdater = require('./frameUpdater')
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ComponentManager;
	
	var _appearWatcher = __webpack_require__(115);
	
	var _utils = __webpack_require__(83);
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	// const lazyload = require('./lazyload')
	// const animation = require('./animation')
	
	var RENDERING_INDENT = 800;
	
	var _instanceMap = {};
	var typeMap = {};
	var scrollableTypes = ['scroller', 'hscroller', 'vscroller', 'list', 'hlist', 'vlist'];
	
	function ComponentManager(id) {
	  this.id = id;
	  this.batched = false;
	  this.updates = [];
	  this.componentMap = {};
	  _instanceMap[this.id] = this;
	}
	
	ComponentManager.getInstance = function (instanceId) {
	  return _instanceMap[instanceId];
	};
	
	ComponentManager.registerComponent = function (type, definition) {
	  typeMap[type] = definition;
	};
	
	ComponentManager.getScrollableTypes = function () {
	  return scrollableTypes;
	};
	
	ComponentManager.prototype = {
	  getWeexInstance: function getWeexInstance() {
	    if (!this._weexInstance) {
	      this._weexInstance = global.weex ? global.weex.getInstance(this.id) : null;
	    }
	    return this._weexInstance;
	  },
	
	
	  // Fire a event 'renderbegin'/'renderend' on body element.
	  rendering: function rendering() {
	    function _renderingEnd() {
	      // get weex instance root
	      window.dispatchEvent(new Event('renderend'));
	      this._renderingTimer = null;
	    }
	    if (this._renderingTimer) {
	      clearTimeout(this._renderingTimer);
	      this._renderingTimer = setTimeout(_renderingEnd.bind(this), RENDERING_INDENT);
	    } else {
	      window.dispatchEvent(new Event('renderbegin'));
	      this._renderingTimer = setTimeout(_renderingEnd.bind(this), RENDERING_INDENT);
	    }
	  },
	  getComponent: function getComponent(ref) {
	    return this.componentMap[ref];
	  },
	  removeComponent: function removeComponent(ref) {
	    var self = this;
	    if (!ref || !this.componentMap[ref]) {
	      return;
	    }
	    // remove from this.componentMap cursively
	    (function _removeCursively(_ref) {
	      var child = self.componentMap[_ref];
	      var listeners = child._listeners;
	      var children = child.data.children;
	      if (children && children.length) {
	        for (var i = 0, l = children.length; i < l; i++) {
	          _removeCursively(children[i].ref);
	        }
	      }
	      // remove events from _ref component
	      if (listeners) {
	        for (var type in listeners) {
	          child.node.removeEventListener(type, listeners[type]);
	        }
	      }
	      delete child._listeners;
	      delete child.node._listeners;
	      // remove _ref component
	      delete self.componentMap[_ref];
	    })(ref);
	  },
	  createElement: function createElement(data, nodeType) {
	    var ComponentType = typeMap[data.type];
	    if (!ComponentType) {
	      ComponentType = typeMap['div'];
	    }
	
	    data.instanceId = this.id;
	    data.scale = this.getWeexInstance().scale;
	    var component = new ComponentType(data, nodeType);
	    var ref = data.ref;
	    this.componentMap[ref] = component;
	    component.node.setAttribute('data-ref', ref);
	
	    return component;
	  },
	
	
	  /**
	   * createBody: generate root component
	   * @param  {object} element
	   */
	  createBody: function createBody(element) {
	    console.log('[h5-render] createBody', element);
	    if (this.componentMap['_root']) {
	      return;
	    }
	    element = element.toJSON();
	
	    var nodeType = element.type;
	    element.type = 'root';
	    element.rootId = this.getWeexInstance().rootId;
	    element.ref = '_root';
	
	    var root = this.createElement(element, nodeType);
	    var body = document.querySelector('#' + this.getWeexInstance().rootId) || document.body;
	    body.appendChild(root.node);
	    root._appended = true;
	
	    this.handleAppend(root);
	  },
	  appendChild: function appendChild(parentRef, data) {
	    var parent = this.componentMap[parentRef];
	
	    if (this.componentMap[data.ref] || !parent) {
	      return;
	    }
	
	    if (parentRef === '_root' && !parent) {
	      parent = this.createElement({
	        type: 'root',
	        rootId: this.getWeexInstance().rootId,
	        ref: '_root'
	      });
	      parent._appended = true;
	    }
	
	    var child = parent.appendChild(data);
	
	    // In some parent component the implementation of method
	    // appendChild didn't return the component at all, therefor
	    // child maybe a undefined object.
	    if (child) {
	      child.parentRef = parentRef;
	    }
	
	    if (child && parent._appended) {
	      this.handleAppend(child);
	    }
	  },
	
	
	  // appendChildren (ref, elements) {
	  //   for (let i = 0; i < elements.length; i++) {
	  //     this.appendChild(ref, elements[i])
	  //   }
	  // },
	
	  removeElement: function removeElement(ref) {
	    var _this = this;
	
	    if ((0, _utils.isArray)(ref)) {
	      return ref.map(function (r) {
	        return _this.removeElement(r);
	      });
	    }
	    var component = this.componentMap[ref];
	    // fire event for rendering dom on body elment.
	    this.rendering();
	
	    if (component && component.parentRef) {
	      var parent = this.componentMap[component.parentRef];
	      component.onRemove && component.onRemove();
	      parent.removeChild(component);
	    } else if (!component) {
	      console.error('[h5-render] component of ref \'' + ref + '\' does not exist.');
	    } else {
	      console.error('[h5-render] parent component \'' + component.parentRef + '\' does not exist.');
	    }
	  },
	  moveElement: function moveElement(ref, parentRef, index) {
	    var component = this.componentMap[ref];
	    var newParent = this.componentMap[parentRef];
	    var oldParentRef = component.parentRef;
	    var children = void 0,
	        before = void 0,
	        i = void 0,
	        l = void 0;
	    if (!component) {
	      return console.error('[h5-render] component of ref \'' + ref + '\' does not exist.');
	    }
	    if (!newParent) {
	      return console.error('[h5-render] parent component \'' + parentRef + '\' does not exist.');
	    }
	
	    if (index < -1) {
	      index = -1;
	      return console.error('[h5-render] index cannot be less than -1.');
	    }
	
	    // fire event for rendering.
	    this.rendering();
	
	    children = newParent.data.children;
	    if (children && children.length && index !== -1 && index < children.length) {
	      before = this.componentMap[newParent.data.children[index].ref];
	    }
	
	    // remove from oldParent.data.children
	    if (oldParentRef && this.componentMap[oldParentRef]) {
	      children = this.componentMap[oldParentRef].data.children;
	      if (children && children.length) {
	        for (i = 0, l = children.length; i < l; i++) {
	          if (children[i].ref === ref) {
	            break;
	          }
	        }
	        if (l > i) {
	          children.splice(i, 1);
	        }
	      }
	    }
	
	    newParent.insertBefore(component, before);
	
	    component.onMove && component.onMove(parentRef, index);
	  },
	  insertBefore: function insertBefore(ref, data) {
	    var child = void 0,
	        parent = void 0;
	    var before = this.componentMap[ref];
	    child = this.componentMap[data.ref];
	    before && (parent = this.componentMap[before.parentRef]);
	    if (child || !parent || !before) {
	      return;
	    }
	
	    child = this.createElement(data);
	    if (child) {
	      child.parentRef = before.parentRef;
	      parent.insertBefore(child, before);
	    } else {
	      return;
	    }
	
	    if (this.componentMap[before.parentRef]._appended) {
	      this.handleAppend(child);
	    }
	  },
	
	
	  /**
	   * addElement
	   * If index is larget than any child's index, the
	   * element will be appended behind.
	   * @param {string} parentRef
	   * @param {obj} element (data of the component)
	   * @param {number} index
	   */
	  addElement: function addElement(element, parentRef, index) {
	    // fire event for rendering dom on body elment.
	    element = element.toJSON();
	    this.rendering();
	
	    var parent = this.componentMap[parentRef];
	    if (!parent) {
	      return;
	    }
	    var children = parent.data.children;
	    // -1 means append as the last.
	    if (index < -1) {
	      index = -1;
	      return console.error('[h5-render] index cannot be less than -1.');
	    }
	    if (children && children.length && children.length > index && index !== -1) {
	      this.insertBefore(children[index].ref, element);
	    } else {
	      this.appendChild(parentRef, element);
	    }
	  },
	  addEvent: function addEvent(ref, type) {
	    var component = this.componentMap[ref];
	    if (!component) {
	      return console.error('[h5-render] component of ref \'' + ref + '\' does not exist.');
	    }
	    component.bindEvents([type]);
	  },
	  removeEvent: function removeEvent(ref, type) {
	    var component = this.componentMap[ref];
	    if (!component) {
	      return console.error('[h5-render] component of ref \'' + ref + '\' does not exist.');
	    }
	    component.unbindEvents([type]);
	  },
	  setAttr: function setAttr(ref, key, value) {
	    var component = this.componentMap[ref];
	    if (!component) {
	      return console.error('[h5-render] component of ref \'' + ref + '\' does not exist.');
	    }
	    component.updateAttrs(_defineProperty({}, key, value));
	    // if (component.data.type === 'image' && key === 'src') {
	    //  component.fire
	    //  lazyload.startIfNeeded(component)
	    // }
	  },
	  setStyle: function setStyle(ref, key, value) {
	    var component = this.componentMap[ref];
	    if (!component) {
	      return console.error('[h5-render] component of ref \'' + ref + '\' does not exist.');
	    }
	    component.updateStyle(_defineProperty({}, key, value));
	  },
	  setStyles: function setStyles(ref, style) {
	    var component = this.componentMap[ref];
	    if (!component) {
	      return console.error('[h5-render] component of ref \'' + ref + '\' does not exist.');
	    }
	    component.updateStyle(style);
	  },
	  handleAppend: function handleAppend(component) {
	    component._appended = true;
	    component.onAppend && component.onAppend();
	
	    // invoke onAppend on children recursively
	    var children = component.data.children;
	    if (children) {
	      for (var i = 0; i < children.length; i++) {
	        var child = this.componentMap[children[i].ref];
	        if (child) {
	          this.handleAppend(child);
	        }
	      }
	    }
	
	    // watch appear/disappear of the component if needed
	    (0, _appearWatcher.watchIfNeeded)(component);
	
	    // do lazyload if needed
	    component.fireLazyload();
	    // lazyload.startIfNeeded(component);
	  },
	  createFinish: function createFinish(callback) {
	    // TODO
	  },
	  updateFinish: function updateFinish(callback) {
	    // TODO
	  },
	  refreshFinish: function refreshFinish(callback) {
	    // TODO
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.watchIfNeeded = watchIfNeeded;
	
	var _utils = __webpack_require__(83);
	
	var componentsInScroller = [];
	var componentsOutOfScroller = [];
	var listened = false;
	var direction = 'up';
	var scrollY = 0;
	
	function watchIfNeeded(component) {
	  if (needWatch(component)) {
	    if (component.isInScrollable()) {
	      componentsInScroller.push(component);
	    } else {
	      componentsOutOfScroller.push(component);
	    }
	    if (!listened) {
	      listened = true;
	      // const handler = throttle(onScroll, 25)
	      var handler = throttle(onScroll, 100);
	      window.addEventListener('scroll', handler, false);
	    }
	  }
	}
	
	function needWatch(component) {
	  var events = component.data.event;
	  if (events && (events.indexOf('appear') !== -1 || events.indexOf('disappear') !== -1)) {
	    return true;
	  }
	  return false;
	}
	
	function onScroll(e) {
	  // If the scroll event is dispatched from a scrollable component
	  // implemented through scrollerjs, then the appear/disappear events
	  // should be treated specially by handleScrollerScroll.
	  if (e.originalType === 'scrolling') {
	    handleScrollerScroll(e);
	  } else {
	    handleWindowScroll();
	  }
	}
	
	function handleScrollerScroll(e) {
	  var cmps = componentsInScroller;
	  var len = cmps.length;
	  direction = e.direction;
	  for (var i = 0; i < len; i++) {
	    var component = cmps[i];
	    var appear = isComponentInScrollerAppear(component);
	    if (appear && !component._appear) {
	      component._appear = true;
	      fireEvent(component, 'appear');
	    } else if (!appear && component._appear) {
	      component._appear = false;
	      fireEvent(component, 'disappear');
	    }
	  }
	}
	
	function handleWindowScroll() {
	  var y = window.scrollY;
	  direction = y >= scrollY ? 'up' : 'down';
	  scrollY = y;
	
	  var len = componentsOutOfScroller.length;
	  if (len === 0) {
	    return;
	  }
	  for (var i = 0; i < len; i++) {
	    var component = componentsOutOfScroller[i];
	    var appear = isComponentInWindow(component);
	    if (appear && !component._appear) {
	      component._appear = true;
	      fireEvent(component, 'appear');
	    } else if (!appear && component._appear) {
	      component._appear = false;
	      fireEvent(component, 'disappear');
	    }
	  }
	}
	
	function isComponentInScrollerAppear(component) {
	  var parentScroller = component._parentScroller;
	  var cmpRect = component.node.getBoundingClientRect();
	  if (!isComponentInWindow(component)) {
	    return false;
	  }
	  while (parentScroller) {
	    var parentRect = parentScroller.node.getBoundingClientRect();
	    if (!(cmpRect.right > parentRect.left && cmpRect.left < parentRect.right && cmpRect.bottom > parentRect.top && cmpRect.top < parentRect.bottom)) {
	      return false;
	    }
	    parentScroller = parentScroller._parentScroller;
	  }
	  return true;
	}
	
	function isComponentInWindow(component) {
	  var rect = component.node.getBoundingClientRect();
	  return rect.right > 0 && rect.left < window.innerWidth && rect.bottom > 0 && rect.top < window.innerHeight;
	}
	
	function fireEvent(component, type) {
	  var evt = document.createEvent('HTMLEvents');
	  var data = { direction: direction };
	  evt.initEvent(type, false, false);
	  evt.data = data;
	  (0, _utils.extend)(evt, data);
	  component.node.dispatchEvent(evt);
	}
	
	function throttle(func, wait) {
	  var context = void 0,
	      args = void 0,
	      result = void 0;
	  var timeout = null;
	  var previous = 0;
	  var later = function later() {
	    previous = Date.now();
	    timeout = null;
	    result = func.apply(context, args);
	  };
	  return function () {
	    var now = Date.now();
	    var remaining = wait - (now - previous);
	    context = this;
	    args = arguments;
	    if (remaining <= 0) {
	      clearTimeout(timeout);
	      timeout = null;
	      previous = now;
	      result = func.apply(context, args);
	    } else if (!timeout) {
	      timeout = setTimeout(later, remaining);
	    }
	    return result;
	  };
	}

/***/ },
/* 116 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var config = {
	  weexVersion: '0.5.0',
	  debug: false,
	  validRoots: ['div', 'list', 'vlist', 'scroller']
	};
	
	exports.default = config;

/***/ },
/* 117 */
/***/ function(module, exports) {

	/* global XMLHttpRequest */
	
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.load = load;
	exports.registerLoader = registerLoader;
	function loadByXHR(config, callback) {
	  if (!config.source) {
	    callback(new Error('xhr loader: missing config.source.'));
	  }
	  var xhr = new XMLHttpRequest();
	  xhr.open('GET', config.source);
	  xhr.onload = function () {
	    callback(null, this.responseText);
	  };
	  xhr.onerror = function (error) {
	    callback(error);
	  };
	  xhr.send();
	}
	
	function loadByJsonp(config, callback) {
	  if (!config.source) {
	    callback(new Error('jsonp loader: missing config.source.'));
	  }
	  var callbackName = config.jsonpCallback || 'weexJsonpCallback';
	  window[callbackName] = function (code) {
	    if (code) {
	      callback(null, code);
	    } else {
	      callback(new Error('load by jsonp error'));
	    }
	  };
	  var script = document.createElement('script');
	  script.src = decodeURIComponent(config.source);
	  script.type = 'text/javascript';
	  document.body.appendChild(script);
	}
	
	function loadBySourceCode(config, callback) {
	  // src is the jsbundle.
	  // no need to fetch from anywhere.
	  if (config.source) {
	    callback(null, config.source);
	  } else {
	    callback(new Error('source code laoder: missing config.source.'));
	  }
	}
	
	var callbackMap = {
	  xhr: loadByXHR,
	  jsonp: loadByJsonp,
	  source: loadBySourceCode
	};
	
	function load(options, callback) {
	  var loadFn = callbackMap[options.loader];
	  loadFn(options, callback);
	}
	
	function registerLoader(name, loaderFunc) {
	  if (typeof loaderFunc === 'function') {
	    callbackMap[name] = loaderFunc;
	  }
	}

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Sender = exports.receiver = exports.protocol = undefined;
	
	var _protocol = __webpack_require__(119);
	
	var _protocol2 = _interopRequireDefault(_protocol);
	
	var _receiver = __webpack_require__(120);
	
	var _receiver2 = _interopRequireDefault(_receiver);
	
	var _sender = __webpack_require__(121);
	
	var _sender2 = _interopRequireDefault(_sender);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.protocol = _protocol2.default;
	exports.receiver = _receiver2.default;
	exports.Sender = _sender2.default;

/***/ },
/* 119 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = {
	
	  // weex instances
	  _instances: {},
	
	  // api meta info
	  _meta: {},
	
	  // Weex.registerApiModule used this to register and access apiModules.
	  apiModule: {},
	
	  // get the api method meta info array for the module.
	  getApiModuleMeta: function getApiModuleMeta(moduleName) {
	    var metaObj = {};
	    metaObj[moduleName] = this._meta[moduleName];
	    return metaObj;
	  },
	
	  // Set meta info for a api module.
	  // If there is a same named api, just replace it.
	  // opts:
	  // - metaObj: meta object like
	  // {
	  //    dom: [{
	  //      name: 'addElement',
	  //      args: ['string', 'object']
	  //    }]
	  // }
	  setApiModuleMeta: function setApiModuleMeta(metaObj) {
	    var moduleName = void 0;
	    for (var k in metaObj) {
	      if (metaObj.hasOwnProperty(k)) {
	        moduleName = k;
	      }
	    }
	    var metaArray = this._meta[moduleName];
	    if (!metaArray) {
	      this._meta[moduleName] = metaObj[moduleName];
	    } else {
	      (function () {
	        var nameObj = {};
	        metaObj[moduleName].forEach(function (api) {
	          nameObj[api.name] = api;
	        });
	        metaArray.forEach(function (api, i) {
	          if (nameObj[api.name]) {
	            metaArray[i] = nameObj[api.name];
	            delete nameObj[api.name];
	          }
	        });
	        for (var _k in metaObj) {
	          if (metaObj.hasOwnProperty(_k)) {
	            metaArray.push(metaObj[_k]);
	          }
	        }
	      })();
	    }
	    this._meta[moduleName] = metaObj[moduleName];
	  },
	
	  // Set meta info for a single api.
	  // opts:
	  //  - moduleName: api module name.
	  //  - meta: a meta object like:
	  //  {
	  //    name: 'addElement',
	  //    args: ['string', 'object']
	  //  }
	  setApiMeta: function setApiMeta(moduleName, meta) {
	    var metaArray = this._meta[moduleName];
	    if (!metaArray) {
	      this._meta[moduleName] = [meta];
	    } else {
	      var metaIdx = -1;
	      metaArray.forEach(function (api, i) {
	        var name = void 0; // todo
	        if (meta.name === name) {
	          metaIdx = i;
	        }
	      });
	      if (metaIdx !== -1) {
	        metaArray[metaIdx] = meta;
	      } else {
	        metaArray.push(meta);
	      }
	    }
	  }
	};
	
	// _registerModules([{
	//   modal: [{
	//     name: 'toast',
	//     args: ['object', 'function']
	//   }, {
	//     name: 'alert',
	//     args: ['object', 'function']
	//   }, {
	//     name: 'confirm',
	//     args: ['object', 'function']
	//   }, {
	//     name: 'prompt',
	//     args: ['object', 'function']
	//   }]
	// }, {
	//   animation: [{
	//     name: 'transition',
	//     args: ['string', 'object', 'function']
	//   }]
	// }])

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _config = __webpack_require__(116);
	
	var _config2 = _interopRequireDefault(_config);
	
	var _protocol = __webpack_require__(119);
	
	var _protocol2 = _interopRequireDefault(_protocol);
	
	var _utils = __webpack_require__(83);
	
	var _sender = __webpack_require__(121);
	
	var _sender2 = _interopRequireDefault(_sender);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var callQueue = [];
	// Need a task counter?
	// When frameUpdater is not activated, tasks will not be push
	// into callQueue and there will be no trace for situation of
	// execution of tasks.
	
	// give 10ms for call handling, and rest 6ms for others
	var MAX_TIME_FOR_EACH_FRAME = 10;
	
	// callNative: jsFramework will call this method to talk to
	// this renderer.
	// params:
	//  - instanceId: string.
	//  - tasks: array of object.
	//  - callbackId: number.
	function callNative(instanceId, tasks, callbackId) {
	  var calls = [];
	  if (typeof tasks === 'string') {
	    try {
	      calls = JSON.parse(tasks);
	    } catch (e) {
	      console.error('invalid tasks:', tasks);
	    }
	  } else if ((0, _utils.isArray)(tasks)) {
	    calls = tasks;
	  }
	  var len = calls.length;
	  calls[len - 1].callbackId = !callbackId && callbackId !== 0 ? -1 : callbackId;
	  // To solve the problem of callapp, the two-way time loop rule must
	  // be replaced by calling directly except the situation of page loading.
	  // 2015-11-03
	  for (var i = 0; i < len; i++) {
	    if (_utils.frameUpdater.isActive()) {
	      callQueue.push({
	        instanceId: instanceId,
	        call: calls[i]
	      });
	    } else {
	      processCall(instanceId, calls[i]);
	    }
	  }
	}
	
	function processCallQueue() {
	  var len = callQueue.length;
	  if (len === 0) {
	    return;
	  }
	  var start = Date.now();
	  var elapsed = 0;
	
	  while (--len >= 0 && elapsed < MAX_TIME_FOR_EACH_FRAME) {
	    var callObj = callQueue.shift();
	    processCall(callObj.instanceId, callObj.call);
	    elapsed = Date.now() - start;
	  }
	}
	
	function processCall(instanceId, call) {
	  var moduleName = call.module;
	  var methodName = call.method;
	  var module = void 0,
	      method = void 0;
	  var args = call.args || call.arguments || [];
	
	  if (!(module = _protocol2.default.apiModule[moduleName])) {
	    return;
	  }
	  if (!(method = module[methodName])) {
	    return;
	  }
	
	  method.apply(global.weex.getInstance(instanceId), args);
	
	  var callbackId = call.callbackId;
	  if ((callbackId || callbackId === 0 || callbackId === '0') && callbackId !== '-1' && callbackId !== -1) {
	    performNextTick(instanceId, callbackId);
	  }
	}
	
	function performNextTick(instanceId, callbackId) {
	  _sender2.default.getSender(instanceId).performCallback(callbackId);
	}
	
	function nativeLog() {
	  if (_config2.default.debug) {
	    if (arguments[0].match(/^perf/)) {
	      console.info.apply(console, arguments);
	      return;
	    }
	    console.debug.apply(console, arguments);
	  }
	}
	
	function exportsBridgeMethodsToGlobal() {
	  global.callNative = callNative;
	  global.nativeLog = nativeLog;
	}
	
	exports.default = {
	  init: function init() {
	    // process callQueue every 16 milliseconds.
	    _utils.frameUpdater.addUpdateObserver(processCallQueue);
	    _utils.frameUpdater.start();
	
	    // exports methods to global(window).
	    exportsBridgeMethodsToGlobal();
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Sender;
	
	var _utils = __webpack_require__(83);
	
	var _senderMap = {};
	
	function Sender(instance) {
	  if (!(this instanceof Sender)) {
	    return new Sender(instance);
	  }
	  this.instanceId = instance.instanceId;
	  this.weexInstance = instance;
	  _senderMap[this.instanceId] = this;
	}
	
	function _send(instanceId, msg) {
	  callJS(instanceId, [msg]);
	}
	
	Sender.getSender = function (instanceId) {
	  return _senderMap[instanceId];
	};
	
	Sender.prototype = {
	
	  // perform a callback to jsframework.
	  performCallback: function performCallback(callbackId, data, keepAlive) {
	    var args = [callbackId];
	    data && args.push(data);
	    keepAlive && args.push(keepAlive);
	    _send(this.instanceId, {
	      method: 'callback',
	      args: args
	    });
	  },
	
	  fireEvent: function fireEvent(ref, type, func, event) {
	    func.extra && (0, _utils.extend)(event, func.extra());
	    _send(this.instanceId, {
	      method: 'fireEvent',
	      args: [ref, type, event, func.updator && func.updator()]
	    });
	  }
	
	};

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Component;
	
	var _utils = __webpack_require__(83);
	
	var _dom = __webpack_require__(123);
	
	var _operate = __webpack_require__(124);
	
	var operate = _interopRequireWildcard(_operate);
	
	var _position = __webpack_require__(126);
	
	var position = _interopRequireWildcard(_position);
	
	var _flexbox = __webpack_require__(128);
	
	var _flexbox2 = _interopRequireDefault(_flexbox);
	
	var _lazyload = __webpack_require__(129);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function hasIntersection(rect, ctRect) {
	  return rect.left < ctRect.right && rect.right > ctRect.left && rect.top < ctRect.bottom && rect.bottom > ctRect.top;
	}
	
	function Component(data, nodeType) {
	  this.data = data;
	  this.node = this.create(nodeType);
	  this.createChildren();
	  this.updateAttrs(this.data.attr || {});
	  // issue: when add element to a list in lifetime hook 'ready', the
	  // styles is set to the classStyle, not style. This is a issue
	  // that jsframework should do something about.
	  var classStyle = this.data.classStyle;
	  classStyle && this.updateStyle(this.data.classStyle);
	  this.updateStyle(this.data.style || {});
	  this.bindEvents(this.data.event || []);
	}
	
	Component.prototype = {
	  getComponentManager: function getComponentManager() {
	    return _dom.ComponentManager.getInstance(this.data.instanceId);
	  },
	  getWeexInstance: function getWeexInstance() {
	    return this.getComponentManager().getWeexInstance();
	  },
	  getParent: function getParent() {
	    return this.getComponentManager().componentMap[this.parentRef];
	  },
	  getParentScroller: function getParentScroller() {
	    if (this.isInScrollable()) {
	      return this._parentScroller;
	    }
	    return null;
	  },
	  getRootScroller: function getRootScroller() {
	    if (this.isInScrollable()) {
	      var scroller = this._parentScroller;
	      var parent = scroller._parentScroller;
	      while (parent) {
	        scroller = parent;
	        parent = scroller._parentScroller;
	      }
	      return scroller;
	    }
	    return null;
	  },
	  getRootContainer: function getRootContainer() {
	    var root = this.getWeexInstance().getRoot() || document.body;
	    return root;
	  },
	  isScrollable: function isScrollable() {
	    var t = this.data.type;
	    return _dom.ComponentManager.getScrollableTypes().indexOf(t) !== -1;
	  },
	  isInScrollable: function isInScrollable() {
	    if (typeof this._isInScrollable === 'boolean') {
	      return this._isInScrollable;
	    }
	    var parent = this.getParent();
	    if (parent && typeof parent._isInScrollable !== 'boolean' && !parent.isScrollable()) {
	      if (parent.data.ref === '_root') {
	        this._isInScrollable = false;
	        return false;
	      }
	      this._isInScrollable = parent.isInScrollable();
	      this._parentScroller = parent._parentScroller;
	      return this._isInScrollable;
	    }
	    if (parent && typeof parent._isInScrollable === 'boolean') {
	      this._isInScrollable = parent._isInScrollable;
	      this._parentScroller = parent._parentScroller;
	      return this._isInScrollable;
	    }
	    if (parent && parent.isScrollable()) {
	      this._isInScrollable = true;
	      this._parentScroller = parent;
	      return true;
	    }
	    if (!parent) {
	      console && console.warn('[h5-render] isInScrollable - parent not exist.');
	      return;
	    }
	  },
	
	
	  // dispatch a specified event on this.node
	  //  - type: event type
	  //  - data: event data
	  //  - config: event config object
	  //     - bubbles
	  //     - cancelable
	  dispatchEvent: function dispatchEvent(type, data, config) {
	    var event = document.createEvent('HTMLEvents');
	    config = config || {};
	    event.initEvent(type, config.bubbles || false, config.cancelable || false);
	    !data && (data = {});
	    event.data = (0, _utils.extend)({}, data);
	    (0, _utils.extend)(event, data);
	    this.node.dispatchEvent(event);
	  },
	
	
	  onAppend: function onAppend() {
	    var rect = this.node.getBoundingClientRect();
	    var parent = this.getParentScroller();
	    var parentNode = parent ? parent.node : this.getRootContainer();
	    var ctRect = parentNode.getBoundingClientRect();
	    if (hasIntersection(rect, ctRect)) {
	      this.dispatchEvent('appear', { direction: '' });
	    }
	  },
	
	  addAppendHandler: function addAppendHandler(cb) {
	    var pre = void 0;
	    if (this.onAppend) {
	      pre = this.onAppend.bind(this);
	    }
	    this.onAppend = function () {
	      pre && pre.call(this);
	      cb && cb.call(this);
	    }.bind(this);
	  },
	
	
	  // change src to img-src for lib.img to fire lazyload later.
	  enableLazyload: function enableLazyload(src) {
	    if (this.node) {
	      (0, _lazyload.makeImageLazy)(this.node, src);
	    } else {
	      console.error('[h5-render] this.node does not exist.');
	    }
	  },
	
	
	  // element can be both weex component and dom element.
	  fireLazyload: function fireLazyload(element) {
	    !element && (element = this);
	    (0, _lazyload.fireLazyload)(element);
	  },
	
	
	  attr: {}, // attr setters
	
	  style: {}, // style setters
	
	  // event funcs
	  //  - 1. 'updator' for updating attrs or styles with out triggering messages.
	  //  - 2. 'extra' for binding extra data.
	  //  - 3. 'setter' set a specified event handler.
	  // funcs should be functions like this: (take 'change' event as a example)
	  // {
	  //   change: {
	  //     updator () {
	  //       return {
	  //         attrs: {
	  //           checked: this.checked
	  //         }
	  //       }
	  //     },
	  //     extra () {
	  //       return {
	  //         value: this.checked
	  //       }
	  //     }
	  //   }
	  // }
	  event: {},
	
	  clearAttr: function clearAttr() {},
	  clearStyle: function clearStyle() {
	    this.node.cssText = '';
	  }
	};
	
	// extend operations.
	(0, _utils.extend)(Component.prototype, operate);
	
	// extend attr and style setters from 'position' and 'flexbox'.
	(0, _utils.extend)(Component.prototype, position);
	(0, _utils.extend)(Component.prototype.style, _flexbox2.default.style);

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ComponentManager = undefined;
	
	var _componentManager = __webpack_require__(114);
	
	var _componentManager2 = _interopRequireDefault(_componentManager);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.ComponentManager = _componentManager2.default; /**
	                                                        * @fileOverview
	                                                        * A simple virtual dom implementation
	                                                        */

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.create = create;
	exports.createChildren = createChildren;
	exports.appendChild = appendChild;
	exports.insertBefore = insertBefore;
	exports.removeChild = removeChild;
	exports.updateAttrs = updateAttrs;
	exports.updateStyle = updateStyle;
	exports.bindEvents = bindEvents;
	exports.unbindEvents = unbindEvents;
	
	var _utils = __webpack_require__(83);
	
	var _valueFilter = __webpack_require__(125);
	
	function create(nodeType) {
	  var node = document.createElement(nodeType || 'div');
	  return node;
	}
	
	function createChildren() {
	  var children = this.data.children;
	  var parentRef = this.data.ref;
	  var componentManager = this.getComponentManager();
	  if (children && children.length) {
	    var fragment = document.createDocumentFragment();
	    var isFlex = false;
	    for (var i = 0; i < children.length; i++) {
	      children[i].instanceId = this.data.instanceId;
	      children[i].scale = this.data.scale;
	      var child = componentManager.createElement(children[i]);
	      fragment.appendChild(child.node);
	      child.parentRef = parentRef;
	      if (!isFlex && child.data.style && child.data.style.hasOwnProperty('flex')) {
	        isFlex = true;
	      }
	    }
	    this.node.appendChild(fragment);
	  }
	}
	
	function appendChild(data) {
	  var children = this.data.children;
	  var componentManager = this.getComponentManager();
	  var child = componentManager.createElement(data);
	  this.node.appendChild(child.node);
	  // update this.data.children
	  if (!children || !children.length) {
	    this.data.children = [data];
	  } else {
	    children.push(data);
	  }
	  return child;
	}
	
	function insertBefore(child, before) {
	  var children = this.data.children;
	  var i = 0;
	  var l = void 0;
	  var isAppend = false;
	
	  // update this.data.children
	  if (!children || !children.length || !before) {
	    isAppend = true;
	  } else {
	    for (l = children.length; i < l; i++) {
	      if (children[i].ref === before.data.ref) {
	        break;
	      }
	    }
	    if (i === l) {
	      isAppend = true;
	    }
	  }
	
	  if (isAppend) {
	    this.node.appendChild(child.node);
	    children.push(child.data);
	  } else {
	    if (before.fixedPlaceholder) {
	      this.node.insertBefore(child.node, before.fixedPlaceholder);
	    } else if (before.stickyPlaceholder) {
	      this.node.insertBefore(child.node, before.stickyPlaceholder);
	    } else {
	      this.node.insertBefore(child.node, before.node);
	    }
	    children.splice(i, 0, child.data);
	  }
	}
	
	function removeChild(child) {
	  var children = this.data.children;
	  // remove from this.data.children
	  var i = 0;
	  var componentManager = this.getComponentManager();
	  if (children && children.length) {
	    var l = void 0;
	    for (l = children.length; i < l; i++) {
	      if (children[i].ref === child.data.ref) {
	        break;
	      }
	    }
	    if (i < l) {
	      children.splice(i, 1);
	    }
	  }
	  // remove from componentMap recursively
	  componentManager.removeComponent(child.data.ref);
	  child.unsetPosition();
	  child.node.parentNode.removeChild(child.node);
	}
	
	function updateAttrs(attrs) {
	  // Note：attr must be injected into the dom element because
	  // it will be accessed from the outside developer by event.target.attr.
	  if (!this.node.attr) {
	    this.node.attr = {};
	  }
	  for (var key in attrs) {
	    var value = attrs[key];
	    var attrSetter = this.attr[key];
	    if (typeof attrSetter === 'function') {
	      attrSetter.call(this, value);
	    } else {
	      if (typeof value === 'boolean') {
	        this.node[key] = value;
	      } else {
	        this.node.setAttribute(key, value);
	      }
	      this.node.attr[key] = value;
	    }
	  }
	}
	
	function updateStyle(style) {
	  for (var key in style) {
	    var value = style[key];
	    var styleSetter = this.style[key];
	    if (typeof styleSetter === 'function') {
	      styleSetter.call(this, value);
	      continue;
	    }
	    var parser = (0, _valueFilter.getFilters)(key, { scale: this.data.scale })[typeof value === 'undefined' ? 'undefined' : _typeof(value)];
	    if (typeof parser === 'function') {
	      value = parser(value);
	    }
	    this.node.style[key] = value;
	  }
	}
	
	function bindEvents(evts) {
	  var self = this;
	  var weexInstance = this.getWeexInstance();
	  evts.map(function (evt) {
	    var func = self.event[evt] || {};
	    var setter = func.setter;
	    if (setter) {
	      self.node.addEventListener(evt, setter);
	      return;
	    }
	    var sender = weexInstance.sender;
	    var listener = function listener(e) {
	      // do stop bubbling.
	      // do not prevent default, otherwise the touchstart
	      // event will no longer trigger a click event
	      if (e._alreadyTriggered) {
	        return;
	      }
	      e._alreadyTriggered = true;
	      var event = (0, _utils.extend)({}, e);
	      event.target = self.data;
	      sender.fireEvent(self.data.ref, evt, {
	        extra: func.extra && func.extra.bind(self),
	        updator: func.updator && func.updator.bind(self)
	      }, event);
	    };
	    self.node.addEventListener(evt, listener, false, false);
	    var listeners = self._listeners;
	    if (!listeners) {
	      listeners = self._listeners = {};
	      self.node._listeners = {};
	    }
	    listeners[evt] = listener;
	    self.node._listeners[evt] = listener;
	  });
	}
	
	function unbindEvents(evts) {
	  var self = this;
	  evts.map(function (evt) {
	    var listener = this._listeners;
	    if (listener) {
	      self.node.removeEventListener(evt, listener);
	      self._listeners[evt] = null;
	      self.node._listeners[evt] = null;
	    }
	  });
	}

/***/ },
/* 125 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.filterStyles = filterStyles;
	exports.getFilters = getFilters;
	var NOT_PX_NUMBER_PROPERTIES = ['flex', 'opacity', 'zIndex', 'fontWeight'];
	
	function filterStyles(styles, config) {
	  for (var key in styles) {
	    var value = styles[key];
	    var parser = this.getFilters(key, config)[typeof value === 'undefined' ? 'undefined' : _typeof(value)];
	    if (typeof parser === 'function') {
	      styles[key] = parser(value);
	    }
	  }
	}
	
	function getFilters(key, config) {
	  if (NOT_PX_NUMBER_PROPERTIES.indexOf(key) !== -1) {
	    return {};
	  }
	  return {
	    number: function number(val) {
	      return val * config.scale + 'px';
	    },
	    string: function string(val) {
	      // string of a pure number or a number suffixed with a 'px' unit
	      if (val.match(/^\-?\d*\.?\d+(?:px)?$/)) {
	        return parseFloat(val) * config.scale + 'px';
	      }
	      if (key.match(/transform/) && val.match(/translate/)) {
	        return val.replace(/\d*\.?\d+px/g, function (match) {
	          return parseInt(parseFloat(match) * config.scale) + 'px';
	        });
	      }
	      return val;
	    }
	  };
	}

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.style = undefined;
	exports.setFixed = setFixed;
	exports.unsetFixed = unsetFixed;
	exports.setSticky = setSticky;
	exports.unsetSticky = unsetSticky;
	exports.unsetPosition = unsetPosition;
	
	var _sticky = __webpack_require__(127);
	
	var _sticky2 = _interopRequireDefault(_sticky);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Set positon to fixed, with a placeholder if it's in a
	// scrollable component.
	function setFixed() {
	  // delay processing in case the node is not appended yet.
	  setTimeout(function () {
	    this.node.style.position = 'fixed';
	    if (!this.isInScrollable()) {
	      return;
	    }
	    var parent = this.node.parentNode;
	    if (parent) {
	      // For the elements who are fixed: this fixedPlaceholder
	      // shoud be inserted, and the fixed element itself should
	      // be moved to the root container.
	      this.fixedPlaceholder = document.createElement('div');
	      this.fixedPlaceholder.classList.add('weex-fixed-placeholder');
	      this.fixedPlaceholder.style.cssText = ['display:none;', 'width:0px;', 'height:0px;'].join('');
	      parent.insertBefore(this.fixedPlaceholder, this.node);
	      this.getRootContainer().appendChild(this.node);
	    }
	  }.bind(this), 0);
	}
	
	// unset a fixed node to the pecified 'position' or 'relative' by default.
	function unsetFixed(position) {
	  // For the elements who are fixed elements before, now
	  // are not fixed: the fixedPlaceholder has to be replaced
	  // by this element.
	  position = position ? position + '' : 'relative';
	  if (this.fixedPlaceholder) {
	    var parent = this.fixedPlaceholder.parentNode;
	    parent.insertBefore(this.node, this.fixedPlaceholder);
	    parent.removeChild(this.fixedPlaceholder);
	    this.fixedPlaceholder = null;
	    this.node.style.position = position;
	  }
	}
	
	function setSticky() {
	  this.node.style.zIndex = 100;
	  setTimeout(function () {
	    this.sticky = new _sticky2.default(this);
	  }.bind(this), 0);
	}
	
	function unsetSticky() {
	  if (this.sticky) {
	    this.sticky.destroy();
	    this.sticky = null;
	  }
	}
	
	// usally used to unset sticky and fixed
	function unsetPosition(position) {
	  this.style.position.call(this, position);
	}
	
	var style = exports.style = {
	  position: function position(value) {
	    // This is a peace of hacking to fix the problem about
	    // mixing fixed and transform. See 'http://stackoverflo
	    // w.com/questions/15194313/webkit-css-transform3d-posi
	    // tion-fixed-issue' for more info.
	    value !== 'fixed' && this.unsetFixed();
	    value !== 'sticky' && this.unsetSticky();
	    if (value === 'fixed') {
	      return this.setFixed();
	    }
	    if (value === 'sticky') {
	      return this.setSticky();
	    }
	    this.node.style.position = value;
	  }
	};

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Sticky;
	
	var _utils = __webpack_require__(83);
	
	var ua = navigator.userAgent;
	var isFirefox = !!ua.match(/Firefox/i);
	var isIEMobile = !!ua.match(/IEMobile/i);
	var cssPrefix = isFirefox ? '-moz-' : isIEMobile ? '-ms-' : '-webkit-';
	var stylePrefix = isFirefox ? 'Moz' : isIEMobile ? 'ms' : 'webkit';
	
	var supportSticky = (0, _utils.detectSticky)();
	
	function createStickyLayer(sticky) {
	  var parent = sticky.parentElement;
	  var sl = parent._stickyLayer;
	  if (sl) {
	    return;
	  }
	  sl = document.createElement('div');
	  sl.classList.add('weex-sticky-layer');
	  sl.style.cssText = ['position:fixed;', 'top:' + parent.getBoundingClientRect().top + 'px;', 'box-sizing:border-box;', 'width:100%;'].join('');
	  parent._stickyLayer = sl;
	  parent.appendChild(sl);
	}
	
	function destroyStickyLayer(sticky) {
	  var parent = sticky.parentElement;
	  var sl = parent._stickyLayer;
	  if (!sl || sl.children.length > 0) {
	    return;
	  }
	  sl && parent.removeChild(sl);
	  parent._stickyLayer = null;
	}
	
	function bindParent(sticky) {
	  if (!sticky instanceof Sticky) {
	    return;
	  }
	  var scroller = sticky.component.getParentScroller();
	  var pt = void 0;
	  if (scroller) {
	    pt = sticky.parent = scroller;
	    sticky.parentElement = pt.node;
	  } else {
	    pt = sticky.parent = sticky.component.getRootContainer();
	    sticky.parentElement = pt;
	  }
	}
	
	function setSticky(sticky) {
	  var comp = sticky.component;
	  comp.stickyPlaceholder = sticky.element.cloneNode(true);
	  comp.stickyPlaceholder.classList.add('weex-sticky-placeholder');
	  sticky.element.classList.add('weex-sticky');
	  sticky.preMarginTop = sticky.element.style.marginTop;
	  sticky.element.style.marginTop = sticky.top + 'px';
	  sticky.element.parentNode.insertBefore(comp.stickyPlaceholder, sticky.element);
	  var pt = sticky.parentElement;
	  !pt.stickys && (pt.stickys = []);
	  pt.stickys.push(sticky);
	  createStickyLayer(sticky);
	  pt._stickyLayer.appendChild(sticky.element);
	}
	
	/**
	 * unsetSticky
	 * @param  {Sticky} sticky : a sticky instance.
	 * @param  {string} position : position replacing with (default: 'relative').
	 */
	function unsetSticky(sticky, position) {
	  var comp = sticky.component;
	  var element = sticky.element;
	  position = position ? position + '' : sticky.prePosition;
	  element.style.position = position;
	  element.style.marginTop = sticky.preMarginTop || '';
	  element.classList.remove('weex-sticky');
	  if (comp.stickyPlaceholder) {
	    var parent = comp.stickyPlaceholder.parentNode;
	    parent.insertBefore(sticky.element, comp.stickyPlaceholder);
	    parent.removeChild(comp.stickyPlaceholder);
	    comp.stickyPlaceholder = null;
	  }
	  var stks = sticky.parentElement.stickys;
	  var idx = stks.indexOf(sticky);
	  stks.splice(idx, 1);
	  destroyStickyLayer(sticky);
	}
	
	/**
	 * @class  Sticky
	 * @param {Component} component: a weex component.
	 * @param {object} options config options.
	 *  - options.component (optional) incase the component param is missing, it can
	 *    be specified in this options.
	 *  - options.withinParent=false（optional，only for Android）the sticky effect is
	 *    limited within the parent element only.
	 */
	function Sticky(component, options) {
	  options = options || {};
	  this.component = component;
	  this.element = component.node;
	  this.prePosition = this.element.style.position;
	  this.withinParent = options.withinParent || false;
	  this.parent = null;
	  this.init();
	}
	
	Sticky.prototype = {
	
	  constructor: Sticky,
	
	  init: function init() {
	    var elementStyle = this.element.style;
	    elementStyle[stylePrefix + 'Transform'] = 'translateZ(0)'; // fix flickering
	    elementStyle['transform'] = 'translateZ(0)';
	    bindParent(this);
	    if (supportSticky) {
	      elementStyle.position = cssPrefix + 'sticky';
	      elementStyle.position = 'sticky';
	    } else {
	      this._simulateSticky();
	      this._bindResize();
	    }
	  },
	  _bindResize: function _bindResize() {
	    var self = this;
	    var isAndroid = /android/gi.test(navigator.appVersion);
	    var resizeEvent = self._resizeEvent = 'onorientationchange' in window ? 'orientationchange' : 'resize';
	    var resizeHandler = self._resizeHandler = function () {
	      setTimeout(function () {
	        self.refresh();
	      }, isAndroid ? 200 : 0);
	    };
	    window.addEventListener(resizeEvent, resizeHandler, false);
	  },
	
	
	  /**
	   * Refresh a instance.
	   * If withParent is true and the parent' height altered, this
	   * method should be called.
	   */
	  refresh: function refresh() {
	    if (supportSticky) {
	      return;
	    }
	    this._detach();
	    this._simulateSticky();
	  },
	  _simulateSticky: function _simulateSticky() {
	    var self = this;
	    var isInScrollable = this.isInScrollable();
	    // the initial y offset.
	    this.offset = (isInScrollable ? this.getParentScroller().offset : window.pageYOffset) || 0;
	    var rectTop = this.element.getBoundingClientRect().top;
	    var wrapperTop = 0;
	    if (isInScrollable) {
	      wrapperTop = this.parentElement.getBoundingClientRect().top;
	    }
	    var withinParent = this.withinParent;
	    var thresholdBase = rectTop - wrapperTop + this.offset;
	    /**
	     * curState:
	     *   1 - normal
	     *   2 - sticky
	     *   3 - exceed parent
	     * @type {Number}
	     */
	    this.curState = 1;
	    var scrollHandler = this._scrollHandler = (0, _utils.throttle)(function (e) {
	      var sl = self.parentElement._stickyLayer;
	      var layerHeight = sl ? sl.getBoundingClientRect().height : 0;
	      var selfHeight = self.element.getBoundingClientRect().height;
	      var selfOffset = self.curState === 2 ? selfHeight : 0;
	      var thresholdTop = thresholdBase - layerHeight + selfOffset;
	      var ypos = self.isInScrollable() ? e.offset : window.pageYOffset;
	      self.offset = ypos;
	      if (ypos < thresholdTop) {
	        if (self.curState !== 1) {
	          unsetSticky(self);
	          self.curState = 1;
	        }
	      } else if (!withinParent && ypos >= thresholdTop || withinParent && ypos >= thresholdTop /* && ypos < thresholdBottom*/) {
	          if (self.curState !== 2) {
	            setSticky(self);
	            self.curState = 2;
	          }
	        }
	    }, 100);
	    window.addEventListener('scroll', scrollHandler, false);
	
	    // take effect once inited after a destroyment.
	    if (this.offset >= thresholdBase) {
	      var dummyEvent = document.createEvent('HTMLEvents');
	      dummyEvent.initEvent('scroll', true, true);
	      window.dispatchEvent(dummyEvent);
	    }
	  },
	  _detach: function _detach(position) {
	    position = position ? position + '' : 'relative';
	    if (!supportSticky) {
	      if (this.curState === 2) {
	        unsetSticky(this);
	      }
	      window.removeEventListener('scroll', this._scrollHandler, false);
	    }
	  },
	  isInScrollable: function isInScrollable() {
	    if (!this._isInScrollable) {
	      try {
	        this._isInScrollable = this.component.isInScrollable();
	      } catch (err) {
	        // The parentRef is not in componentManager's componentMap yet, so
	        // it's invalid to get the parent and test if it's scrollable.
	        // This is most likely to happen in the case that the parent
	        // component's 'append' attribute is set to 'tree'.
	        console.error('isInScrollable is not yet available to call', err);
	      }
	    }
	    return this._isInScrollable;
	  },
	  getParentScroller: function getParentScroller() {
	    return this.component.getParentScroller();
	  },
	  destroy: function destroy(position) {
	    this._detach(position);
	    var elementStyle = this.element.style;
	    elementStyle.removeProperty(cssPrefix + 'transform');
	    elementStyle.removeProperty('transform');
	    if (!supportSticky) {
	      window.removeEventListener(this._resizeEvent, this._resizeHandler, false);
	    }
	  }
	};

/***/ },
/* 128 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var boxAlignMap = {
	  stretch: 'stretch',
	  'flex-start': 'start',
	  'flex-end': 'end',
	  center: 'center'
	};
	
	var boxOrientMap = {
	  row: 'horizontal',
	  column: 'vertical'
	};
	
	var boxPackMap = {
	  'flex-start': 'start',
	  'flex-end': 'end',
	  center: 'center',
	  'space-between': 'justify',
	  'space-around': 'justify' // Just same as `space-between`
	};
	
	exports.default = {
	  style: {
	    flex: function flex(value) {
	      this.node.style.webkitBoxFlex = value;
	      this.node.style.webkitFlex = value;
	      this.node.style.flex = value;
	    },
	    alignItems: function alignItems(value) {
	      this.node.style.webkitBoxAlign = boxAlignMap[value];
	      this.node.style.webkitAlignItems = value;
	      this.node.style.alignItems = value;
	    },
	    alignSelf: function alignSelf(value) {
	      this.node.style.webkitAlignSelf = value;
	      this.node.style.alignSelf = value;
	    },
	    flexDirection: function flexDirection(value) {
	      this.node.style.webkitBoxOrient = boxOrientMap[value];
	      this.node.style.webkitFlexDirection = value;
	      this.node.style.flexDirection = value;
	    },
	    justifyContent: function justifyContent(value) {
	      this.node.style.webkitBoxPack = boxPackMap[value];
	      this.node.style.webkitJustifyContent = value;
	      this.node.style.justifyContent = value;
	    }
	  }
	};

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/* global lib, HTMLElement */
	
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.makeImageLazy = makeImageLazy;
	exports.fireLazyload = fireLazyload;
	__webpack_require__(130);
	
	var lazyloadTimer = void 0;
	
	// fire lazyimg on images.
	function fire() {
	  lib.img.fire();
	}
	
	// we don't know when all images are appended
	// just use setTimeout to do delay lazyload
	//
	// -- actually everytime we add a element or update styles,
	// the component manager will call startIfNeed to fire
	// lazyload once again in the handleAppend function. so there
	// is no way that any image element can miss it. See source
	// code in componentMangager.js.
	
	// component is not a dom element but a weex component.
	function startIfNeeded(component) {
	  if (component.data.type === 'image') {
	    if (!lazyloadTimer) {
	      lazyloadTimer = setTimeout(function () {
	        fire();
	        clearTimeout(lazyloadTimer);
	        lazyloadTimer = null;
	      }, 16);
	    }
	  }
	}
	
	// elementScope is a dom element.
	function loadIfNeeded(elementScope) {
	  var notPreProcessed = elementScope.querySelectorAll('[img-src]');
	  // image elements which have attribute 'i-lazy-src' were elements
	  // that had been preprocessed by lib-img-core, but not loaded yet, and
	  // must be loaded when 'appear' events were fired. It turns out the
	  // 'appear' event was not fired correctly in the css-translate-transition
	  // situation, so 'i-lazy-src' must be checked and lazyload must be
	  // fired manually.
	  var preProcessed = elementScope.querySelectorAll('[i-lazy-src]');
	  if (notPreProcessed.length > 0 || preProcessed.length > 0) {
	    fire();
	  }
	}
	
	function makeImageLazy(image, src) {
	  image.removeAttribute('img-src');
	  image.removeAttribute('i-lazy-src');
	  image.removeAttribute('src');
	  image.setAttribute('img-src', src);
	  fire();
	}
	
	function fireLazyload(component) {
	  if (component instanceof HTMLElement) {
	    loadIfNeeded(component);
	  } else {
	    startIfNeeded(component);
	  }
	}

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/*
	    lib-img-adpter 
	    Author: kongshi.wl@alibaba-inc.com 
	    Date:   Dec,2015
	*/
	;
	
	(function (win, lib) {
	    __webpack_require__(131);
	
	    var adapter = {};
	    var appearInstance;
	    var runtimeFlags = {};
	
	    var config = {
	        'dataSrc': 'img-src', //指定图片地址的attribute名, 兼做lazy-class的作用
	        'lazyHeight': 0, //以此高度提前触发懒加载
	        'lazyWidth': 0 //以此宽度提前触发懒加载
	    };
	
	
	    function extendStrict(main, sub) {
	        var ret = {};
	        for (var k in main) {
	            if (main.hasOwnProperty(k)) {
	                ret[k] = sub.hasOwnProperty(k) ? sub[k] : main[k];
	            }
	        }
	        return ret;
	    }
	
	    function applySrc(item, processedSrc) {
	        if (!processedSrc) {
	            return;
	        }
	        if (item.nodeName.toUpperCase() == 'IMG') {
	            item.setAttribute('src', processedSrc);
	        } else {
	            item.style.backgroundImage = 'url("' + processedSrc + '")';
	        }
	    }
	
	    function init() {
	        appearInstance = lib.appear.init({
	            cls: 'imgtmp', //可选，需要遍历的元素
	            once: true, //可选，是否只触发一次
	            x: config.lazyWidth, //可选，容器右边距离x以内的元素加载，默认为0
	            y: config.lazyHeight, //可选，容器底部距离y以内的元素加载，默认为0
	            onAppear: function (evt) {
	                var item = this;
	                applySrc(item, item.getAttribute('i-lazy-src'));
	                item.removeAttribute('i-lazy-src');
	            }
	        });
	    }
	
	
	    adapter.logConfig = function () {
	        console.log('lib-img Config\n', config);
	    }
	
	
	    adapter.fire = function () {
	
	        if (!appearInstance) {
	            init();
	        }
	
	        var label = 'i_' + Date.now() % 100000;
	        var domList = document.querySelectorAll('[' + config.dataSrc + ']');
	
	        [].forEach.call(domList, function (item) {
	            if (item.dataset.lazy == 'false' && item.dataset.lazy != 'true') {
	                applySrc(item, processSrc(item, item.getAttribute(config.dataSrc)));
	            } else {
	                item.classList.add(label);
	                item.setAttribute('i-lazy-src', item.getAttribute(config.dataSrc));
	            }
	            item.removeAttribute(config.dataSrc);
	        });
	
	        appearInstance.bind('.' + label);
	        appearInstance.fire();
	    }
	
	
	
	    adapter.defaultSrc = 'data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==';
	
	
	
	    lib.img = adapter;
	    
	    module.exports = adapter;
	
	})(window, window['lib'] || (window['lib'] = {}));


/***/ },
/* 131 */
/***/ function(module, exports) {

	;
	(function (win, lib) {
	  var doc = document;
	  var appearEvt;
	  var disappearEvt;
	
	  function createEvent() {
	    appearEvt = doc.createEvent("HTMLEvents");//创建自定义显示事件  
	    disappearEvt = doc.createEvent("HTMLEvents");//创建自定义消失事件  
	    appearEvt.initEvent('_appear', false, true);      
	    disappearEvt.initEvent('_disappear', false, true);      
	  }
	
	  /**
	   * [throttle 节流函数]
	   * @param  {[function]} func [执行函数]
	   * @param  {[int]} wait [等待时长]
	   * @return {[type]}      [description]
	   */
	  function throttle(func, wait) {
	    var latest = Date.now(),
	      previous = 0,//上次执行的时间
	      timeout = null,//setTimout任务
	      context,//上下文
	      args,//参数
	      result;//结果
	    var later = function () {
	      previous = Date.now();
	      timeout = null;//清空计时器
	      func.apply(context, args);
	    }
	    return function () {
	      var now = Date.now();
	      context = this;
	      args = arguments;
	
	      var remaining = wait - (now - previous);
	      if (remaining <= 0 || remaining >= wait) {
	        //如果没有剩余时间，或者存在修改过系统时间导致剩余时间增大的情况，则执行
	        clearTimeout(timeout);
	        timeout = null;
	        result = func.apply(context, args);
	      } else if (timeout == null) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    }
	  }
	
	  /**
	   * [getOffset 获取边距尺寸]
	   * @param  {[type]} el   [description]
	   * @param  {[type]} param [description]
	   * @return {[type]}       [description]
	   */
	  function getOffset(el, param) {
	    var el, l,  r, b, t;
	    if (!el) {
	      return;
	    }
	    if (!param) {
	      param = {x: 0, y: 0};
	    }
	
	    if (el != window) {
	      el = el.getBoundingClientRect();
	      l = el.left;
	      t = el.top;
	      r = el.right;
	      b = el.bottom;
	    } else {
	      l = 0;
	      t = 0;
	      r = l + el.innerWidth;
	      b = t + el.innerHeight;
	    }
	    return {
	      'left': l,
	      'top': t,
	      'right': r + param.x,
	      'bottom': b + param.y
	    };
	  }
	  //元素位置比较
	  function compareOffset(d1, d2) {
	    var left = d2.right > d1.left && d2.left < d1.right;
	    var top = d2.bottom > d1.top && d2.top < d1.bottom;
	    return left && top;
	  }
	  //获取移动方向
	  function getDirection(beforeOffset, nowOffset) {
	    var direction = 'none';
	    var horizental = beforeOffset.left - nowOffset.left;
	    var vertical = beforeOffset.top - nowOffset.top;
	    if (vertical == 0) {
	      if (horizental != 0) {
	        direction = horizental > 0 ? 'left' : 'right';
	      } else {
	        direction = 'none'
	      }
	    }
	    if (horizental == 0) {
	      if (vertical != 0) {
	        direction = vertical > 0 ? 'up' : 'down';
	      } else {
	        direction = 'none';
	      }
	    }
	    return direction;
	  }
	
	  function extend(target, el) {
	    for (var k in el) {
	      if (el.hasOwnProperty(k)) {
	        target[k] = el[k];
	      }
	    }
	    return target;
	  }
	
	  /**
	   * [__bindEvent 绑定事件，包括滚动、touchmove、transform、resize等]
	   * @return {[type]}      [description]
	   */
	  function __bindEvent() {
	    var self = this;
	    var handle = throttle(function () {
	      __fire.apply(self, arguments);
	    }, this.options.wait);
	    if (this.__handle) {
	      //避免重复绑定
	      this.container.removeEventListener('scroll', this.__handle);
	      this.__handle = null;
	    }
	    this.__handle = handle;
	    this.container.addEventListener('scroll', handle, false);
	    this.container.addEventListener('resize', function(ev) {
	      __fire.apply(self, arguments);
	    }, false);
	    this.container.addEventListener('animationEnd', function() {
	      __fire.apply(self, arguments);
	    }, false);
	    // android4.0以下
	    this.container.addEventListener('webkitAnimationEnd', function() {
	      __fire.apply(self, arguments);
	    }, false);
	    this.container.addEventListener('transitionend', function() {
	      __fire.apply(self, arguments);
	    }, false);
	  }
	
	  //获取容器内所有的加载元素
	  function __getElements(selector) {
	    var self = this;
	    //获取容器
	    var container = this.options.container;
	    if (typeof container == 'string') {
	      //如果是字符串，则选择器
	      this.container = doc.querySelector(container);
	    } else {
	      //对象传值
	      this.container = container;
	    }
	    //获取容器内的所有目标元素
	    if (this.container == window) {
	      var appearWatchElements = doc.querySelectorAll(selector);            
	    } else {
	      var appearWatchElements = this.container.querySelectorAll(selector);
	    }
	    var appearWatchElements = [].slice.call(appearWatchElements, null);
	
	    appearWatchElements = appearWatchElements.filter(function(ele) {
	      // 如果已经绑定过，清除appear状态，不再加入到数组里
	      if (ele.dataset['bind'] == '1') {
	        delete ele._hasAppear;
	        delete ele._hasDisAppear;
	        delete ele._appear;      
	        ele.classList.remove(self.options.cls);
	        return false;
	      } else {
	        return true;
	      }
	    });
	
	    return appearWatchElements;
	  }
	
	  function __initBoundingRect(elements) {
	    var self = this;
	    if (elements && elements.length > 0) {
	      [].forEach.call(elements, function (ele) {
	        ele._eleOffset = getOffset(ele); 
	        //移除类名
	        ele.classList.remove(self.options.cls);
	        // 标志已经绑定
	        ele.dataset['bind'] = 1;
	      });
	    }        
	  }
	
	  // 触发加载
	  function __fire() {
	    var container = this.container,
	      elements = this.appearWatchElements,
	      appearCallback = this.options.onAppear,//appear的执行函数
	      disappearCallback = this.options.onDisappear,//disappear的执行函数
	      containerOffset = getOffset(container, {
	        x: this.options.x,
	        y: this.options.y
	      }),
	      isOnce = this.options.once,//是否只执行一次
	      ev = arguments[0] || {};
	    if (elements && elements.length > 0) {
	      [].forEach.call(elements, function (ele, i) {
	        //获取左右距离
	        var eleOffset = getOffset(ele);
	        var direction = getDirection(ele._eleOffset, eleOffset);
	        //保存上个时段的位置信息
	        ele._eleOffset = eleOffset;
	        //查看是否在可视区域范围内
	        var isInView = compareOffset(containerOffset, eleOffset);
	        var appear = ele._appear;
	        var _hasAppear = ele._hasAppear;
	        var _hasDisAppear = ele._hasDisAppear;
	        appearEvt.data = {
	          direction: direction
	        }
	        disappearEvt.data = {
	          direction: direction
	        }
	        if (isInView && !appear) {
	          if ((isOnce && !_hasAppear) || !isOnce) {
	            //如果只触发一次并且没有触发过或者允许触发多次
	            //如果在可视区域内，并且是从disppear进入appear，则执行回调
	            appearCallback && appearCallback.call(ele, ev);
	            //触发自定义事件
	            ele.dispatchEvent(appearEvt);
	            ele._hasAppear = true;
	            ele._appear = true;
	          }
	        } else if (!isInView && appear) {
	          if ((isOnce && !_hasDisAppear) || !isOnce) {
	            //如果不在可视区域内，并且是从appear进入disappear，执行disappear回调
	            disappearCallback && disappearCallback.call(ele, ev);
	            //触发自定义事件
	            ele.dispatchEvent(disappearEvt);
	            ele._hasDisAppear = true;
	            ele._appear = false;
	          }
	        }
	      });
	    }
	  }
	
	  // proto = extend(proto, listener);
	
	  function __init(opts) {
	    //扩展参数
	    extend(this.options, opts || (opts = {}));
	    //获取目标元素
	    this.appearWatchElements = this.appearWatchElements || __getElements.call(this, '.' + this.options.cls);
	    //初始化位置信息
	    __initBoundingRect.call(this, this.appearWatchElements);
	    //绑定事件
	    __bindEvent.call(this);
	  }
	  
	  var Appear = function () {
	    __init.apply(this, arguments);
	  }
	
	
	  var appear = {
	    instances: [],
	    init: function (opts) {
	      var proto = {
	        //默认参数
	        options: {
	          container: window,
	          wait: 100,
	          x: 0,
	          y: 0,
	          cls: 'lib-appear',
	          once: false,
	          onReset: function () {},
	          onAppear: function () {},
	          onDisappear: function () {}
	        },
	        container: null,
	        appearWatchElements: null,
	        bind: function (node) {
	          var cls = this.options.cls;
	          // 添加需要绑定的appear元素
	          if (typeof node == 'string') {
	            var elements = __getElements.call(this, node);
	            [].forEach.call(elements, function (ele, i) {
	              if (!ele.classList.contains(cls)) {
	                ele.classList.add(cls);
	              }
	            });
	            
	          } else if (node.nodeType == 1 && this.container.contains(node)) {
	            //如果传入的是元素并且在包含在容器中，直接添加类名
	            if (!node.classList.contains(cls)) {
	              //添加类名
	              node.classList.add(cls);
	            }
	          } else {
	            return this;
	          }
	          //新增的子元素
	          var newElements = __getElements.call(this, '.' + this.options.cls);
	          //对缓存的子元素做增量
	          this.appearWatchElements = this.appearWatchElements.concat(newElements);
	          //初始化新子元素的位置信息
	          __initBoundingRect.call(this, newElements);
	          return this;
	        },
	        // 重置函数
	        reset: function (opts) {
	          __init.call(this, opts);
	          this.appearWatchElements.forEach(function(ele) {
	            delete ele._hasAppear;
	            delete ele._hasDisAppear;
	            delete ele._appear;
	          });
	          return this;
	        },
	        fire: function () {
	          if (!this.appearWatchElements) {
	            this.appearWatchElements = [];
	          }
	          var newElements = __getElements.call(this, '.' + this.options.cls);
	          this.appearWatchElements = this.appearWatchElements.concat(newElements);
	          //初始化位置信息
	          __initBoundingRect.call(this, newElements);
	          __fire.call(this);
	          return this;
	        }
	      }
	      Appear.prototype = proto;
	      var instance = new Appear(opts);
	      this.instances.push(instance);
	      return instance;
	    },
	    fireAll: function () {
	      var instances = this.instances;
	      instances.forEach(function (instance) {
	        instance.fire();
	      });
	    }
	  }
	  //注册事件
	  createEvent();
	
	  lib.appear = appear;
	
	})(window, window.lib || (window.lib = {}));

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = Atomic;
	
	var _component = __webpack_require__(122);
	
	var _component2 = _interopRequireDefault(_component);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Component which can have no subcomponents.
	// This component should not be instantiated directly, since
	// it is designed to be used as a base class to extend from.
	function Atomic(data) {
	  _component2.default.call(this, data);
	}
	
	Atomic.prototype = Object.create(_component2.default.prototype);
	
	Atomic.prototype.createChildren = function (data) {
	  // do nonthing
	  return;
	};
	
	Atomic.prototype.appendChild = function (data) {
	  // do nothing
	  return;
	};
	
	Atomic.prototype.insertBefore = function (child, before) {
	  // do nothing
	  return;
	};
	
	Atomic.prototype.removeChild = function (child) {
	  // do nothing
	  return;
	};

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.bind = bind;
	
	var _componentManager = __webpack_require__(114);
	
	var _componentManager2 = _interopRequireDefault(_componentManager);
	
	var _loader = __webpack_require__(117);
	
	var _bridge = __webpack_require__(118);
	
	var _utils = __webpack_require__(83);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var methods = {
	  // Register a new component with the specified name.
	
	  registerComponent: function registerComponent(name, comp) {
	    _componentManager2.default.registerComponent(name, comp);
	  },
	
	
	  // Register a new api module.
	  // If the module already exists, just add methods from the
	  // new module to the old one.
	  registerApiModule: function registerApiModule(name, module, meta) {
	    if (!_bridge.protocol.apiModule[name]) {
	      _bridge.protocol.apiModule[name] = module;
	    } else {
	      for (var key in module) {
	        if (module.hasOwnProperty(key)) {
	          _bridge.protocol.apiModule[name][key] = module[key];
	        }
	      }
	    }
	    // register API module's meta info to jsframework
	    if (meta) {
	      _bridge.protocol.setApiModuleMeta(meta);
	      global.registerModules(_bridge.protocol.getApiModuleMeta(name), true);
	    }
	  },
	
	
	  // Register a new api method for the specified module.
	  // opts:
	  //  - args: type of arguments the API method takes such
	  //    as ['string', 'function']
	  registerApi: function registerApi(moduleName, name, method, args) {
	    if (typeof method !== 'function') {
	      return;
	    }
	    if (!_bridge.protocol.apiModule[moduleName]) {
	      _bridge.protocol.apiModule[moduleName] = {};
	      _bridge.protocol._meta[moduleName] = [];
	    }
	    _bridge.protocol.apiModule[moduleName][name] = method;
	    if (!args) {
	      return;
	    }
	    // register API meta info to jsframework
	    _bridge.protocol.setApiMeta(moduleName, {
	      name: name,
	      args: args
	    });
	    global.registerModules(_bridge.protocol.getApiModuleMeta(moduleName), true);
	  },
	
	
	  // Register a new weex-bundle-loader.
	  registerLoader: function registerLoader(name, loaderFunc) {
	    (0, _loader.registerLoader)(name, loaderFunc);
	  }
	};
	
	// To install components and plugins.
	function install(mod) {
	  mod.init(this);
	}
	
	function bind(Weex) {
	  Weex.install = install.bind(Weex);
	  (0, _utils.extend)(Weex, methods);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 134 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a){Object.defineProperty(this,"val",{value:a.toString(),enumerable:!0}),this.gt=function(a){return c.compare(this,a)>0},this.gte=function(a){return c.compare(this,a)>=0},this.lt=function(a){return c.compare(this,a)<0},this.lte=function(a){return c.compare(this,a)<=0},this.eq=function(a){return 0===c.compare(this,a)}}b.env=b.env||{},c.prototype.toString=function(){return this.val},c.prototype.valueOf=function(){for(var a=this.val.split("."),b=[],c=0;c<a.length;c++){var d=parseInt(a[c],10);isNaN(d)&&(d=0);var e=d.toString();e.length<5&&(e=Array(6-e.length).join("0")+e),b.push(e),1===b.length&&b.push(".")}return parseFloat(b.join(""))},c.compare=function(a,b){a=a.toString().split("."),b=b.toString().split(".");for(var c=0;c<a.length||c<b.length;c++){var d=parseInt(a[c],10),e=parseInt(b[c],10);if(window.isNaN(d)&&(d=0),window.isNaN(e)&&(e=0),e>d)return-1;if(d>e)return 1}return 0},b.version=function(a){return new c(a)}}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c=a.location.search.replace(/^\?/,"");if(b.env.params={},c)for(var d=c.split("&"),e=0;e<d.length;e++){d[e]=d[e].split("=");try{b.env.params[d[e][0]]=decodeURIComponent(d[e][1])}catch(f){b.env.params[d[e][0]]=d[e][1]}}}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c,d=a.navigator.userAgent;if(c=d.match(/Windows\sPhone\s(?:OS\s)?([\d\.]+)/))b.env.os={name:"Windows Phone",isWindowsPhone:!0,version:c[1]};else if(d.match(/Safari/)&&(c=d.match(/Android[\s\/]([\d\.]+)/)))b.env.os={version:c[1]},d.match(/Mobile\s+Safari/)?(b.env.os.name="Android",b.env.os.isAndroid=!0):(b.env.os.name="AndroidPad",b.env.os.isAndroidPad=!0);else if(c=d.match(/(iPhone|iPad|iPod)/)){var e=c[1];c=d.match(/OS ([\d_\.]+) like Mac OS X/),b.env.os={name:e,isIPhone:"iPhone"===e||"iPod"===e,isIPad:"iPad"===e,isIOS:!0,version:c[1].split("_").join(".")}}else b.env.os={name:"unknown",version:"0.0.0"};b.version&&(b.env.os.version=b.version(b.env.os.version))}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c,d=a.navigator.userAgent;(c=d.match(/(?:UCWEB|UCBrowser\/)([\d\.]+)/))?b.env.browser={name:"UC",isUC:!0,version:c[1]}:(c=d.match(/MQQBrowser\/([\d\.]+)/))?b.env.browser={name:"QQ",isQQ:!0,version:c[1]}:(c=d.match(/Firefox\/([\d\.]+)/))?b.env.browser={name:"Firefox",isFirefox:!0,version:c[1]}:(c=d.match(/MSIE\s([\d\.]+)/))||(c=d.match(/IEMobile\/([\d\.]+)/))?(b.env.browser={version:c[1]},d.match(/IEMobile/)?(b.env.browser.name="IEMobile",b.env.browser.isIEMobile=!0):(b.env.browser.name="IE",b.env.browser.isIE=!0),d.match(/Android|iPhone/)&&(b.env.browser.isIELikeWebkit=!0)):(c=d.match(/(?:Chrome|CriOS)\/([\d\.]+)/))?(b.env.browser={name:"Chrome",isChrome:!0,version:c[1]},d.match(/Version\/[\d+\.]+\s*Chrome/)&&(b.env.browser.name="Chrome Webview",b.env.browser.isWebview=!0)):d.match(/Safari/)&&(c=d.match(/Android[\s\/]([\d\.]+)/))?b.env.browser={name:"Android",isAndroid:!0,version:c[1]}:d.match(/iPhone|iPad|iPod/)?d.match(/Safari/)?(c=d.match(/Version\/([\d\.]+)/),b.env.browser={name:"Safari",isSafari:!0,version:c[1]}):(c=d.match(/OS ([\d_\.]+) like Mac OS X/),b.env.browser={name:"iOS Webview",isWebview:!0,version:c[1].replace(/\_/g,".")}):b.env.browser={name:"unknown",version:"0.0.0"},b.version&&(b.env.browser.version=b.version(b.env.browser.version))}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c=a.navigator.userAgent;c.match(/Weibo/i)?b.env.thirdapp={appname:"Weibo",isWeibo:!0}:c.match(/MicroMessenger/i)?b.env.thirdapp={appname:"Weixin",isWeixin:!0}:b.env.thirdapp=!1}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c,d,e=a.navigator.userAgent;(d=e.match(/WindVane[\/\s]([\d\.\_]+)/))&&(c=d[1]);var f=!1,g="",h="",i="";(d=e.match(/AliApp\(([A-Z\-]+)\/([\d\.]+)\)/i))&&(f=!0,g=d[1],i=d[2],h=g.indexOf("-PD")>0?b.env.os.isIOS?"iPad":b.env.os.isAndroid?"AndroidPad":b.env.os.name:b.env.os.name),!g&&e.indexOf("TBIOS")>0&&(g="TB"),f?b.env.aliapp={windvane:b.version(c||"0.0.0"),appname:g||"unkown",version:b.version(i||"0.0.0"),platform:h||b.env.os.name}:b.env.aliapp=!1,b.env.taobaoApp=b.env.aliapp}(window,window.lib||(window.lib={}));;module.exports = window.lib['env'];

/***/ },
/* 135 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a){var b={};Object.defineProperty(this,"params",{set:function(a){if("object"==typeof a){for(var c in b)delete b[c];for(var c in a)b[c]=a[c]}},get:function(){return b},enumerable:!0}),Object.defineProperty(this,"search",{set:function(a){if("string"==typeof a){0===a.indexOf("?")&&(a=a.substr(1));var c=a.split("&");for(var d in b)delete b[d];for(var e=0;e<c.length;e++){var f=c[e].split("=");if(void 0!==f[1]&&(f[1]=f[1].toString()),f[0])try{b[decodeURIComponent(f[0])]=decodeURIComponent(f[1])}catch(g){b[f[0]]=f[1]}}}},get:function(){var a=[];for(var c in b)if(void 0!==b[c])if(""!==b[c])try{a.push(encodeURIComponent(c)+"="+encodeURIComponent(b[c]))}catch(d){a.push(c+"="+b[c])}else try{a.push(encodeURIComponent(c))}catch(d){a.push(c)}return a.length?"?"+a.join("&"):""},enumerable:!0});var c;Object.defineProperty(this,"hash",{set:function(a){"string"==typeof a&&(a&&a.indexOf("#")<0&&(a="#"+a),c=a||"")},get:function(){return c},enumerable:!0}),this.set=function(a){a=a||"";var b;if(!(b=a.match(new RegExp("^([a-z0-9-]+:)?[/]{2}(?:([^@/:?]+)(?::([^@/:]+))?@)?([^:/?#]+)(?:[:]([0-9]+))?([/][^?#;]*)?(?:[?]([^#]*))?([#][^?]*)?$","i"))))throw new Error("Wrong uri scheme.");this.protocol=b[1]||("object"==typeof location?location.protocol:""),this.username=b[2]||"",this.password=b[3]||"",this.hostname=this.host=b[4],this.port=b[5]||"",this.pathname=b[6]||"/",this.search=b[7]||"",this.hash=b[8]||"",this.origin=this.protocol+"//"+this.hostname},this.toString=function(){var a=this.protocol+"//";return this.username&&(a+=this.username,this.password&&(a+=":"+this.password),a+="@"),a+=this.host,this.port&&"80"!==this.port&&(a+=":"+this.port),this.pathname&&(a+=this.pathname),this.search&&(a+=this.search),this.hash&&(a+=this.hash),a},a&&this.set(a.toString())}b.httpurl=function(a){return new c(a)}}(window,window.lib||(window.lib={}));;module.exports = window.lib['httpurl'];

/***/ },
/* 136 */
/***/ function(module, exports) {

	/* eslint-disable */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var isInitialized = false;
	
	// major events supported:
	//   panstart
	//   panmove
	//   panend
	//   swipe
	//   longpress
	// extra events supported:
	//   dualtouchstart
	//   dualtouch
	//   dualtouchend
	//   tap
	//   doubletap
	//   pressend
	
	var doc = window.document;
	var docEl = doc.documentElement;
	var slice = Array.prototype.slice;
	var gestures = {};
	var lastTap = null;
	
	/**
	 * find the closest common ancestor
	 * if there's no one, return null
	 *
	 * @param  {Element} el1 first element
	 * @param  {Element} el2 second element
	 * @return {Element}     common ancestor
	 */
	function getCommonAncestor(el1, el2) {
	  var el = el1;
	  while (el) {
	    if (el.contains(el2) || el == el2) {
	      return el;
	    }
	    el = el.parentNode;
	  }
	  return null;
	}
	
	/**
	 * fire a HTMLEvent
	 *
	 * @param  {Element} element which element to fire a event on
	 * @param  {string}  type    type of event
	 * @param  {object}  extra   extra data for the event object
	 */
	function fireEvent(element, type, extra) {
	  var event = doc.createEvent('HTMLEvents');
	  event.initEvent(type, true, true);
	
	  if ((typeof extra === 'undefined' ? 'undefined' : _typeof(extra)) === 'object') {
	    for (var p in extra) {
	      event[p] = extra[p];
	    }
	  }
	
	  element.dispatchEvent(event);
	}
	
	/**
	 * calc the transform
	 * assume 4 points ABCD on the coordinate system
	 * > rotate：angle rotating from AB to CD
	 * > scale：scale ratio from AB to CD
	 * > translate：translate shift from A to C
	 *
	 * @param  {number} x1 abscissa of A
	 * @param  {number} y1 ordinate of A
	 * @param  {number} x2 abscissa of B
	 * @param  {number} y2 ordinate of B
	 * @param  {number} x3 abscissa of C
	 * @param  {number} y3 ordinate of C
	 * @param  {number} x4 abscissa of D
	 * @param  {number} y4 ordinate of D
	 * @return {object}    transform object like
	 *   {rotate, scale, translate[2], matrix[3][3]}
	 */
	function calc(x1, y1, x2, y2, x3, y3, x4, y4) {
	  var rotate = Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y2 - y1, x2 - x1);
	  var scale = Math.sqrt((Math.pow(y4 - y3, 2) + Math.pow(x4 - x3, 2)) / (Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2)));
	  var translate = [x3 - scale * x1 * Math.cos(rotate) + scale * y1 * Math.sin(rotate), y3 - scale * y1 * Math.cos(rotate) - scale * x1 * Math.sin(rotate)];
	
	  return {
	    rotate: rotate,
	    scale: scale,
	    translate: translate,
	    matrix: [[scale * Math.cos(rotate), -scale * Math.sin(rotate), translate[0]], [scale * Math.sin(rotate), scale * Math.cos(rotate), translate[1]], [0, 0, 1]]
	  };
	}
	
	/**
	 * take over the touchstart events. Add new touches to the gestures.
	 * If there is no previous records, then bind touchmove, tochend
	 * and touchcancel events.
	 * new touches initialized with state 'tapping', and within 500 milliseconds
	 * if the state is still tapping, then trigger gesture 'press'.
	 * If there are two touche points, then the 'dualtouchstart' is triggerd. The
	 * node of the touch gesture is their cloest common ancestor.
	 *
	 * @event
	 * @param  {event} event
	 */
	function touchstartHandler(event) {
	
	  if (Object.keys(gestures).length === 0) {
	    docEl.addEventListener('touchmove', touchmoveHandler, false);
	    docEl.addEventListener('touchend', touchendHandler, false);
	    docEl.addEventListener('touchcancel', touchcancelHandler, false);
	  }
	
	  // record every touch
	  for (var i = 0; i < event.changedTouches.length; i++) {
	    var touch = event.changedTouches[i];
	    var touchRecord = {};
	
	    for (var p in touch) {
	      touchRecord[p] = touch[p];
	    }
	
	    var gesture = {
	      startTouch: touchRecord,
	      startTime: Date.now(),
	      status: 'tapping',
	      element: event.srcElement || event.target,
	      pressingHandler: setTimeout(function (element, touch) {
	        return function () {
	          if (gesture.status === 'tapping') {
	            gesture.status = 'pressing';
	
	            fireEvent(element, 'longpress', {
	              // add touch data for weex
	              touch: touch,
	              touches: event.touches,
	              changedTouches: event.changedTouches,
	              touchEvent: event
	            });
	          }
	
	          clearTimeout(gesture.pressingHandler);
	          gesture.pressingHandler = null;
	        };
	      }(event.srcElement || event.target, event.changedTouches[i]), 500)
	    };
	    gestures[touch.identifier] = gesture;
	  }
	
	  if (Object.keys(gestures).length == 2) {
	    var elements = [];
	
	    for (var p in gestures) {
	      elements.push(gestures[p].element);
	    }
	
	    fireEvent(getCommonAncestor(elements[0], elements[1]), 'dualtouchstart', {
	      touches: slice.call(event.touches),
	      touchEvent: event
	    });
	  }
	}
	
	/**
	 * take over touchmove events, and handle pan and dual related gestures.
	 *
	 * 1. traverse every touch point：
	 * > if 'tapping' and the shift is over 10 pixles, then it's a 'panning'.
	 * 2. if there are two touch points, then calc the tranform and trigger
	 *   'dualtouch'.
	 *
	 * @event
	 * @param  {event} event
	 */
	function touchmoveHandler(event) {
	  for (var i = 0; i < event.changedTouches.length; i++) {
	    var touch = event.changedTouches[i];
	    var gesture = gestures[touch.identifier];
	
	    if (!gesture) {
	      return;
	    }
	
	    if (!gesture.lastTouch) {
	      gesture.lastTouch = gesture.startTouch;
	    }
	    if (!gesture.lastTime) {
	      gesture.lastTime = gesture.startTime;
	    }
	    if (!gesture.velocityX) {
	      gesture.velocityX = 0;
	    }
	    if (!gesture.velocityY) {
	      gesture.velocityY = 0;
	    }
	    if (!gesture.duration) {
	      gesture.duration = 0;
	    }
	
	    var time = Date.now() - gesture.lastTime;
	    var vx = (touch.clientX - gesture.lastTouch.clientX) / time;
	    var vy = (touch.clientY - gesture.lastTouch.clientY) / time;
	
	    var RECORD_DURATION = 70;
	    if (time > RECORD_DURATION) {
	      time = RECORD_DURATION;
	    }
	    if (gesture.duration + time > RECORD_DURATION) {
	      gesture.duration = RECORD_DURATION - time;
	    }
	
	    gesture.velocityX = (gesture.velocityX * gesture.duration + vx * time) / (gesture.duration + time);
	    gesture.velocityY = (gesture.velocityY * gesture.duration + vy * time) / (gesture.duration + time);
	    gesture.duration += time;
	
	    gesture.lastTouch = {};
	
	    for (var p in touch) {
	      gesture.lastTouch[p] = touch[p];
	    }
	    gesture.lastTime = Date.now();
	
	    var displacementX = touch.clientX - gesture.startTouch.clientX;
	    var displacementY = touch.clientY - gesture.startTouch.clientY;
	    var distance = Math.sqrt(Math.pow(displacementX, 2) + Math.pow(displacementY, 2));
	    var isVertical = !(Math.abs(displacementX) > Math.abs(displacementY));
	    var direction = isVertical ? displacementY >= 0 ? 'down' : 'up' : displacementX >= 0 ? 'right' : 'left';
	
	    // magic number 10: moving 10px means pan, not tap
	    if ((gesture.status === 'tapping' || gesture.status === 'pressing') && distance > 10) {
	      gesture.status = 'panning';
	      gesture.isVertical = isVertical;
	      gesture.direction = direction;
	
	      fireEvent(gesture.element, 'panstart', {
	        touch: touch,
	        touches: event.touches,
	        changedTouches: event.changedTouches,
	        touchEvent: event,
	        isVertical: gesture.isVertical,
	        direction: direction
	      });
	    }
	
	    if (gesture.status === 'panning') {
	      gesture.panTime = Date.now();
	
	      fireEvent(gesture.element, 'panmove', {
	        displacementX: displacementX,
	        displacementY: displacementY,
	        touch: touch,
	        touches: event.touches,
	        changedTouches: event.changedTouches,
	        touchEvent: event,
	        isVertical: gesture.isVertical,
	        direction: direction
	      });
	    }
	  }
	
	  if (Object.keys(gestures).length == 2) {
	    var position = [];
	    var current = [];
	    var elements = [];
	    var transform;
	
	    for (var i = 0; i < event.touches.length; i++) {
	      var touch = event.touches[i];
	      var gesture = gestures[touch.identifier];
	      position.push([gesture.startTouch.clientX, gesture.startTouch.clientY]);
	      current.push([touch.clientX, touch.clientY]);
	    }
	
	    for (var p in gestures) {
	      elements.push(gestures[p].element);
	    }
	
	    transform = calc(position[0][0], position[0][1], position[1][0], position[1][1], current[0][0], current[0][1], current[1][0], current[1][1]);
	    fireEvent(getCommonAncestor(elements[0], elements[1]), 'dualtouch', {
	      transform: transform,
	      touches: event.touches,
	      touchEvent: event
	    });
	  }
	}
	
	/**
	 * handle touchend event
	 *
	 * 1. if there are tow touch points, then trigger 'dualtouchend'如
	 *
	 * 2. traverse every touch piont：
	 * > if tapping, then trigger 'tap'.
	 * If there is a tap 300 milliseconds before, then it's a 'doubletap'.
	 * > if padding, then decide to trigger 'panend' or 'swipe'
	 * > if pressing, then trigger 'pressend'.
	 *
	 * 3. remove listeners.
	 *
	 * @event
	 * @param  {event} event
	 */
	function touchendHandler(event) {
	
	  if (Object.keys(gestures).length == 2) {
	    var elements = [];
	    for (var p in gestures) {
	      elements.push(gestures[p].element);
	    }
	    fireEvent(getCommonAncestor(elements[0], elements[1]), 'dualtouchend', {
	      touches: slice.call(event.touches),
	      touchEvent: event
	    });
	  }
	
	  for (var i = 0; i < event.changedTouches.length; i++) {
	    var touch = event.changedTouches[i];
	    var id = touch.identifier;
	    var gesture = gestures[id];
	
	    if (!gesture) {
	      continue;
	    }
	
	    if (gesture.pressingHandler) {
	      clearTimeout(gesture.pressingHandler);
	      gesture.pressingHandler = null;
	    }
	
	    if (gesture.status === 'tapping') {
	      gesture.timestamp = Date.now();
	      fireEvent(gesture.element, 'tap', {
	        touch: touch,
	        touchEvent: event
	      });
	
	      if (lastTap && gesture.timestamp - lastTap.timestamp < 300) {
	        fireEvent(gesture.element, 'doubletap', {
	          touch: touch,
	          touchEvent: event
	        });
	      }
	
	      lastTap = gesture;
	    }
	
	    if (gesture.status === 'panning') {
	      var now = Date.now();
	      var duration = now - gesture.startTime;
	      var displacementX = touch.clientX - gesture.startTouch.clientX;
	      var displacementY = touch.clientY - gesture.startTouch.clientY;
	
	      var velocity = Math.sqrt(gesture.velocityY * gesture.velocityY + gesture.velocityX * gesture.velocityX);
	      var isSwipe = velocity > 0.5 && now - gesture.lastTime < 100;
	      var extra = {
	        duration: duration,
	        isSwipe: isSwipe,
	        velocityX: gesture.velocityX,
	        velocityY: gesture.velocityY,
	        displacementX: displacementX,
	        displacementY: displacementY,
	        touch: touch,
	        touches: event.touches,
	        changedTouches: event.changedTouches,
	        touchEvent: event,
	        isVertical: gesture.isVertical,
	        direction: gesture.direction
	      };
	
	      fireEvent(gesture.element, 'panend', extra);
	      if (isSwipe) {
	        fireEvent(gesture.element, 'swipe', extra);
	      }
	    }
	
	    if (gesture.status === 'pressing') {
	      fireEvent(gesture.element, 'pressend', {
	        touch: touch,
	        touchEvent: event
	      });
	    }
	
	    delete gestures[id];
	  }
	
	  if (Object.keys(gestures).length === 0) {
	    docEl.removeEventListener('touchmove', touchmoveHandler, false);
	    docEl.removeEventListener('touchend', touchendHandler, false);
	    docEl.removeEventListener('touchcancel', touchcancelHandler, false);
	  }
	}
	
	/**
	 * handle touchcancel
	 *
	 * 1. if there are two touch points, then trigger 'dualtouchend'
	 *
	 * 2. traverse everty touch point:
	 * > if pannnig, then trigger 'panend'
	 * > if pressing, then trigger 'pressend'
	 *
	 * 3. remove listeners
	 *
	 * @event
	 * @param  {event} event
	 */
	function touchcancelHandler(event) {
	
	  if (Object.keys(gestures).length == 2) {
	    var elements = [];
	    for (var p in gestures) {
	      elements.push(gestures[p].element);
	    }
	    fireEvent(getCommonAncestor(elements[0], elements[1]), 'dualtouchend', {
	      touches: slice.call(event.touches),
	      touchEvent: event
	    });
	  }
	
	  for (var i = 0; i < event.changedTouches.length; i++) {
	    var touch = event.changedTouches[i];
	    var id = touch.identifier;
	    var gesture = gestures[id];
	
	    if (!gesture) {
	      continue;
	    }
	
	    if (gesture.pressingHandler) {
	      clearTimeout(gesture.pressingHandler);
	      gesture.pressingHandler = null;
	    }
	
	    if (gesture.status === 'panning') {
	      fireEvent(gesture.element, 'panend', {
	        touch: touch,
	        touches: event.touches,
	        changedTouches: event.changedTouches,
	        touchEvent: event
	      });
	    }
	    if (gesture.status === 'pressing') {
	      fireEvent(gesture.element, 'pressend', {
	        touch: touch,
	        touchEvent: event
	      });
	    }
	    delete gestures[id];
	  }
	
	  if (Object.keys(gestures).length === 0) {
	    docEl.removeEventListener('touchmove', touchmoveHandler, false);
	    docEl.removeEventListener('touchend', touchendHandler, false);
	    docEl.removeEventListener('touchcancel', touchcancelHandler, false);
	  }
	}
	
	if (!isInitialized) {
	  docEl.addEventListener('touchstart', touchstartHandler, false);
	  isInitialized = true;
	}

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _componentManager = __webpack_require__(114);
	
	var _componentManager2 = _interopRequireDefault(_componentManager);
	
	var _config = __webpack_require__(116);
	
	var _config2 = _interopRequireDefault(_config);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function detectRootHeight(root) {
	  var rootQuery = '#' + root.getWeexInstance().rootId;
	  var rootContainer = document.querySelector(rootQuery) || document.body;
	  var height = rootContainer.getBoundingClientRect().height;
	  if (height > global.innerHeight) {
	    console.warn(['[h5-render] for scrollable root like \'list\' and \'scroller\', the height of ', 'the root container must be a user-specified value. Otherwise ', 'the scrollable element may not be able to work correctly. ', 'Current height of the root element \'' + rootQuery + '\' is ', height + 'px, and mostly its height should be less than the ', 'viewport\'s height ' + global.innerHeight + 'px. Please ', 'make sure the height is correct.'].join(''));
	  }
	}
	
	function init(Weex) {
	  var Component = Weex.Component;
	
	  function RootComponent(data, nodeType) {
	    var id = data.rootId + '-root';
	    var cm = _componentManager2.default.getInstance(data.instanceId);
	
	    this.data = data;
	
	    // In some situation the root component should be implemented as
	    // its own type, otherwise it has to be a div component as a root.
	    if (!nodeType) {
	      nodeType = 'div';
	    } else if (_config2.default.validRoots.indexOf(nodeType) === -1) {
	      console.warn('[h5-render] the root component type \'' + nodeType + '\' is not one of ' + 'the types in [' + _config2.default.validRoots + '] list. It is auto downgraded ' + 'to \'div\'.');
	      nodeType = 'div';
	    } else {
	      if (!global.weex.getInstance(data.instanceId).embed) {
	        window.addEventListener('renderend', function () {
	          detectRootHeight(this);
	        }.bind(this));
	      }
	      !this.data.style.height && (this.data.style.height = '100%');
	    }
	
	    data.type = nodeType;
	    var cmp = cm.createElement(data);
	    cmp.node.id = id;
	    return cmp;
	  }
	
	  RootComponent.prototype = Object.create(Component.prototype);
	
	  Weex.registerComponent('root', RootComponent);
	}
	
	exports.default = { init: init };
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 138 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function init(Weex) {
	  var Component = Weex.Component;
	
	  function Div(data, nodeType) {
	    Component.call(this, data, nodeType);
	    this.node.classList.add('weex-container');
	  }
	  Div.prototype = Object.create(Component.prototype);
	
	  Weex.registerComponent('div', Div);
	  Weex.registerComponent('container', Div);
	}
	
	exports.default = { init: init };

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _image = __webpack_require__(140);
	
	var _image2 = _interopRequireDefault(_image);
	
	var _text = __webpack_require__(143);
	
	var _text2 = _interopRequireDefault(_text);
	
	var _scrollable = __webpack_require__(144);
	
	var _scrollable2 = _interopRequireDefault(_scrollable);
	
	var _slider = __webpack_require__(161);
	
	var _slider2 = _interopRequireDefault(_slider);
	
	var _indicator = __webpack_require__(170);
	
	var _indicator2 = _interopRequireDefault(_indicator);
	
	var _tabheader = __webpack_require__(173);
	
	var _tabheader2 = _interopRequireDefault(_tabheader);
	
	var _input = __webpack_require__(176);
	
	var _input2 = _interopRequireDefault(_input);
	
	var _video = __webpack_require__(177);
	
	var _video2 = _interopRequireDefault(_video);
	
	var _switch = __webpack_require__(180);
	
	var _switch2 = _interopRequireDefault(_switch);
	
	var _a = __webpack_require__(183);
	
	var _a2 = _interopRequireDefault(_a);
	
	var _embed = __webpack_require__(184);
	
	var _embed2 = _interopRequireDefault(_embed);
	
	var _spinner = __webpack_require__(185);
	
	var _spinner2 = _interopRequireDefault(_spinner);
	
	var _web = __webpack_require__(188);
	
	var _web2 = _interopRequireDefault(_web);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// import Refresh from './refresh'
	// import Loading from './loading'
	
	// import Select from './select'
	// import Datepicker from './datepicker'
	// import Timepicker from './timepicker'
	// TODO
	// import Countdown from './countdown'
	// import Marquee from './marquee'
	exports.default = {
	  init: function init(Weex) {
	    Weex.install(_image2.default);
	    Weex.install(_text2.default);
	    Weex.install(_scrollable2.default); // TODO
	    // Weex.install(Countdown)
	    // Weex.install(Marquee)
	    Weex.install(_slider2.default);
	    Weex.install(_indicator2.default);
	    Weex.install(_tabheader2.default); // TODO
	    Weex.install(_input2.default);
	    // Weex.registerComponent('list', Vlist)
	    // Weex.registerComponent('vlist', Vlist)
	    // Weex.registerComponent('hlist', Hlist)
	    // Weex.registerComponent('scroller', Scroller)
	    // Weex.registerComponent('select', Select)
	    // Weex.registerComponent('datepicker', Datepicker)
	    // Weex.registerComponent('timepicker', Timepicker)
	    Weex.install(_video2.default);
	    Weex.install(_switch2.default);
	    Weex.install(_a2.default);
	    Weex.install(_embed2.default);
	    // Weex.install(Refresh)
	    // Weex.install(Loading)
	    Weex.install(_spinner2.default);
	    Weex.install(_web2.default);
	  }
	}; // TODO
	// import Scroller from './scroller'

	// import Vlist from './vlist'
	// import Hlist from './hlist'

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/* global lib */
	
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(141);
	
	var DEFAULT_SIZE = 200;
	var RESIZE_MODES = ['stretch', 'cover', 'contain'];
	var DEFAULT_RESIZE_MODE = 'stretch';
	
	/**
	 * resize: 'cover' | 'contain' | 'stretch', default is 'stretch'
	 * src: url
	 */
	var proto = {
	  create: function create() {
	    var node = document.createElement('div');
	    node.classList.add('weex-img', 'weex-element');
	    return node;
	  },
	  clearAttr: function clearAttr() {
	    this.src = '';
	    this.node.style.backgroundImage = '';
	  }
	};
	
	var attr = {
	  src: function src(val) {
	    if (!this.src) {
	      this.src = lib.img.defaultSrc;
	      this.node.style.backgroundImage = 'url(' + this.src + ')';
	    }
	    this.enableLazyload(val);
	  },
	
	  resize: function resize(val) {
	    if (RESIZE_MODES.indexOf(val) === -1) {
	      val = 'stretch';
	    }
	    this.node.style.backgroundSize = val === 'stretch' ? '100% 100%' : val;
	  }
	};
	
	var style = {
	  width: function width(val) {
	    val = parseFloat(val) * this.data.scale;
	    if (val < 0 || isNaN(val)) {
	      val = DEFAULT_SIZE;
	    }
	    this.node.style.width = val + 'px';
	  },
	
	  height: function height(val) {
	    val = parseFloat(val) * this.data.scale;
	    if (val < 0 || isNaN(val)) {
	      val = DEFAULT_SIZE;
	    }
	    this.node.style.height = val + 'px';
	  }
	};
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	
	  function Image(data) {
	    this.resize = DEFAULT_RESIZE_MODE;
	    Atomic.call(this, data);
	  }
	  Image.prototype = Object.create(Atomic.prototype);
	  extend(Image.prototype, proto);
	  extend(Image.prototype, { attr: attr });
	  extend(Image.prototype, {
	    style: extend(Object.create(Atomic.prototype.style), style)
	  });
	
	  Weex.registerComponent('image', Image);
	}
	
	exports.default = { init: init };

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(142);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./image.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./image.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-img {\n  background-repeat: no-repeat;\n  background-size: 100% 100%;\n  background-position: 50%;\n}", ""]);
	
	// exports


/***/ },
/* 143 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var DEFAULT_FONT_SIZE = 32;
	var DEFAULT_TEXT_OVERFLOW = 'ellipsis';
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('div');
	    node.classList.add('weex-container');
	    node.style.fontSize = DEFAULT_FONT_SIZE * this.data.scale + 'px';
	    this.textNode = document.createElement('span');
	    // Give the developers the ability to control space
	    // and line-breakers.
	    this.textNode.style.whiteSpace = 'pre-wrap';
	    this.textNode.style.wordWrap = 'break-word';
	    this.textNode.style.display = '-webkit-box';
	    this.textNode.style.webkitBoxOrient = 'vertical';
	    this.style.lines.call(this, this.data.style.lines);
	    node.appendChild(this.textNode);
	    return node;
	  },
	  clearAttr: function clearAttr() {
	    this.node.firstChild.textContent = '';
	  }
	};
	
	var attr = {
	  value: function value(_value) {
	    var span = this.node.firstChild;
	    span.innerHTML = '';
	    if (_value == null || _value === '') {
	      return;
	    }
	    span.textContent = _value;
	    /**
	     * Developers are supposed to have the ability to break text
	     * lines manually. Using ``&nbsp;`` to replace text space is
	     * not compatible with the ``-webkit-line-clamp``. Therefor
	     * we use ``white-space: no-wrap`` instead (instead of the
	     * code bellow).
	       const frag = document.createDocumentFragment()
	        text.split(' ').forEach(function(str) {
	          const textNode = document.createTextNode(str)
	          const space = document.createElement('i')
	          space.innerHTML = '&nbsp;'
	          frag.appendChild(space)
	          frag.appendChild(textNode)
	        })
	        frag.removeChild(frag.firstChild)
	        span.appendChild(document.createElement('br'))
	        span.appendChild(frag)
	      })
	      span.removeChild(span.firstChild)
	     */
	  }
	};
	
	var style = {
	  lines: function lines(val) {
	    val = parseInt(val);
	    if (isNaN(val)) {
	      return;
	    }
	    if (val <= 0) {
	      this.textNode.style.textOverflow = '';
	      this.textNode.style.overflow = 'visible';
	      this.textNode.style.webkitLineClamp = '';
	    } else {
	      var _style = this.data ? this.data.style : null;
	      this.textNode.style.overflow = 'hidden';
	      this.textNode.style.textOverflow = _style ? _style.textOverflow : DEFAULT_TEXT_OVERFLOW;
	      this.textNode.style.webkitLineClamp = val;
	    }
	  },
	
	  textOverflow: function textOverflow(val) {
	    this.textNode.style.textOverflow = val;
	  }
	};
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	
	  // attr
	  //  - value: text content.
	  // style
	  //  - lines: maximum lines of the text.
	  function Text(data) {
	    Atomic.call(this, data);
	  }
	  Text.prototype = Object.create(Atomic.prototype);
	  extend(Text.prototype, proto);
	  extend(Text.prototype, { attr: attr });
	  extend(Text.prototype, {
	    style: extend(Object.create(Atomic.prototype.style), style)
	  });
	
	  Weex.registerComponent('text', Text);
	}
	
	exports.default = { init: init };

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _list = __webpack_require__(145);
	
	var _list2 = _interopRequireDefault(_list);
	
	var _scroller = __webpack_require__(154);
	
	var _scroller2 = _interopRequireDefault(_scroller);
	
	var _refresh = __webpack_require__(155);
	
	var _refresh2 = _interopRequireDefault(_refresh);
	
	var _loading = __webpack_require__(158);
	
	var _loading2 = _interopRequireDefault(_loading);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.install(_list2.default);
	    Weex.install(_scroller2.default);
	    Weex.install(_refresh2.default);
	    Weex.install(_loading2.default);
	  }
	};

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _vlist = __webpack_require__(146);
	
	var _vlist2 = _interopRequireDefault(_vlist);
	
	var _hlist = __webpack_require__(153);
	
	var _hlist2 = _interopRequireDefault(_hlist);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function init(Weex) {
	  Weex.install(_vlist2.default);
	  Weex.install(_hlist2.default);
	}
	
	exports.default = { init: init };

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _list = __webpack_require__(147);
	
	var _list2 = _interopRequireDefault(_list);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function init(Weex) {
	  var List = _list2.default.init(Weex);
	
	  function Vlist(data, nodeType) {
	    data.attr.direction = 'v';
	    List.call(this, data, nodeType);
	  }
	  Vlist.prototype = Object.create(List.prototype);
	
	  Weex.registerComponent('list', Vlist);
	  Weex.registerComponent('vlist', Vlist);
	}
	
	exports.default = { init: init };

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _scrollable = __webpack_require__(148);
	
	var _scrollable2 = _interopRequireDefault(_scrollable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var availableChildrenTypes = ['cell', 'loading', 'refresh'];
	
	function getProto(Scrollable) {
	  return {
	    create: function create() {
	      var node = Scrollable.prototype.create.call(this);
	      node.classList.add('list-wrap');
	      this.scrollElement.classList.add('list-element');
	      return node;
	    },
	    createChildren: function createChildren() {
	      var children = this.data.children || [];
	      children.forEach(function (data) {
	        var type = data.type;
	        if (availableChildrenTypes.indexOf(type) === -1) {
	          // throw new Error('[h5-render] invalid child type "'
	          //   + type + '" for list.')
	          console.warn('[h5-render] invalid child type "' + type + '" for list.');
	        }
	      });
	      return Scrollable.prototype.createChildren.call(this);
	    },
	    appendChild: function appendChild(data) {
	      var type = data.type;
	      if (availableChildrenTypes.indexOf(type) === -1) {
	        // throw new Error('[h5-render] invalid child type "'
	        //   + type + '" for list.')
	        console.warn('[h5-render] invalid child type "' + type + '" for list.');
	      }
	      return Scrollable.prototype.appendChild.call(this, data);
	    },
	    insertBefore: function insertBefore(child, before) {
	      var type = child.data.type;
	      if (availableChildrenTypes.indexOf(type) === -1) {
	        // throw new Error('[h5-render] invalid child type "'
	        //   + type + '" for list.')
	        console.warn('[h5-render] invalid child type "' + type + '" for list.');
	      }
	      return Scrollable.prototype.insertBefore.call(this, child, before);
	    }
	  };
	}
	
	function init(Weex) {
	  var Scrollable = _scrollable2.default.init(Weex);
	  function List(data, nodeType) {
	    Scrollable.call(this, data, nodeType);
	  }
	  var extend = Weex.utils.extend;
	
	  List.prototype = Object.create(Scrollable.prototype);
	  extend(List.prototype, getProto(Scrollable));
	
	  return List;
	}
	
	exports.default = { init: init };

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/* global lib */
	
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	__webpack_require__(149);
	__webpack_require__(151);
	
	// lib.scroll events:
	//  - scrollstart
	//  - scrolling
	//  - pulldownend
	//  - pullupend
	//  - pullleftend
	//  - pullrightend
	//  - pulldown
	//  - pullup
	//  - pullleft
	//  - pullright
	//  - contentrefresh
	
	var directionMap = {
	  h: ['row', 'horizontal', 'h', 'x'],
	  v: ['column', 'vertical', 'v', 'y']
	};
	
	var DEFAULT_DIRECTION = 'column';
	var DEFAULT_LOAD_MORE_OFFSET = 0;
	
	function refreshWhenDomRenderend(comp) {
	  if (!comp.renderendHandler) {
	    comp.renderendHandler = function () {
	      comp.scroller.refresh();
	    };
	  }
	  window.addEventListener('renderend', comp.renderendHandler);
	}
	
	function removeEvents(comp) {
	  if (comp.renderendHandler) {
	    window.removeEventListener('renderend', comp.renderendHandler);
	  }
	}
	
	function getProto(Weex) {
	  var Component = Weex.Component;
	
	  function create(nodeType) {
	    var Scroll = lib.scroll;
	    var node = Component.prototype.create.call(this, nodeType);
	    node.classList.add('weex-container', 'scrollable-wrap');
	    this.scrollElement = document.createElement('div');
	    this.scrollElement.classList.add('weex-container', 'scrollable-element', 'dir-' + this.direction);
	
	    this.scrollElement.style.webkitBoxOrient = directionMap[this.direction][1];
	    this.scrollElement.style.webkitFlexDirection = directionMap[this.direction][0];
	    this.scrollElement.style.flexDirection = directionMap[this.direction][0];
	
	    node.appendChild(this.scrollElement);
	    this.scroller = new Scroll({
	      // if the direction is x, then the bounding rect of the scroll element
	      // should be got by the 'Range' API other than the 'getBoundingClientRect'
	      // API, because the width outside the viewport won't be count in by
	      // 'getBoundingClientRect'.
	      // Otherwise should use the element rect in case there is a child scroller
	      // or list in this scroller. If using 'Range', the whole scroll element
	      // including the hiding part will be count in the rect.
	      useElementRect: this.direction === 'v',
	      scrollElement: this.scrollElement,
	      direction: this.direction === 'h' ? 'x' : 'y'
	    });
	    this.scroller.init();
	    this.offset = 0;
	    return node;
	  }
	
	  function createChildren() {
	    var children = this.data.children;
	    var parentRef = this.data.ref;
	    var componentManager = this.getComponentManager();
	    if (children && children.length) {
	      var fragment = document.createDocumentFragment();
	      var isFlex = false;
	      for (var i = 0; i < children.length; i++) {
	        children[i].instanceId = this.data.instanceId;
	        children[i].scale = this.data.scale;
	        var child = componentManager.createElement(children[i]);
	        fragment.appendChild(child.node);
	        child.parentRef = parentRef;
	        if (!isFlex && child.data.style && child.data.style.hasOwnProperty('flex')) {
	          isFlex = true;
	        }
	      }
	      this.scrollElement.appendChild(fragment);
	    }
	    // wait for fragment to appended on scrollElement on UI thread.
	    setTimeout(function () {
	      this.scroller.refresh();
	    }.bind(this), 0);
	  }
	
	  function appendChild(data) {
	    var children = this.data.children;
	    var componentManager = this.getComponentManager();
	    var child = componentManager.createElement(data);
	    this.scrollElement.appendChild(child.node);
	
	    // wait for UI thread to update.
	    setTimeout(function () {
	      this.scroller.refresh();
	    }.bind(this), 0);
	
	    // update this.data.children
	    if (!children || !children.length) {
	      this.data.children = [data];
	    } else {
	      children.push(data);
	    }
	
	    return child;
	  }
	
	  function insertBefore(child, before) {
	    var children = this.data.children;
	    var i = 0;
	    var isAppend = false;
	
	    // update this.data.children
	    if (!children || !children.length || !before) {
	      isAppend = true;
	    } else {
	      var l = void 0;
	      for (l = children.length; i < l; i++) {
	        if (children[i].ref === before.data.ref) {
	          break;
	        }
	      }
	      if (i === l) {
	        isAppend = true;
	      }
	    }
	
	    if (isAppend) {
	      this.scrollElement.appendChild(child.node);
	      children.push(child.data);
	    } else {
	      var refreshLoadingPlaceholder = before.refreshPlaceholder || before.loadingPlaceholder;
	      if (refreshLoadingPlaceholder) {
	        this.scrollElement.insertBefore(child.node, refreshLoadingPlaceholder);
	      } else if (before.fixedPlaceholder) {
	        this.scrollElement.insertBefore(child.node, before.fixedPlaceholder);
	      } else if (before.stickyPlaceholder) {
	        this.scrollElement.insertBefore(child.node, before.stickyPlaceholder);
	      } else {
	        this.scrollElement.insertBefore(child.node, before.node);
	      }
	      children.splice(i, 0, child.data);
	    }
	
	    // wait for UI thread to update.
	    setTimeout(function () {
	      this.scroller.refresh();
	    }.bind(this), 0);
	  }
	
	  function removeChild(child) {
	    var children = this.data.children;
	    // remove from this.data.children
	    var i = 0;
	    var componentManager = this.getComponentManager();
	    if (children && children.length) {
	      var l = void 0;
	      for (l = children.length; i < l; i++) {
	        if (children[i].ref === child.data.ref) {
	          break;
	        }
	      }
	      if (i < l) {
	        children.splice(i, 1);
	      }
	    }
	    // remove from componentMap recursively
	    componentManager.removeComponent(child.data.ref);
	    var refreshLoadingPlaceholder = child.refreshPlaceholder || child.loadingPlaceholder;
	    child.unsetPosition();
	    if (refreshLoadingPlaceholder) {
	      this.scrollElement.removeChild(refreshLoadingPlaceholder);
	    }
	    child.node.parentNode.removeChild(child.node);
	
	    // wait for UI thread to update.
	    setTimeout(function () {
	      this.scroller.refresh();
	    }.bind(this), 0);
	  }
	
	  function bindEvents(evts) {
	    Component.prototype.bindEvents.call(this, evts);
	    // to enable lazyload for Images
	    this.scroller.addEventListener('scrolling', function (e) {
	      var so = e.scrollObj;
	      var scrollTop = so.getScrollTop();
	      var scrollLeft = so.getScrollLeft();
	      var offset = this.direction === 'v' ? scrollTop : scrollLeft;
	      var diff = offset - this.offset;
	      var dir = void 0;
	      if (diff >= 0) {
	        dir = this.direction === 'v' ? 'up' : 'left';
	      } else {
	        dir = this.direction === 'v' ? 'down' : 'right';
	      }
	      this.dispatchEvent('scroll', {
	        originalType: 'scrolling',
	        scrollTop: so.getScrollTop(),
	        scrollLeft: so.getScrollLeft(),
	        offset: offset,
	        direction: dir
	      }, {
	        bubbles: true
	      });
	      this.offset = offset;
	
	      // fire loadmore event.
	      var leftDist = Math.abs(so.maxScrollOffset) - this.offset;
	      if (leftDist <= this.loadmoreoffset && this.isAvailableToFireloadmore) {
	        this.isAvailableToFireloadmore = false;
	        this.dispatchEvent('loadmore');
	      } else if (leftDist > this.loadmoreoffset && !this.isAvailableToFireloadmore) {
	        this.isAvailableToFireloadmore = true;
	      }
	    }.bind(this));
	  }
	
	  function onAppend() {
	    refreshWhenDomRenderend(this);
	  }
	
	  function onRemove() {
	    removeEvents(this);
	  }
	
	  return {
	    create: create,
	    createChildren: createChildren,
	    appendChild: appendChild,
	    insertBefore: insertBefore,
	    removeChild: removeChild,
	    bindEvents: bindEvents,
	    onAppend: onAppend,
	    onRemove: onRemove
	  };
	}
	
	var attr = {
	  loadmoreoffset: function loadmoreoffset(val) {
	    val = parseFloat(val);
	    if (val < 0 || isNaN(val)) {
	      console.warn('[h5-render] invalida');
	      return;
	    }
	    this.loadmoreoffset = val;
	  }
	};
	
	function init(Weex) {
	  var Component = Weex.Component;
	  var extend = Weex.utils.extend;
	
	  // attrs:
	  //  - loadmoreoffset: updatable
	  //  - scroll-direciton: none|vertical|horizontal (default is vertical)
	  //  - show-scrollbar: true|false (default is true)
	  function Scrollable(data, nodeType) {
	    this.loadmoreoffset = DEFAULT_LOAD_MORE_OFFSET;
	    this.isAvailableToFireloadmore = true;
	    var attrs = data.attr || {};
	    var direction = attrs.scrollDirection || attrs.direction || DEFAULT_DIRECTION;
	    this.direction = directionMap.h.indexOf(direction) === -1 ? 'v' : 'h';
	    this.showScrollbar = attrs.showScrollbar || true;
	    Component.call(this, data, nodeType);
	  }
	  Scrollable.prototype = Object.create(Component.prototype);
	  extend(Scrollable.prototype, getProto(Weex));
	  extend(Scrollable.prototype, { attr: attr });
	  return Scrollable;
	}
	
	exports.default = { init: init };

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(150);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./scrollable.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./scrollable.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".scrollable-wrap {\n  display: block;\n  overflow: hidden;\n}\n\n.scrollable-element.horizontal {\n  -webkit-box-orient: horizontal;\n  -webkit-flex-direction: row;\n  flex-direction: row;\n}\n.scrollable-element.vertical {\n  -webkit-box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n}\n", ""]);
	
	// exports


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	/* eslint-disable */
	
	__webpack_require__(152);
	
	var doc = window.document;
	var ua = window.navigator.userAgent;
	var scrollObjs = {};
	var plugins = {};
	var dpr = window.dpr || (!!window.navigator.userAgent.match(/iPhone|iPad|iPod/) ? document.documentElement.clientWidth / window.screen.availWidth : 1);
	var inertiaCoefficient = {
	  normal: [2 * dpr, 0.0015 * dpr],
	  slow: [1.5 * dpr, 0.003 * dpr],
	  veryslow: [1.5 * dpr, 0.005 * dpr]
	};
	var timeFunction = {
	  ease: [.25, .1, .25, 1],
	  liner: [0, 0, 1, 1],
	  'ease-in': [.42, 0, 1, 1],
	  'ease-out': [0, 0, .58, 1],
	  'ease-in-out': [.42, 0, .58, 1]
	};
	var Firefox = !!ua.match(/Firefox/i);
	var IEMobile = !!ua.match(/IEMobile/i);
	var cssPrefix = Firefox ? '-moz-' : IEMobile ? '-ms-' : '-webkit-';
	var stylePrefix = Firefox ? 'Moz' : IEMobile ? 'ms' : 'webkit';
	
	function debugLog() {
	  if (lib.scroll.outputDebugLog) {
	    console.log.apply(console, arguments);
	  }
	}
	
	function getBoundingClientRect(el) {
	  var rect = el.getBoundingClientRect();
	  if (!rect) {
	    rect = {};
	    rect.width = el.offsetWidth;
	    rect.height = el.offsetHeight;
	
	    rect.left = el.offsetLeft;
	    rect.top = el.offsetTop;
	    var parent = el.offsetParent;
	    while (parent) {
	      rect.left += parent.offsetLeft;
	      rect.top += parent.offsetTop;
	      parent = parent.offsetParent;
	    }
	
	    rect.right = rect.left + rect.width;
	    rect.bottom = rect.top + rect.height;
	  }
	  return rect;
	}
	
	function getMinScrollOffset(scrollObj) {
	  return 0 - scrollObj.options[scrollObj.axis + 'PaddingTop'];
	}
	
	function getMaxScrollOffset(scrollObj) {
	  var rect = getBoundingClientRect(scrollObj.element);
	  var pRect = getBoundingClientRect(scrollObj.viewport);
	  var min = getMinScrollOffset(scrollObj);
	  if (scrollObj.axis === 'y') {
	    var max = 0 - rect.height + pRect.height;
	  } else {
	    var max = 0 - rect.width + pRect.width;
	  }
	  return Math.min(max + scrollObj.options[scrollObj.axis + 'PaddingBottom'], min);
	}
	
	function _getBoundaryOffset(scrollObj, offset) {
	  if (offset > scrollObj.minScrollOffset) {
	    return offset - scrollObj.minScrollOffset;
	  }
	  if (offset < scrollObj.maxScrollOffset) {
	    return offset - scrollObj.maxScrollOffset;
	  }
	}
	
	function touchBoundary(scrollObj, offset) {
	  if (offset > scrollObj.minScrollOffset) {
	    offset = scrollObj.minScrollOffset;
	  } else if (offset < scrollObj.maxScrollOffset) {
	    offset = scrollObj.maxScrollOffset;
	  }
	  return offset;
	}
	
	function fireEvent(scrollObj, eventName, extra) {
	  debugLog(scrollObj.element.scrollId, eventName, extra);
	  var event = doc.createEvent('HTMLEvents');
	  event.initEvent(eventName, false, true);
	  event.scrollObj = scrollObj;
	  if (extra) {
	    for (var key in extra) {
	      event[key] = extra[key];
	    }
	  }
	  scrollObj.element.dispatchEvent(event);
	  scrollObj.viewport.dispatchEvent(event);
	}
	
	function getTransformOffset(scrollObj) {
	  var offset = { x: 0, y: 0 };
	  var transform = getComputedStyle(scrollObj.element)[stylePrefix + 'Transform'];
	  var matched;
	  var reg1 = new RegExp('^matrix3d' + '\\((?:[-\\d.]+,\\s*){12}([-\\d.]+),' + '\\s*([-\\d.]+)(?:,\\s*[-\\d.]+){2}\\)');
	  var reg2 = new RegExp('^matrix' + '\\((?:[-\\d.]+,\\s*){4}([-\\d.]+),\\s*([-\\d.]+)\\)$');
	  if (transform !== 'none') {
	    if (matched = transform.match(reg1) || transform.match(reg2)) {
	      offset.x = parseFloat(matched[1]) || 0;
	      offset.y = parseFloat(matched[2]) || 0;
	    }
	  }
	
	  return offset;
	}
	
	var CSSMatrix = IEMobile ? 'MSCSSMatrix' : 'WebKitCSSMatrix';
	var has3d = !!Firefox || CSSMatrix in window && 'm11' in new window[CSSMatrix]();
	function getTranslate(x, y) {
	  x = parseFloat(x);
	  y = parseFloat(y);
	
	  if (x != 0) {
	    x += 'px';
	  }
	
	  if (y != 0) {
	    y += 'px';
	  }
	
	  if (has3d) {
	    return 'translate3d(' + x + ', ' + y + ', 0)';
	  }
	  return 'translate(' + x + ', ' + y + ')';
	}
	
	function setTransitionStyle(scrollObj, duration, timingFunction) {
	  if (duration === '' && timingFunction === '') {
	    scrollObj.element.style[stylePrefix + 'Transition'] = '';
	  } else {
	    scrollObj.element.style[stylePrefix + 'Transition'] = cssPrefix + 'transform ' + duration + ' ' + timingFunction + ' 0s';
	  }
	}
	
	function setTransformStyle(scrollObj, offset) {
	  var x = 0;
	  var y = 0;
	  if ((typeof offset === 'undefined' ? 'undefined' : _typeof(offset)) === 'object') {
	    x = offset.x;
	    y = offset.y;
	  } else {
	    if (scrollObj.axis === 'y') {
	      y = offset;
	    } else {
	      x = offset;
	    }
	  }
	  scrollObj.element.style[stylePrefix + 'Transform'] = getTranslate(x, y);
	}
	
	var panning = false;
	doc.addEventListener('touchmove', function (e) {
	  if (panning) {
	    e.preventDefault();
	    return false;
	  }
	  return true;
	}, false);
	
	function Scroll(element, options) {
	  var that = this;
	
	  options = options || {};
	  options.noBounce = !!options.noBounce;
	  options.padding = options.padding || {};
	
	  if (options.isPrevent == null) {
	    options.isPrevent = true;
	  } else {
	    options.isPrevent = !!options.isPrevent;
	  }
	
	  if (options.isFixScrollendClick == null) {
	    options.isFixScrollendClick = true;
	  } else {
	    options.isFixScrollendClick = !!options.isFixScrollendClick;
	  }
	
	  if (options.padding) {
	    options.yPaddingTop = -options.padding.top || 0;
	    options.yPaddingBottom = -options.padding.bottom || 0;
	    options.xPaddingTop = -options.padding.left || 0;
	    options.xPaddingBottom = -options.padding.right || 0;
	  } else {
	    options.yPaddingTop = 0;
	    options.yPaddingBottom = 0;
	    options.xPaddingTop = 0;
	    options.xPaddingBottom = 0;
	  }
	
	  options.direction = options.direction || 'y';
	  options.inertia = options.inertia || 'normal';
	
	  this.options = options;
	  that.axis = options.direction;
	  this.element = element;
	  this.viewport = element.parentNode;
	  this.plugins = {};
	
	  this.element.scrollId = setTimeout(function () {
	    scrollObjs[that.element.scrollId + ''] = that;
	  }, 1);
	
	  this.viewport.addEventListener('touchstart', touchstartHandler, false);
	  this.viewport.addEventListener('touchend', touchendHandler, false);
	  this.viewport.addEventListener('touchcancel', touchendHandler, false);
	  this.viewport.addEventListener('panstart', panstartHandler, false);
	  this.viewport.addEventListener('panmove', panHandler, false);
	  this.viewport.addEventListener('panend', panendHandler, false);
	
	  if (options.isPrevent) {
	    this.viewport.addEventListener('touchstart', function (e) {
	      panning = true;
	    }, false);
	    that.viewport.addEventListener('touchend', function (e) {
	      panning = false;
	    }, false);
	  }
	
	  // if (options.isPrevent) {
	  //   var d = this.axis === 'y'?'vertical':'horizontal'
	  //   this.viewport.addEventListener(d + 'panstart', function (e) {
	  //     panning = true
	  //   }, false)
	  //   that.viewport.addEventListener('panend', function (e) {
	  //     panning = false
	  //   }, false)
	  // }
	
	  if (options.isFixScrollendClick) {
	    var preventScrollendClickHandler = function preventScrollendClickHandler(e) {
	      if (preventScrollendClick || isScrolling) {
	        e.preventDefault();
	        e.stopPropagation();
	        return false;
	      }
	      return true;
	    };
	
	    var fireNiceTapEventHandler = function fireNiceTapEventHandler(e) {
	      if (!preventScrollendClick && !isScrolling) {
	        setTimeout(function () {
	          var niceTapEvent = document.createEvent('HTMLEvents');
	          niceTapEvent.initEvent('niceclick', true, true);
	          e.target.dispatchEvent(niceTapEvent);
	        }, 300);
	      }
	    };
	
	    var preventScrollendClick;
	    var fixScrollendClickTimeoutId;
	
	    this.viewport.addEventListener('scrolling', function () {
	      preventScrollendClick = true;
	      fixScrollendClickTimeoutId && clearTimeout(fixScrollendClickTimeoutId);
	      fixScrollendClickTimeoutId = setTimeout(function (e) {
	        preventScrollendClick = false;
	      }, 400);
	    }, false);
	
	    this.viewport.addEventListener('click', preventScrollendClickHandler);
	    this.viewport.addEventListener('tap', fireNiceTapEventHandler);
	  }
	
	  function setTransitionEndHandler(h, t) {
	    if (options.useFrameAnimation) {
	      return;
	    }
	    transitionEndHandler = null;
	    clearTimeout(transitionEndTimeoutId);
	
	    transitionEndTimeoutId = setTimeout(function () {
	      if (transitionEndHandler) {
	        transitionEndHandler = null;
	        lib.animation.requestFrame(h);
	      }
	    }, t || 400);
	
	    transitionEndHandler = h;
	  }
	
	  if (options.useFrameAnimation) {
	    var scrollAnimation;
	
	    Object.defineProperty(this, 'animation', {
	      get: function get() {
	        return scrollAnimation;
	      }
	    });
	  } else {
	    var transitionEndHandler;
	    var transitionEndTimeoutId = 0;
	
	    element.addEventListener(Firefox ? 'transitionend' : stylePrefix + 'TransitionEnd', function (e) {
	      if (transitionEndHandler) {
	        var handler = transitionEndHandler;
	
	        transitionEndHandler = null;
	        clearTimeout(transitionEndTimeoutId);
	
	        lib.animation.requestFrame(function () {
	          handler(e);
	        });
	      }
	    }, false);
	  }
	
	  var panFixRatio;
	  var isScrolling;
	  var isFlickScrolling;
	  var cancelScrollEnd;
	
	  Object.defineProperty(this, 'isScrolling', {
	    get: function get() {
	      return !!isScrolling;
	    }
	  });
	
	  function isEnabled(e) {
	    if (!that.enabled) {
	      return false;
	    }
	
	    if (typeof e.isVertical != 'undefined') {
	      if (that.axis === 'y' && e.isVertical || that.axis === 'x' && !e.isVertical) {
	        // gesture in same direction, stop bubbling up
	        e.stopPropagation();
	      } else {
	        // gesture in different direction, bubbling up
	        // to the top, without any other process
	        return false;
	      }
	    }
	
	    return true;
	  }
	
	  function touchstartHandler(e) {
	    if (!isEnabled(e)) {
	      return;
	    }
	
	    if (isScrolling) {
	      scrollEnd();
	    }
	
	    if (options.useFrameAnimation) {
	      scrollAnimation && scrollAnimation.stop();
	      scrollAnimation = null;
	    } else {
	      var transform = getTransformOffset(that);
	      setTransformStyle(that, transform);
	      setTransitionStyle(that, '', '');
	      transitionEndHandler = null;
	      clearTimeout(transitionEndTimeoutId);
	    }
	  }
	
	  function touchendHandler(e) {
	    if (!isEnabled(e)) {
	      return;
	    }
	
	    var s0 = getTransformOffset(that)[that.axis];
	    var boundaryOffset = _getBoundaryOffset(that, s0);
	
	    if (boundaryOffset) {
	      // dragging out of boundray, bounce is needed
	      var s1 = touchBoundary(that, s0);
	
	      if (options.useFrameAnimation) {
	        // frame
	        var _s = s1 - s0;
	        scrollAnimation = new lib.animation(400, lib.cubicbezier.ease, 0, function (i1, i2) {
	          var offset = (s0 + _s * i2).toFixed(2);
	          setTransformStyle(that, offset);
	          fireEvent(that, 'scrolling');
	        });
	        scrollAnimation.onend(scrollEnd);
	        scrollAnimation.play();
	      } else {
	        // css
	        var offset = s1.toFixed(0);
	        setTransitionEndHandler(scrollEnd, 400);
	        setTransitionStyle(that, '0.4s', 'ease');
	        setTransformStyle(that, offset);
	
	        lib.animation.requestFrame(function doScroll() {
	          if (isScrolling && that.enabled) {
	            fireEvent(that, 'scrolling');
	            lib.animation.requestFrame(doScroll);
	          }
	        });
	      }
	
	      if (boundaryOffset > 0) {
	        fireEvent(that, that.axis === 'y' ? 'pulldownend' : 'pullrightend');
	      } else if (boundaryOffset < 0) {
	        fireEvent(that, that.axis === 'y' ? 'pullupend' : 'pullleftend');
	      }
	    } else if (isScrolling) {
	      // without exceeding the boundary, just end it
	      scrollEnd();
	    }
	  }
	
	  var lastDisplacement;
	  function panstartHandler(e) {
	    if (!isEnabled(e)) {
	      return;
	    }
	
	    that.transformOffset = getTransformOffset(that);
	    that.minScrollOffset = getMinScrollOffset(that);
	    that.maxScrollOffset = getMaxScrollOffset(that);
	    panFixRatio = 2.5;
	    cancelScrollEnd = true;
	    isScrolling = true;
	    isFlickScrolling = false;
	    fireEvent(that, 'scrollstart');
	
	    lastDisplacement = e['displacement' + that.axis.toUpperCase()];
	  }
	
	  function panHandler(e) {
	    if (!isEnabled(e)) {
	      return;
	    }
	
	    // finger move less than 5 px. just ignore that.
	    var displacement = e['displacement' + that.axis.toUpperCase()];
	    if (Math.abs(displacement - lastDisplacement) < 5) {
	      e.stopPropagation();
	      return;
	    }
	    lastDisplacement = displacement;
	
	    var offset = that.transformOffset[that.axis] + displacement;
	    if (offset > that.minScrollOffset) {
	      offset = that.minScrollOffset + (offset - that.minScrollOffset) / panFixRatio;
	      panFixRatio *= 1.003;
	    } else if (offset < that.maxScrollOffset) {
	      offset = that.maxScrollOffset - (that.maxScrollOffset - offset) / panFixRatio;
	      panFixRatio *= 1.003;
	    }
	    if (panFixRatio > 4) {
	      panFixRatio = 4;
	    }
	
	    // tell whether or not reach the fringe
	    var boundaryOffset = _getBoundaryOffset(that, offset);
	    if (boundaryOffset) {
	      fireEvent(that, boundaryOffset > 0 ? that.axis === 'y' ? 'pulldown' : 'pullright' : that.axis === 'y' ? 'pullup' : 'pullleft', {
	        boundaryOffset: Math.abs(boundaryOffset)
	      });
	      if (that.options.noBounce) {
	        offset = touchBoundary(that, offset);
	      }
	    }
	
	    setTransformStyle(that, offset.toFixed(2));
	    fireEvent(that, 'scrolling');
	  }
	
	  function panendHandler(e) {
	    if (!isEnabled(e)) {
	      return;
	    }
	
	    if (e.isSwipe) {
	      flickHandler(e);
	    }
	  }
	
	  function flickHandler(e) {
	    cancelScrollEnd = true;
	
	    var v0, a0, t0, s0, s, motion0;
	    var v1, a1, t1, s1, motion1, sign;
	    var v2, a2, t2, s2, motion2, ft;
	
	    s0 = getTransformOffset(that)[that.axis];
	    var boundaryOffset0 = _getBoundaryOffset(that, s0);
	    if (!boundaryOffset0) {
	      // when fingers left the range of screen, let touch end handler
	      // to deal with it.
	      // when fingers left the screen, but still in the range of
	      // screen, calculate the intertia.
	      v0 = e['velocity' + that.axis.toUpperCase()];
	
	      var maxV = 2;
	      var friction = 0.0015;
	      if (options.inertia && inertiaCoefficient[options.inertia]) {
	        maxV = inertiaCoefficient[options.inertia][0];
	        friction = inertiaCoefficient[options.inertia][1];
	      }
	
	      if (v0 > maxV) {
	        v0 = maxV;
	      }
	      if (v0 < -maxV) {
	        v0 = -maxV;
	      }
	      a0 = friction * (v0 / Math.abs(v0));
	      motion0 = new lib.motion({
	        v: v0,
	        a: -a0
	      });
	      t0 = motion0.t;
	      s = s0 + motion0.s;
	
	      var boundaryOffset1 = _getBoundaryOffset(that, s);
	      if (boundaryOffset1) {
	        debugLog('inertial calculation has exceeded the boundary', boundaryOffset1);
	
	        v1 = v0;
	        a1 = a0;
	        if (boundaryOffset1 > 0) {
	          s1 = that.minScrollOffset;
	          sign = 1;
	        } else {
	          s1 = that.maxScrollOffset;
	          sign = -1;
	        }
	        motion1 = new lib.motion({
	          v: sign * v1,
	          a: -sign * a1,
	          s: Math.abs(s1 - s0)
	        });
	        t1 = motion1.t;
	        var timeFunction1 = motion1.generateCubicBezier();
	
	        v2 = v1 - a1 * t1;
	        a2 = 0.03 * (v2 / Math.abs(v2));
	        motion2 = new lib.motion({
	          v: v2,
	          a: -a2
	        });
	        t2 = motion2.t;
	        s2 = s1 + motion2.s;
	        var timeFunction2 = motion2.generateCubicBezier();
	
	        if (options.noBounce) {
	          debugLog('no bounce effect');
	
	          if (s0 !== s1) {
	            if (options.useFrameAnimation) {
	              // frame
	              var _s = s1 - s0;
	              var bezier = lib.cubicbezier(timeFunction1[0][0], timeFunction1[0][1], timeFunction1[1][0], timeFunction1[1][1]);
	              scrollAnimation = new lib.animation(t1.toFixed(0), bezier, 0, function (i1, i2) {
	                var offset = s0 + _s * i2;
	                getTransformOffset(that, offset.toFixed(2));
	                fireEvent(that, 'scrolling', {
	                  afterFlick: true
	                });
	              });
	
	              scrollAnimation.onend(scrollEnd);
	
	              scrollAnimation.play();
	            } else {
	              // css
	              var offset = s1.toFixed(0);
	              setTransitionEndHandler(scrollEnd, (t1 / 1000).toFixed(2) * 1000);
	              setTransitionStyle(that, (t1 / 1000).toFixed(2) + 's', 'cubic-bezier(' + timeFunction1 + ')');
	              setTransformStyle(that, offset);
	            }
	          } else {
	            scrollEnd();
	          }
	        } else if (s0 !== s2) {
	          debugLog('scroll for inertia', 's=' + s2.toFixed(0), 't=' + ((t1 + t2) / 1000).toFixed(2));
	
	          if (options.useFrameAnimation) {
	            var _s = s2 - s0;
	            var bezier = lib.cubicbezier.easeOut;
	            scrollAnimation = new lib.animation((t1 + t2).toFixed(0), bezier, 0, function (i1, i2) {
	              var offset = s0 + _s * i2;
	              setTransformStyle(that, offset.toFixed(2));
	              fireEvent(that, 'scrolling', {
	                afterFlick: true
	              });
	            });
	
	            scrollAnimation.onend(function () {
	              if (!that.enabled) {
	                return;
	              }
	
	              var _s = s1 - s2;
	              var bezier = lib.cubicbezier.ease;
	              scrollAnimation = new lib.animation(400, bezier, 0, function (i1, i2) {
	                var offset = s2 + _s * i2;
	                setTransformStyle(that, offset.toFixed(2));
	                fireEvent(that, 'scrolling', {
	                  afterFlick: true
	                });
	              });
	
	              scrollAnimation.onend(scrollEnd);
	
	              scrollAnimation.play();
	            });
	
	            scrollAnimation.play();
	          } else {
	            var offset = s2.toFixed(0);
	            setTransitionEndHandler(function (e) {
	              if (!that.enabled) {
	                return;
	              }
	
	              debugLog('inertial bounce', 's=' + s1.toFixed(0), 't=400');
	
	              if (s2 !== s1) {
	                var offset = s1.toFixed(0);
	                setTransitionStyle(that, '0.4s', 'ease');
	                setTransformStyle(that, offset);
	                setTransitionEndHandler(scrollEnd, 400);
	              } else {
	                scrollEnd();
	              }
	            }, ((t1 + t2) / 1000).toFixed(2) * 1000);
	
	            setTransitionStyle(that, ((t1 + t2) / 1000).toFixed(2) + 's', 'ease-out');
	            setTransformStyle(that, offset);
	          }
	        } else {
	          scrollEnd();
	        }
	      } else {
	        debugLog('inertial calculation hasn\'t exceeded the boundary');
	        var timeFunction = motion0.generateCubicBezier();
	
	        if (options.useFrameAnimation) {
	          // frame
	          var _s = s - s0;
	          var bezier = lib.cubicbezier(timeFunction[0][0], timeFunction[0][1], timeFunction[1][0], timeFunction[1][1]);
	          scrollAnimation = new lib.animation(t0.toFixed(0), bezier, 0, function (i1, i2) {
	            var offset = (s0 + _s * i2).toFixed(2);
	            setTransformStyle(that, offset);
	            fireEvent(that, 'scrolling', {
	              afterFlick: true
	            });
	          });
	
	          scrollAnimation.onend(scrollEnd);
	
	          scrollAnimation.play();
	        } else {
	          // css
	          var offset = s.toFixed(0);
	          setTransitionEndHandler(scrollEnd, (t0 / 1000).toFixed(2) * 1000);
	          setTransitionStyle(that, (t0 / 1000).toFixed(2) + 's', 'cubic-bezier(' + timeFunction + ')');
	          setTransformStyle(that, offset);
	        }
	      }
	
	      isFlickScrolling = true;
	      if (!options.useFrameAnimation) {
	        lib.animation.requestFrame(function doScroll() {
	          if (isScrolling && isFlickScrolling && that.enabled) {
	            fireEvent(that, 'scrolling', {
	              afterFlick: true
	            });
	            lib.animation.requestFrame(doScroll);
	          }
	        });
	      }
	    }
	  }
	
	  function scrollEnd() {
	    if (!that.enabled) {
	      return;
	    }
	
	    cancelScrollEnd = false;
	
	    setTimeout(function () {
	      if (!cancelScrollEnd && isScrolling) {
	        isScrolling = false;
	        isFlickScrolling = false;
	
	        if (options.useFrameAnimation) {
	          scrollAnimation && scrollAnimation.stop();
	          scrollAnimation = null;
	        } else {
	          setTransitionStyle(that, '', '');
	        }
	        fireEvent(that, 'scrollend');
	      }
	    }, 50);
	  }
	
	  var proto = {
	    init: function init() {
	      this.enable();
	      this.refresh();
	      this.scrollTo(0);
	      return this;
	    },
	
	    enable: function enable() {
	      this.enabled = true;
	      return this;
	    },
	
	    disable: function disable() {
	      var el = this.element;
	      this.enabled = false;
	
	      if (this.options.useFrameAnimation) {
	        scrollAnimation && scrollAnimation.stop();
	      } else {
	        lib.animation.requestFrame(function () {
	          el.style[stylePrefix + 'Transform'] = getComputedStyle(el)[stylePrefix + 'Transform'];
	        });
	      }
	
	      return this;
	    },
	
	    getScrollWidth: function getScrollWidth() {
	      return getBoundingClientRect(this.element).width;
	    },
	
	    getScrollHeight: function getScrollHeight() {
	      return getBoundingClientRect(this.element).height;
	    },
	
	    getScrollLeft: function getScrollLeft() {
	      return -getTransformOffset(this).x - this.options.xPaddingTop;
	    },
	
	    getScrollTop: function getScrollTop() {
	      return -getTransformOffset(this).y - this.options.yPaddingTop;
	    },
	
	    getMaxScrollLeft: function getMaxScrollLeft() {
	      return -that.maxScrollOffset - this.options.xPaddingTop;
	    },
	
	    getMaxScrollTop: function getMaxScrollTop() {
	      return -that.maxScrollOffset - this.options.yPaddingTop;
	    },
	
	    getBoundaryOffset: function getBoundaryOffset() {
	      return Math.abs(_getBoundaryOffset(this, getTransformOffset(this)[this.axis]) || 0);
	    },
	
	    refresh: function refresh() {
	      var el = this.element;
	      var isVertical = this.axis === 'y';
	      var type = isVertical ? 'height' : 'width';
	      var size, rect, extraSize;
	
	      function getExtraSize(el, isVertical) {
	        var extraType = isVertical ? ['top', 'bottom'] : ['left', 'right'];
	        return parseFloat(getComputedStyle(el.firstElementChild)['margin-' + extraType[0]]) + parseFloat(getComputedStyle(el.lastElementChild)['margin-' + extraType[1]]);
	      }
	
	      if (this.options[type] != null) {
	        // use options
	        size = this.options[type];
	      } else if (el.childElementCount <= 0) {
	        el.style[type] = 'auto';
	        size = null;
	      } else if (!!this.options.useElementRect) {
	        el.style[type] = 'auto';
	        rect = getBoundingClientRect(el);
	        size = rect[type];
	        size += getExtraSize(el, isVertical);
	      } else {
	        var range, rect;
	        var firstEl = el.firstElementChild;
	        var lastEl = el.lastElementChild;
	
	        if (document.createRange && !this.options.ignoreOverflow) {
	          // use range
	          range = document.createRange();
	          range.selectNodeContents(el);
	          rect = getBoundingClientRect(range);
	        }
	
	        if (rect) {
	          size = rect[type];
	        } else {
	          // use child offsets
	          while (firstEl) {
	            if (getBoundingClientRect(firstEl)[type] === 0 && firstEl.nextElementSibling) {
	              firstEl = firstEl.nextElementSibling;
	            } else {
	              break;
	            }
	          }
	
	          while (lastEl && lastEl !== firstEl) {
	            if (getBoundingClientRect(lastEl)[type] === 0 && lastEl.previousElementSibling) {
	              lastEl = lastEl.previousElementSibling;
	            } else {
	              break;
	            }
	          }
	
	          size = getBoundingClientRect(lastEl)[isVertical ? 'bottom' : 'right'] - getBoundingClientRect(firstEl)[isVertical ? 'top' : 'left'];
	        }
	
	        size += getExtraSize(el, isVertical);
	      }
	
	      el.style[type] = size ? size + 'px' : 'auto';
	
	      this.transformOffset = getTransformOffset(this);
	      this.minScrollOffset = getMinScrollOffset(this);
	      this.maxScrollOffset = getMaxScrollOffset(this);
	
	      this.scrollTo(-this.transformOffset[this.axis] - this.options[this.axis + 'PaddingTop']);
	      fireEvent(this, 'contentrefresh');
	
	      return this;
	    },
	
	    offset: function offset(childEl) {
	      var elRect = getBoundingClientRect(this.element);
	      var childRect = getBoundingClientRect(childEl);
	      if (this.axis === 'y') {
	        var offsetRect = {
	          top: childRect.top - elRect.top - this.options.yPaddingTop,
	          left: childRect.left - elRect.left,
	          right: elRect.right - childRect.right,
	          width: childRect.width,
	          height: childRect.height
	        };
	
	        offsetRect.bottom = offsetRect.top + offsetRect.height;
	      } else {
	        var offsetRect = {
	          top: childRect.top - elRect.top,
	          bottom: elRect.bottom - childRect.bottom,
	          left: childRect.left - elRect.left - this.options.xPaddingTop,
	          width: childRect.width,
	          height: childRect.height
	        };
	
	        offsetRect.right = offsetRect.left + offsetRect.width;
	      }
	      return offsetRect;
	    },
	
	    getRect: function getRect(childEl) {
	      var viewRect = getBoundingClientRect(this.viewport);
	      var childRect = getBoundingClientRect(childEl);
	      if (this.axis === 'y') {
	        var offsetRect = {
	          top: childRect.top - viewRect.top,
	          left: childRect.left - viewRect.left,
	          right: viewRect.right - childRect.right,
	          width: childRect.width,
	          height: childRect.height
	        };
	
	        offsetRect.bottom = offsetRect.top + offsetRect.height;
	      } else {
	        var offsetRect = {
	          top: childRect.top - viewRect.top,
	          bottom: viewRect.bottom - childRect.bottom,
	          left: childRect.left - viewRect.left,
	          width: childRect.width,
	          height: childRect.height
	        };
	
	        offsetRect.right = offsetRect.left + offsetRect.width;
	      }
	      return offsetRect;
	    },
	
	    isInView: function isInView(childEl) {
	      var viewRect = this.getRect(this.viewport);
	      var childRect = this.getRect(childEl);
	      if (this.axis === 'y') {
	        return viewRect.top < childRect.bottom && viewRect.bottom > childRect.top;
	      }
	      return viewRect.left < childRect.right && viewRect.right > childRect.left;
	    },
	
	    scrollTo: function scrollTo(offset, isSmooth) {
	      var that = this;
	      var element = this.element;
	
	      offset = -offset - this.options[this.axis + 'PaddingTop'];
	      offset = touchBoundary(this, offset);
	
	      isScrolling = true;
	      if (isSmooth === true) {
	        if (this.options.useFrameAnimation) {
	          var s0 = getTransformOffset(that)[this.axis];
	          var _s = offset - s0;
	          scrollAnimation = new lib.animation(400, lib.cubicbezier.easeInOut, 0, function (i1, i2) {
	            var offset = (s0 + _s * i2).toFixed(2);
	            setTransformStyle(that, offset);
	            fireEvent(that, 'scrolling');
	          });
	
	          scrollAnimation.onend(scrollEnd);
	
	          scrollAnimation.play();
	        } else {
	          (function () {
	            var _cancelScroll = function _cancelScroll() {
	              if (isScrolling && that.enabled) {
	                fireEvent(that, 'scrolling');
	                lib.animation.requestFrame(_cancelScroll);
	              }
	            };
	
	            setTransitionEndHandler(scrollEnd, 400);
	            setTransitionStyle(that, '0.4s', 'ease-in-out');
	            setTransformStyle(that, offset);
	
	            lib.animation.requestFrame(_cancelScroll);
	          })();
	        }
	      } else {
	        if (!this.options.useFrameAnimation) {
	          setTransitionStyle(that, '', '');
	        }
	        setTransformStyle(that, offset);
	        scrollEnd();
	      }
	
	      return this;
	    },
	
	    scrollToElement: function scrollToElement(childEl, isSmooth, topOffset) {
	      var offset = this.offset(childEl);
	      offset = offset[this.axis === 'y' ? 'top' : 'left'];
	      topOffset && (offset += topOffset);
	      return this.scrollTo(offset, isSmooth);
	    },
	
	    getViewWidth: function getViewWidth() {
	      return getBoundingClientRect(this.viewport).width;
	    },
	
	    getViewHeight: function getViewHeight() {
	      return getBoundingClientRect(this.viewport).height;
	    },
	
	    addPulldownHandler: function addPulldownHandler(handler) {
	      var that = this;
	      this.element.addEventListener('pulldownend', function (e) {
	        that.disable();
	        handler.call(that, e, function () {
	          that.scrollTo(0, true);
	          that.refresh();
	          that.enable();
	        });
	      }, false);
	
	      return this;
	    },
	
	    addPullupHandler: function addPullupHandler(handler) {
	      var that = this;
	
	      this.element.addEventListener('pullupend', function (e) {
	        that.disable();
	        handler.call(that, e, function () {
	          that.scrollTo(that.getScrollHeight(), true);
	          that.refresh();
	          that.enable();
	        });
	      }, false);
	
	      return this;
	    },
	
	    addScrollstartHandler: function addScrollstartHandler(handler) {
	      var that = this;
	      this.element.addEventListener('scrollstart', function (e) {
	        handler.call(that, e);
	      }, false);
	
	      return this;
	    },
	
	    addScrollingHandler: function addScrollingHandler(handler) {
	      var that = this;
	      this.element.addEventListener('scrolling', function (e) {
	        handler.call(that, e);
	      }, false);
	
	      return this;
	    },
	
	    addScrollendHandler: function addScrollendHandler(handler) {
	      var that = this;
	      this.element.addEventListener('scrollend', function (e) {
	        handler.call(that, e);
	      }, false);
	
	      return this;
	    },
	
	    addContentrenfreshHandler: function addContentrenfreshHandler(handler) {
	      var that = this;
	      this.element.addEventListener('contentrefresh', function (e) {
	        handler.call(that, e);
	      }, false);
	    },
	
	    addEventListener: function addEventListener(name, handler, useCapture) {
	      var that = this;
	      this.element.addEventListener(name, function (e) {
	        handler.call(that, e);
	      }, !!useCapture);
	    },
	
	    removeEventListener: function removeEventListener(name, handler) {
	      var that = this;
	      this.element.removeEventListener(name, function (e) {
	        handler.call(that, e);
	      });
	    },
	
	    enablePlugin: function enablePlugin(name, options) {
	      var plugin = plugins[name];
	      if (plugin && !this.plugins[name]) {
	        this.plugins[name] = true;
	        options = options || {};
	        plugin.call(this, name, options);
	      }
	      return this;
	    }
	  };
	
	  for (var k in proto) {
	    this[k] = proto[k];
	  }
	  // delete proto
	}
	
	lib.scroll = function (el, options) {
	  if (arguments.length === 1 && !(arguments[0] instanceof HTMLElement)) {
	    options = arguments[0];
	    if (options.scrollElement) {
	      el = options.scrollElement;
	    } else if (options.scrollWrap) {
	      el = options.scrollWrap.firstElementChild;
	    } else {
	      throw new Error('no scroll element');
	    }
	  }
	
	  if (!el.parentNode) {
	    throw new Error('wrong dom tree');
	  }
	  if (options && options.direction && ['x', 'y'].indexOf(options.direction) < 0) {
	    throw new Error('wrong direction');
	  }
	
	  var scroll;
	  if (options.downgrade === true && lib.scroll.downgrade) {
	    scroll = lib.scroll.downgrade(el, options);
	  } else {
	    if (el.scrollId) {
	      scroll = scrollObjs[el.scrollId];
	    } else {
	      scroll = new Scroll(el, options);
	    }
	  }
	  return scroll;
	};
	
	lib.scroll.plugin = function (name, constructor) {
	  if (constructor) {
	    name = name.split(',');
	    name.forEach(function (n) {
	      plugins[n] = constructor;
	    });
	  } else {
	    return plugins[name];
	  }
	};

/***/ },
/* 152 */
/***/ function(module, exports) {

	/* global lib: true */
	
	'use strict';
	
	/**
	 * transfer Quadratic Bezier Curve to Cubic Bezier Curve
	 *
	 * @param  {number} a abscissa of p1
	 * @param  {number} b ordinate of p1
	 * @return {Array} parameter matrix for cubic bezier curve
	 *   like [[p1x, p1y], [p2x, p2y]]
	 */
	
	function quadratic2cubicBezier(a, b) {
	  return [[(a / 3 + (a + b) / 3 - a) / (b - a), (a * a / 3 + a * b * 2 / 3 - a * a) / (b * b - a * a)], [(b / 3 + (a + b) / 3 - a) / (b - a), (b * b / 3 + a * b * 2 / 3 - a * a) / (b * b - a * a)]];
	}
	
	/**
	 * derive position data from knowing motion parameters
	 * base on Newton's second law: s = vt + at^2/2
	 *
	 * @param {object} config object of { v, a, s, t }
	 *   - v: initial velocity
	 *   - a: accelerate speed
	 *   - t: time
	 *   - s: shifting
	 */
	function Motion(config) {
	  this.v = config.v || 0;
	  this.a = config.a || 0;
	
	  if (typeof config.t !== 'undefined') {
	    this.t = config.t;
	  }
	
	  if (typeof config.s !== 'undefined') {
	    this.s = config.s;
	  }
	
	  // derive time from shifting
	  if (typeof this.t === 'undefined') {
	    if (typeof this.s === 'undefined') {
	      this.t = -this.v / this.a;
	    } else {
	      var t1 = (Math.sqrt(this.v * this.v + 2 * this.a * this.s) - this.v) / this.a;
	      var t2 = (-Math.sqrt(this.v * this.v + 2 * this.a * this.s) - this.v) / this.a;
	      this.t = Math.min(t1, t2);
	    }
	  }
	
	  // derive shifting from time
	  if (typeof this.s === 'undefined') {
	    this.s = this.a * this.t * this.t / 2 + this.v * this.t;
	  }
	}
	
	/**
	 * derive cubic bezier parameters from motion parameters
	 * @return {Array} parameter matrix for cubic bezier curve
	 *   like [[p1x, p1y], [p2x, p2y]]
	 */
	Motion.prototype.generateCubicBezier = function () {
	  return quadratic2cubicBezier(this.v / this.a, this.t + this.v / this.a);
	};
	
	!lib && (lib = {});
	lib.motion = Motion;
	
	module.exports = Motion;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _list = __webpack_require__(147);
	
	var _list2 = _interopRequireDefault(_list);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function init(Weex) {
	  var List = _list2.default.init(Weex);
	
	  function Hlist(data, nodeType) {
	    data.attr.direction = 'h';
	    List.call(this, data, nodeType);
	  }
	
	  Hlist.prototype = Object.create(List.prototype);
	
	  Weex.registerComponent('hlist', Hlist);
	}
	
	exports.default = { init: init };

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _scrollable = __webpack_require__(148);
	
	var _scrollable2 = _interopRequireDefault(_scrollable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function init(Weex) {
	  var Scrollable = _scrollable2.default.init(Weex);
	  function Scroller(data, nodeType) {
	    Scrollable.call(this, data, nodeType);
	  }
	  var extend = Weex.utils.extend;
	
	  Scroller.prototype = Object.create(Scrollable.prototype);
	  extend(Scroller.prototype, {
	    create: function create() {
	      var node = Scrollable.prototype.create.call(this);
	      node.classList.add('scroller-wrap');
	      this.scrollElement.classList.add('scroller-element');
	      return node;
	    }
	  });
	
	  Weex.registerComponent('scroller', Scroller);
	}
	
	exports.default = { init: init };

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(156);
	
	var parents = ['scroller', 'list', 'vlist'];
	
	// Only if pulldown offset is larger than this value can this
	// component trigger the 'refresh' event, otherwise just recover
	// to the start point.
	var DEFAULT_CLAMP = 130;
	var DEFAULT_ALIGN_ITEMS = 'center';
	var DEFAULT_JUSTIFY_CONTENT = 'center';
	
	function adjustHeight(refresh, val) {
	  refresh.node.style.height = val + 'px';
	}
	
	// function adJustPosition (refresh, val) {
	//   refresh.node.style.top = -val + 'px'
	// }
	
	function handleRefresh(refresh, e) {
	  refresh.node.style.height = refresh.clamp + 'px';
	  refresh.dispatchEvent('refresh');
	  refresh.isRefreshing = true;
	}
	
	function show(refresh) {
	  refresh.display = true;
	  refresh.node.style.display = '-webkit-box';
	  refresh.node.style.display = '-webkit-flex';
	  refresh.node.style.display = 'flex';
	}
	
	function hide(refresh) {
	  refresh.display = false;
	  refresh.node.style.display = 'none';
	  refresh.isRefreshing = false;
	}
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('div');
	    node.classList.add('weex-container', 'weex-refresh');
	    return node;
	  },
	  onAppend: function onAppend() {
	    var parent = this.getParent();
	    var self = this;
	    if (parents.indexOf(parent.data.type) === -1) {
	      // not in a scroller or a list
	      return;
	    }
	    this.refreshPlaceholder = document.createElement('div');
	    this.refreshPlaceholder.classList.add('weex-refresh-placeholder');
	    this.refreshPlaceholder.style.display = 'none';
	    this.refreshPlaceholder.style.width = '0px';
	    this.refreshPlaceholder.style.height = '0px';
	    var scrollElement = parent.scrollElement || parent.listElement;
	    scrollElement.insertBefore(this.refreshPlaceholder, this.node);
	    parent.node.appendChild(this.node);
	    parent.scroller.addEventListener('pulldown', function (e) {
	      if (self.isRefreshing) {
	        return;
	      }
	      adjustHeight(self, Math.abs(e.scrollObj.getScrollTop()));
	      if (!self.display) {
	        show(self);
	      }
	    });
	    parent.scroller.addEventListener('pulldownend', function (e) {
	      if (self.isRefreshing) {
	        return;
	      }
	      var top = Math.abs(e.scrollObj.getScrollTop());
	      if (top > self.clamp) {
	        handleRefresh(self, e);
	      } else {
	        hide(self);
	      }
	    });
	  }
	};
	
	var attr = {
	  display: function display(val) {
	    if (val === 'show') {
	      setTimeout(function () {
	        show(this);
	      }.bind(this), 0);
	    } else if (val === 'hide') {
	      setTimeout(function () {
	        hide(this);
	      }.bind(this), 0);
	    } else {
	      console.error('[h5-render] attr \'display\' of <refresh>\': value ' + val + ' is invalid. Should be \'show\' or \'hide\'');
	    }
	  }
	};
	
	var style = {
	  height: function height(val) {
	    val = parseFloat(val);
	    if (isNaN(val) || val < 0) {
	      return console.warn('[h5-render] <refresh>\'s height (' + val + ') is invalid.');
	    }
	    this.clamp = val * this.data.scale;
	  }
	};
	
	function init(Weex) {
	  var Component = Weex.Component;
	  var extend = Weex.utils.extend;
	
	  function Refresh(data) {
	    this.isRefreshing = false;
	    this.clamp = (data.style.height || DEFAULT_CLAMP) * data.scale;
	    !data.style.alignItems && (data.style.alignItems = DEFAULT_ALIGN_ITEMS);
	    !data.style.justifyContent && (data.style.justifyContent = DEFAULT_JUSTIFY_CONTENT);
	    Component.call(this, data);
	  }
	  Refresh.prototype = Object.create(Component.prototype);
	  extend(Refresh.prototype, proto);
	  extend(Refresh.prototype, { attr: attr });
	  extend(Refresh.prototype, {
	    style: extend(Object.create(Component.prototype.style), style)
	  });
	
	  Weex.registerComponent('refresh', Refresh);
	}
	
	exports.default = { init: init };

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(157);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../../node_modules/css-loader/index.js!./refresh.css", function() {
				var newContent = require("!!./../../../../../../node_modules/css-loader/index.js!./refresh.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-refresh {\n  // -webkit-box-align: center;\n  // -webkit-align-items: center;\n  // align-items: center;\n  // -webkit-box-pack: center;\n  // -webkit-justify-content: center;\n  // justify-content: center;\n  overflow: hidden;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 0;\n  z-index: 999999;\n  background-color: #666;\n}", ""]);
	
	// exports


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(159);
	
	var parents = ['scroller', 'list', 'vlist'];
	
	var DEFAULT_CLAMP = 130;
	var DEFAULT_ALIGN_ITEMS = 'center';
	var DEFAULT_JUSTIFY_CONTENT = 'center';
	
	function adjustHeight(loading, val) {
	  loading.node.style.height = val + 'px';
	}
	
	function handleLoading(loading, e) {
	  loading.node.style.height = loading.clamp + 'px';
	  loading.dispatchEvent('loading');
	  loading.isLoading = true;
	}
	
	function show(loading) {
	  loading.display = true;
	  loading.node.style.display = '-webkit-box';
	  loading.node.style.display = '-webkit-flex';
	  loading.node.style.display = 'flex';
	}
	
	function hide(loading) {
	  loading.display = false;
	  loading.node.style.display = 'none';
	  loading.isLoading = false;
	}
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('div');
	    node.classList.add('weex-container', 'weex-loading');
	    return node;
	  },
	  onAppend: function onAppend() {
	    var parent = this.getParent();
	    var self = this;
	    var scrollWrapHeight = parent.node.getBoundingClientRect().height;
	    if (parents.indexOf(parent.data.type) === -1) {
	      // not in a scroller or a list
	      return;
	    }
	    this.loadingPlaceholder = document.createElement('div');
	    this.loadingPlaceholder.classList.add('weex-loading-placeholder');
	    this.loadingPlaceholder.style.display = 'none';
	    this.loadingPlaceholder.style.width = '0px';
	    this.loadingPlaceholder.style.height = '0px';
	    var scrollElement = parent.scrollElement || parent.listElement;
	    scrollElement.insertBefore(this.loadingPlaceholder, this.node);
	    parent.node.appendChild(this.node);
	    parent.scroller.addEventListener('pullup', function (e) {
	      if (self.isLoading) {
	        return;
	      }
	      var obj = e.scrollObj;
	      adjustHeight(self, Math.abs(obj.getScrollHeight() - obj.getScrollTop() - scrollWrapHeight));
	      if (!self.display) {
	        show(self);
	      }
	    });
	    parent.scroller.addEventListener('pullupend', function (e) {
	      if (self.isLoading) {
	        return;
	      }
	      handleLoading(self, e);
	    });
	  }
	};
	
	var attr = {
	  display: function display(val) {
	    if (val === 'show') {
	      setTimeout(function () {
	        show(this);
	      }.bind(this), 0);
	    } else if (val === 'hide') {
	      setTimeout(function () {
	        hide(this);
	      }.bind(this), 0);
	    } else {
	      console.error('[h5-render] attr \'display\' of <refresh>\': value ' + val + ' is invalid. Should be \'show\' or \'hide\'');
	    }
	  }
	};
	
	var style = {
	  height: function height(val) {
	    val = parseFloat(val);
	    if (Number.isNaN(val) || val < 0) {
	      return console.warn('[h5-render] <loading>\'s height (' + val + ') is invalid.');
	    }
	    this.clamp = val * this.data.scale;
	  }
	};
	
	function init(Weex) {
	  var Component = Weex.Component;
	  var extend = Weex.utils.extend;
	
	  function Loading(data) {
	    this.clamp = (data.style.height || DEFAULT_CLAMP) * data.scale;
	    !data.style.alignItems && (data.style.alignItems = DEFAULT_ALIGN_ITEMS);
	    !data.style.justifyContent && (data.style.justifyContent = DEFAULT_JUSTIFY_CONTENT);
	    Component.call(this, data);
	  }
	  Loading.prototype = Object.create(Component.prototype);
	  extend(Loading.prototype, proto);
	  extend(Loading.prototype, { attr: attr });
	  extend(Loading.prototype, {
	    style: extend(Object.create(Component.prototype.style), style)
	  });
	
	  Weex.registerComponent('loading', Loading);
	}
	
	exports.default = { init: init };

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(160);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../../node_modules/css-loader/index.js!./loading.css", function() {
				var newContent = require("!!./../../../../../../node_modules/css-loader/index.js!./loading.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-loading {\n  // -webkit-box-align: center;\n  // -webkit-align-items: center;\n  // align-items: center;\n  // -webkit-box-pack: center;\n  // -webkit-justify-content: center;\n  // justify-content: center;\n  overflow: hidden;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  height: 0;\n  background-color: #666;\n}", ""]);
	
	// exports


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global lib */
	
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	__webpack_require__(162);
	
	__webpack_require__(168);
	
	var DEFAULT_INTERVAL = 3000;
	
	var extend = void 0,
	    Component = void 0;
	
	function idleWhenPageDisappear(slider) {
	  function handlePageShow() {
	    slider.isPageShow = true;
	    slider.autoPlay && !slider.isDomRendering && slider.play();
	  }
	  function handlePageHide() {
	    slider.isPageShow = false;
	    slider.stop();
	  }
	  global.addEventListener('pageshow', handlePageShow);
	  global.addEventListener('pagehide', handlePageHide);
	  document.addEventListener('visibilitychange', function () {
	    if (document.visibilityState === 'visible') {
	      handlePageShow();
	    } else if (document.visibilityState === 'hidden') {
	      handlePageHide();
	    }
	  });
	}
	
	function idleWhenDomRendering(slider) {
	  global.addEventListener('renderend', function () {
	    slider.isDomRendering = false;
	    slider.autoPlay && slider.isPageShow && slider.play();
	  });
	  global.addEventListener('renderbegin', function () {
	    slider.isDomRendering = true;
	    slider.stop();
	  });
	}
	
	function updateIndicators(slider) {
	  slider.indicator && slider.indicator.setIndex(slider.currentIndex);
	}
	
	function getSliderChangeHandler(slider) {
	  if (!slider._sliderChangeHandler) {
	    slider._sliderChangeHandler = function (e) {
	      var index = this.carrousel.items.index;
	      this.currentIndex = index;
	      updateIndicators(this);
	      this.dispatchEvent('change', { index: index });
	    }.bind(slider);
	  }
	  return slider._sliderChangeHandler;
	}
	
	function doRender(slider) {
	  slider.createChildren();
	  slider.onAppend();
	}
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('div');
	    node.classList.add('slider');
	    node.style.position = 'relative';
	    node.style.overflow = 'hidden';
	    return node;
	  },
	  createChildren: function createChildren() {
	    var componentManager = this.getComponentManager();
	
	    // recreate slider container.
	    if (this.sliderContainer) {
	      this.node.removeChild(this.sliderContainer);
	    }
	    if (this.indicator) {
	      this.indicator.node.parentNode.removeChild(this.indicator.node);
	    }
	    this.children = [];
	
	    var sliderContainer = document.createElement('ul');
	    sliderContainer.style.listStyle = 'none';
	    this.node.appendChild(sliderContainer);
	    this.sliderContainer = sliderContainer;
	
	    var children = this.data.children;
	    var scale = this.data.scale;
	    var fragment = document.createDocumentFragment();
	    var indicatorData = void 0,
	        width = void 0,
	        height = void 0;
	    var childWidth = 0;
	    var childHeight = 0;
	
	    if (children && children.length) {
	      for (var i = 0; i < children.length; i++) {
	        var child = void 0;
	        children[i].scale = this.data.scale;
	        children[i].instanceId = this.data.instanceId;
	        if (children[i].type === 'indicator') {
	          indicatorData = extend(children[i], {
	            extra: {
	              amount: children.length - 1,
	              index: 0
	            }
	          });
	        } else {
	          child = componentManager.createElement(children[i], 'li');
	          this.children.push(child);
	          fragment.appendChild(child.node);
	          width = child.data.style.width || 0;
	          height = child.data.style.height || 0;
	          width > childWidth && (childWidth = width);
	          height > childHeight && (childHeight = height);
	          child.parentRef = this.data.ref;
	        }
	      }
	      // append indicator
	      if (indicatorData) {
	        indicatorData.extra.width = this.data.style.width || childWidth;
	        indicatorData.extra.height = this.data.style.height || childHeight;
	        this.indicator = componentManager.createElement(indicatorData);
	        this.indicator.parentRef = this.data.ref;
	        this.indicator.slider = this;
	        this.node.appendChild(this.indicator.node);
	      }
	
	      sliderContainer.style.height = scale * this.data.style.height + 'px';
	      sliderContainer.appendChild(fragment);
	    }
	  },
	  appendChild: function appendChild(data) {
	    var children = this.data.children || (this.data.children = []);
	    children.push(data);
	    doRender(this);
	    if (this.children.length > 0) {
	      return this.children[this.children.length - 1];
	    }
	  },
	  insertBefore: function insertBefore(child, before) {
	    var children = this.data.children;
	    var childIndex = -1;
	    for (var i = 0, l = children.length; i < l; i++) {
	      if (children[i].ref === before.data.ref) {
	        childIndex = i;
	        break;
	      }
	    }
	    children.splice(childIndex, 0, child.data);
	    doRender(this);
	    if (this.children.length > 0) {
	      return this.children[this.children.length - 1];
	    }
	  },
	  removeChild: function removeChild(child) {
	    var children = this.data.children;
	    if (children) {
	      for (var i = 0; i < children.length; i++) {
	        if (child.data.ref === children[i].ref) {
	          children.splice(i, 1);
	          break;
	        }
	      }
	    }
	    doRender(this);
	  },
	  onAppend: function onAppend() {
	    if (this.carrousel) {
	      this.carrousel.removeEventListener('change', getSliderChangeHandler(this));
	      this.carrousel.stop();
	      this.carrousel = null;
	    }
	    var Carrousel = lib.carrousel;
	    this.carrousel = new Carrousel(this.sliderContainer, {
	      autoplay: this.autoPlay,
	      useGesture: true
	    });
	
	    this.carrousel.playInterval = this.interval;
	    this.carrousel.addEventListener('change', getSliderChangeHandler(this));
	    this.currentIndex = 0;
	
	    // preload all images for slider
	    // because:
	    // 1. lib-img doesn't listen to event transitionend
	    // 2. even if we fire lazy load in slider's change event handler,
	    //    the next image still won't be preloaded utill the moment it
	    //    slides into the view, which is too late.
	    if (this.preloadImgsTimer) {
	      clearTimeout(this.preloadImgsTimer);
	    }
	    // The time just before the second slide appear and enough
	    // for all child elements to append is ok.
	    var preloadTime = 0.8;
	    this.preloadImgsTimer = setTimeout(function () {
	      var imgs = this.carrousel.element.querySelectorAll('.weex-img');
	      for (var i = 0, l = imgs.length; i < l; i++) {
	        var img = imgs[i];
	        var iLazySrc = img.getAttribute('i-lazy-src');
	        var imgSrc = img.getAttribute('img-src');
	        if (iLazySrc) {
	          img.style.backgroundImage = 'url(' + iLazySrc + ')';
	        } else if (imgSrc) {
	          img.style.backgroundImage = 'url(' + imgSrc + ')';
	        }
	        img.removeAttribute('i-lazy-src');
	        img.removeAttribute('img-src');
	      }
	    }.bind(this), preloadTime * 1000);
	
	    // avoid page scroll when panning
	    var panning = false;
	    this.carrousel.element.addEventListener('panstart', function (e) {
	      if (!e.isVertical) {
	        panning = true;
	      }
	    });
	    this.carrousel.element.addEventListener('panend', function (e) {
	      if (!e.isVertical) {
	        panning = false;
	      }
	    });
	
	    document.addEventListener('touchmove', function (e) {
	      if (panning) {
	        e.preventDefault();
	        return false;
	      }
	      return true;
	    });
	
	    Component.prototype.onAppend.call(this);
	  },
	  play: function play() {
	    this.carrousel.play();
	  },
	  stop: function stop() {
	    this.carrousel.stop();
	  },
	  slideTo: function slideTo(index) {
	    var offset = index - this.currentIndex;
	    this.carrousel.items.slide(offset);
	  }
	};
	
	var attr = {
	  interval: function interval(val) {
	    this.interval = parseInt(val) || DEFAULT_INTERVAL;
	    if (this.carrousel) {
	      this.carrousel.playInterval = this.interval;
	    }
	  },
	
	  index: function index(val) {
	    var _this = this;
	    function doSlide(index) {
	      index = parseInt(index);
	      if (index < 0 || isNaN(index)) {
	        return console.error('[h5-render] invalid index ', index);
	      }
	      _this.slideTo(index);
	      if (_this._updateIndex) {
	        window.removeEventListener('renderend', _this._updateIndex);
	      }
	    }
	    if (this.isDomRendering) {
	      var pre = !!this._updateIndex;
	      this._updateIndex = function () {
	        _this.autoPlay && _this.isPageShow && _this.play();
	        doSlide(val);
	      };
	      !pre && window.addEventListener('renderend', this._updateIndex);
	    } else {
	      doSlide(val);
	    }
	  },
	
	  playstatus: function playstatus(val) {
	    this.playstatus = val && val !== 'false';
	    this.autoPlay = this.playstatus;
	    if (this.carrousel) {
	      if (this.playstatus) {
	        this.play();
	      } else {
	        this.stop();
	      }
	    }
	  },
	
	  // support playstatus' alias auto-play for compatibility
	  autoPlay: function autoPlay(val) {
	    this.attr.playstatus.call(this, val);
	  }
	};
	
	var event = {
	  change: {
	    updator: function updator() {
	      return {
	        attrs: {
	          index: this.currentIndex
	        }
	      };
	    }
	  }
	};
	
	function init(Weex) {
	  Component = Weex.Component;
	  extend = Weex.utils.extend;
	
	  function Slider(data) {
	    this.autoPlay = false; // default value is false.
	    this.interval = DEFAULT_INTERVAL;
	    this.direction = 'row'; // 'column' is not temporarily supported.
	    this.children = [];
	    this.isPageShow = true;
	    this.isDomRendering = true;
	
	    // bind event 'pageshow', 'pagehide' and 'visibilitychange' on window.
	    idleWhenPageDisappear(this);
	    // bind event 'renderBegin' and 'renderEnd' on window.
	    idleWhenDomRendering(this);
	
	    Component.call(this, data);
	  }
	  Slider.prototype = Object.create(Component.prototype);
	  extend(Slider.prototype, proto);
	  extend(Slider.prototype, { attr: attr });
	  extend(Slider.prototype, { event: event });
	
	  Weex.registerComponent('slider', Slider);
	}
	
	exports.default = { init: init };
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-disable */
	
	'use strict';
	
	// require('./gesture')
	
	__webpack_require__(163);
	__webpack_require__(164);
	__webpack_require__(165);
	
	var doc = window.document;
	var ua = window.navigator.userAgent;
	var Firefox = !!ua.match(/Firefox/i);
	var IEMobile = !!ua.match(/IEMobile/i);
	var cssPrefix = Firefox ? '-moz-' : IEMobile ? '-ms-' : '-webkit-';
	var stylePrefix = Firefox ? 'Moz' : IEMobile ? 'ms' : 'webkit';
	
	var timer = __webpack_require__(167);
	var setTimeout = timer.setTimeout;
	var clearTimeout = timer.clearTimeout;
	
	function getTransformOffset(element) {
	  var offset = { x: 0, y: 0 };
	  var transform = getComputedStyle(element)[stylePrefix + 'Transform'];
	  var regMatrix3d = new RegExp('^matrix3d\\((?:[-\\d.]+,\\s*){12}([-\\d.]+),' + '\\s*([-\\d.]+)(?:,\\s*[-\\d.]+){2}\\)');
	  var regMatrix = /^matrix\((?:[-\d.]+,\s*){4}([-\d.]+),\s*([-\d.]+)\)$/;
	  var matched;
	
	  if (transform !== 'none') {
	    if (matched = transform.match(regMatrix3d) || transform.match(regMatrix)) {
	      offset.x = parseFloat(matched[1]) || 0;
	      offset.y = parseFloat(matched[2]) || 0;
	    }
	  }
	
	  return offset;
	}
	
	var CSSMatrix = IEMobile ? 'MSCSSMatrix' : 'WebKitCSSMatrix';
	var has3d = !!Firefox || CSSMatrix in window && 'm11' in new window[CSSMatrix]();
	function getTranslate(x, y) {
	  x = parseFloat(x);
	  y = parseFloat(y);
	
	  if (x != 0) {
	    x += 'px';
	  }
	
	  if (y != 0) {
	    y += 'px';
	  }
	
	  if (has3d) {
	    return 'translate3d(' + x + ', ' + y + ', 0)';
	  }
	
	  return 'translate(' + x + ', ' + y + ')';
	}
	
	var slice = Array.prototype.slice;
	function ArrayFrom(a) {
	  return slice.call(a);
	}
	
	var incId = 0;
	function Carrousel(element, options) {
	  var that = this;
	  var views = [];
	  var pages = {};
	  var id = Date.now() + '-' + ++incId;
	  var root = document.createDocumentFragment();
	
	  if (arguments.length === 1 && !(arguments[0] instanceof HTMLElement)) {
	    options = arguments[0];
	    element = null;
	  }
	
	  if (!element) {
	    element = document.createElement('ul');
	    root.appendChild(element);
	  }
	  options = options || {};
	
	  element.setAttribute('data-ctrl-name', 'carrousel');
	  element.setAttribute('data-ctrl-id', id);
	
	  function fireEvent(name, extra) {
	    var ev = doc.createEvent('HTMLEvents');
	    ev.initEvent(name, false, false);
	    if (extra) {
	      for (var key in extra) {
	        ev[key] = extra[key];
	      }
	    }
	    root.dispatchEvent(ev);
	  }
	
	  element.style.position = 'relative';
	  element.style[stylePrefix + 'Transform'] = getTranslate(0, 0);
	
	  var transformOffset = 0;
	  var items = {};
	  var itemLength = 0;
	  var itemStep = options.step || element.getBoundingClientRect().width;
	  var itemIndex = 0;
	
	  items.add = function (html) {
	    var li = document.createElement('li');
	    li.style.display = 'none';
	    li.style.float = 'left';
	    li.index = itemLength;
	    if (typeof html === 'string') {
	      li.innerHTML = html;
	    } else if (html instanceof HTMLElement) {
	      li.appendChild(html);
	    }
	    element.appendChild(li);
	
	    Object.defineProperty(items, itemLength + '', {
	      get: function get() {
	        return li;
	      }
	    });
	
	    itemLength++;
	    return li;
	  };
	
	  function normalizeIndex(index) {
	    while (index < 0) {
	      index += itemLength;
	    }
	
	    while (index >= itemLength) {
	      index -= itemLength;
	    }
	
	    return index;
	  }
	
	  items.get = function (index) {
	    return items[normalizeIndex(index)];
	  };
	
	  items.getCloned = function (index) {
	    var index = normalizeIndex(index);
	    var item = element.querySelector('[cloned="cloned-' + index + '"]');
	    var originalItem = items[index];
	
	    // If there a _listeners attribute on the dom element
	    // then clone the _listeners as well for the events' binding
	    function cloneEvents(origin, clone, deep) {
	      var listeners = origin._listeners;
	      if (listeners) {
	        clone._listeners = listeners;
	        for (var type in listeners) {
	          clone.addEventListener(type, listeners[type]);
	        }
	      }
	      if (deep && origin.children && origin.children.length) {
	        for (var i = 0, l = origin.children.length; i < l; i++) {
	          cloneEvents(origin.children[i], clone.children[i], deep);
	        }
	      }
	    }
	
	    if (!item) {
	      item = originalItem.cloneNode(true);
	      cloneEvents(originalItem, item, true);
	
	      element.appendChild(item);
	      item.setAttribute('cloned', 'cloned-' + index);
	      item.index = index;
	    }
	
	    return item;
	  };
	
	  function activate(index) {
	    if (itemLength === 0) {
	      return;
	    }
	
	    var curItem = items.get(index);
	    var prevItem;
	    var nextItem;
	
	    if (itemLength > 1) {
	      prevItem = items.get(index - 1);
	
	      if (itemLength === 2) {
	        nextItem = items.getCloned(index + 1);
	      } else {
	        nextItem = items.get(index + 1);
	      }
	
	      curItem.style.left = -transformOffset + 'px';
	      prevItem.style.left = -transformOffset - itemStep + 'px';
	      nextItem.style.left = -transformOffset + itemStep + 'px';
	    }
	
	    itemIndex = curItem.index;
	
	    fireEvent('change', {
	      prevItem: prevItem,
	      curItem: curItem,
	      nextItem: nextItem
	    });
	  }
	
	  items.slide = function (index) {
	    if (itemLength === 0) {
	      return;
	    }
	
	    if (itemLength === 1) {
	      index = 0;
	    }
	
	    var startOffset = getTransformOffset(element).x;
	    var endOffset = transformOffset + itemStep * -index;
	    var interOffset = endOffset - startOffset;
	
	    if (interOffset === 0) {
	      return;
	    }
	
	    var anim = new lib.animation(400, lib.cubicbezier.ease, function (i1, i2) {
	      element.style[stylePrefix + 'Transform'] = getTranslate(startOffset + interOffset * i2, 0);
	    }).play().then(function () {
	      transformOffset = endOffset;
	      element.style[stylePrefix + 'Transform'] = getTranslate(endOffset, 0);
	      index && activate(itemIndex + index);
	    });
	  };
	
	  items.next = function () {
	    items.slide(1);
	  };
	
	  items.prev = function () {
	    items.slide(-1);
	  };
	
	  ArrayFrom(element.children).forEach(function (el) {
	    el.style.position = 'absolute';
	    el.style.top = '0';
	    el.style.left = itemLength * itemStep + 'px';
	    el.style.float = 'left';
	    el.index = itemLength;
	    Object.defineProperty(items, itemLength + '', {
	      get: function get() {
	        return el;
	      }
	    });
	
	    itemLength++;
	  });
	
	  Object.defineProperty(this, 'items', {
	    get: function get() {
	      return items;
	    }
	  });
	
	  Object.defineProperty(items, 'length', {
	    get: function get() {
	      return itemLength;
	    }
	  });
	
	  Object.defineProperty(items, 'index', {
	    get: function get() {
	      return itemIndex;
	    }
	  });
	
	  Object.defineProperty(items, 'step', {
	    get: function get() {
	      return itemStep;
	    },
	
	    set: function set(v) {
	      itemStep = v;
	    }
	  });
	
	  var starting = false;
	  var playing = false;
	  var isSliding = false;
	  this.play = function () {
	    if (!starting) {
	      starting = true;
	      return activate(0);
	    }
	
	    if (!!playing) {
	      return;
	    }
	
	    playing = setTimeout(function play() {
	      isSliding = true;
	      items.next();
	      setTimeout(function () {
	        isSliding = false;
	      }, 500);
	      playing = setTimeout(play, 400 + playInterval);
	    }, 400 + playInterval);
	  };
	
	  this.stop = function () {
	    if (!playing) {
	      return;
	    }
	    clearTimeout(playing);
	    setTimeout(function () {
	      playing = false;
	    }, 500);
	  };
	
	  var autoplay = false;
	  var readyToPlay = false;
	  Object.defineProperty(this, 'autoplay', {
	    get: function get() {
	      return autoplay;
	    },
	    set: function set(v) {
	      autoplay = !!v;
	      if (readyToPlay) {
	        clearTimeout(readyToPlay);
	        readyToPlay = false;
	      }
	      if (autoplay) {
	        readyToPlay = setTimeout(function () {
	          that.play();
	        }, 2000);
	      } else {
	        that.stop();
	      }
	    }
	  });
	  this.autoplay = !!options.autoplay;
	
	  var playInterval = 1500;
	  Object.defineProperty(this, 'playInterval', {
	    get: function get() {
	      return playInterval;
	    },
	    set: function set(n) {
	      playInterval = n;
	    }
	  });
	  this.playInterval = !!options.playInterval || 1500;
	
	  if (options.useGesture) {
	    var panning = false;
	    var displacement;
	    element.addEventListener('panstart', function (e) {
	      if (!e.isVertical && !(panning && isSliding)) {
	        e.preventDefault();
	        e.stopPropagation();
	
	        if (autoplay) {
	          that.stop();
	        }
	
	        displacement = 0;
	        panning = true;
	      }
	    });
	
	    element.addEventListener('panmove', function (e) {
	      if (!e.isVertical && panning) {
	        e.preventDefault();
	        e.stopPropagation();
	        displacement = e.displacementX;
	        element.style[stylePrefix + 'Transform'] = getTranslate(transformOffset + displacement, 0);
	      }
	    });
	
	    element.addEventListener('panend', function (e) {
	      if (!e.isVertical && panning) {
	        e.preventDefault();
	        e.stopPropagation();
	        panning = false;
	        if (e.isSwipe) {
	          if (displacement < 0) {
	            items.next();
	          } else {
	            items.prev();
	          }
	        } else {
	          if (Math.abs(displacement) < itemStep / 2) {
	            items.slide(0);
	          } else {
	            items.slide(displacement < 0 ? 1 : -1);
	          }
	        }
	
	        if (autoplay) {
	          setTimeout(function () {
	            that.play();
	          }, 2000);
	        }
	      }
	    }, false);
	
	    element.addEventListener('swipe', function (e) {
	      if (!e.isVertical) {
	        e.preventDefault();
	        e.stopPropagation();
	      }
	    });
	  }
	
	  this.addEventListener = function (name, handler) {
	    this.root.addEventListener(name, handler, false);
	  };
	
	  this.removeEventListener = function (name, handler) {
	    this.root.removeEventListener(name, handler, false);
	  };
	
	  this.root = root;
	  this.element = element;
	}
	
	!lib && (lib = {});
	lib.carrousel = Carrousel;

/***/ },
/* 163 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a,b,c,d){function e(a){return(3*k*a+2*l)*a+m}function f(a){return((k*a+l)*a+m)*a}function g(a){return((n*a+o)*a+p)*a}function h(a){for(var b,c,d=a,g=0;8>g;g++){if(c=f(d)-a,Math.abs(c)<j)return d;if(b=e(d),Math.abs(b)<j)break;d-=c/b}var h=1,i=0;for(d=a;h>i;){if(c=f(d)-a,Math.abs(c)<j)return d;c>0?h=d:i=d,d=(h+i)/2}return d}function i(a){return g(h(a))}var j=1e-6,k=3*a-3*c+1,l=3*c-6*a,m=3*a,n=3*b-3*d+1,o=3*d-6*b,p=3*b;return i}b.cubicbezier=c,b.cubicbezier.linear=c(0,0,1,1),b.cubicbezier.ease=c(.25,.1,.25,1),b.cubicbezier.easeIn=c(.42,0,1,1),b.cubicbezier.easeOut=c(0,0,.58,1),b.cubicbezier.easeInOut=c(.42,0,.58,1)}(window,window.lib||(window.lib={}));;module.exports = window.lib['cubicbezier'];

/***/ },
/* 164 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a){return setTimeout(a,l)}function d(a){clearTimeout(a)}function e(){var a={},b=new m(function(b,c){a.resolve=b,a.reject=c});return a.promise=b,a}function f(a,b){return["then","catch"].forEach(function(c){b[c]=function(){return a[c].apply(a,arguments)}}),b}function g(b){var c,d,h=!1;this.request=function(){h=!1;var g=arguments;return c=e(),f(c.promise,this),d=n(function(){h||c&&c.resolve(b.apply(a,g))}),this},this.cancel=function(){return d&&(h=!0,o(d),c&&c.reject("CANCEL")),this},this.clone=function(){return new g(b)}}function h(a,b){"function"==typeof b&&(b={0:b});for(var c=a/l,d=1/c,e=[],f=Object.keys(b).map(function(a){return parseInt(a)}),h=0;c>h;h++){var i=f[0],j=d*h;if(null!=i&&100*j>=i){var k=b[""+i];k instanceof g||(k=new g(k)),e.push(k),f.shift()}else e.length&&e.push(e[e.length-1].clone())}return e}function i(a){var c;return"string"==typeof a||a instanceof Array?b.cubicbezier?"string"==typeof a?b.cubicbezier[a]&&(c=b.cubicbezier[a]):a instanceof Array&&4===a.length&&(c=b.cubicbezier.apply(b.cubicbezier,a)):console.error("require lib.cubicbezier"):"function"==typeof a&&(c=a),c}function j(a,b,c){var d,g=h(a,c),j=1/(a/l),k=0,m=i(b);if(!m)throw new Error("unexcept timing function");var n=!1;this.play=function(){function a(){var c=j*(k+1).toFixed(10),e=g[k];e.request(c.toFixed(10),b(c).toFixed(10)).then(function(){n&&(k===g.length-1?(n=!1,d&&d.resolve("FINISH"),d=null):(k++,a()))},function(){})}if(!n)return n=!0,d||(d=e(),f(d.promise,this)),a(),this},this.stop=function(){return n?(n=!1,g[k]&&g[k].cancel(),this):void 0}}var k=60,l=1e3/k,m=a.Promise||b.promise&&b.promise.ES6Promise,n=window.requestAnimationFrame||window.msRequestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||c,o=window.cancelAnimationFrame||window.msCancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||d;(n===c||o===d)&&(n=c,o=d),b.animation=function(a,b,c){return new j(a,b,c)},b.animation.frame=function(a){return new g(a)},b.animation.requestFrame=function(a){var b=new g(a);return b.request()}}(window,window.lib||(window.lib={}));;module.exports = window.lib['animation'];

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(166);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./carrousel.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./carrousel.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, "[data-ctrl-name=\"carrousel\"] {\n  position: relative;\n  -webkit-transform: translateZ(1px);\n  -ms-transform: translateZ(1px);\n  transform: translateZ(1px);\n}", ""]);
	
	// exports


/***/ },
/* 167 */
/***/ function(module, exports) {

	/* eslint-disable */
	
	'use strict';
	
	var _fallback = false;
	
	var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame;
	if (!raf) {
	  _fallback = true;
	  raf = function raf(callback) {
	    return setTimeout(callback, 16);
	  };
	}
	var caf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame;
	if (!caf && _fallback) {
	  caf = function caf(id) {
	    return clearTimeout(id);
	  };
	} else if (!caf) {
	  caf = function caf() {};
	}
	
	var MAX = (Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1) - 1;
	
	var _idMap = {};
	var _globalId = 0;
	
	function _getGlobalId() {
	  _globalId = (_globalId + 1) % MAX;
	  if (_idMap[_globalId]) {
	    return _getGlobalId();
	  }
	  return _globalId;
	}
	
	var timer = {
	
	  setTimeout: function setTimeout(cb, ms) {
	    var id = _getGlobalId();
	    var start = Date.now();
	    _idMap[id] = raf(function loop() {
	      if (!_idMap[id] && _idMap[id] !== 0) {
	        return;
	      }
	      var ind = Date.now() - start;
	      if (ind < ms) {
	        _idMap[id] = raf(loop);
	      } else {
	        delete _idMap[id];
	        cb();
	      }
	    });
	    return id;
	  },
	
	  clearTimeout: function clearTimeout(id) {
	    var tid = _idMap[id];
	    tid && caf(tid);
	    delete _idMap[id];
	  }
	
	};
	
	module.exports = timer;

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(169);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./slider.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./slider.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".slider {\n  position: relative;\n}\n\n.slider .indicator-container {\n  position: absolute;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-box-align: center;\n  box-align: center;\n  -webkit-align-items: center;\n  align-items: center;\n  -webkit-box-pack: center;\n  box-pack: center;\n  -webkit-justify-content: center;\n  justify-content: center;\n  font-size: 0;\n}\n.slider .indicator-container .indicator {\n  border-radius: 50%;\n}\n.slider .indicator-container.row {\n  -webkit-box-orient: horizontal;\n  box-orient: horizontal;\n  -webkit-flex-direction: row;\n  flex-direction: row;\n}\n.slider .indicator-container.column {\n  -webkit-box-orient: vertical;\n  box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n}\n", ""]);
	
	// exports


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	__webpack_require__(171);
	
	var DEFAULT_ITEM_COLOR = '#999';
	var DEFAULT_ITEM_SELECTED_COLOR = '#0000ff';
	var DEFAULT_ITEM_SIZE = 20;
	var DEFAULT_MARGIN_SIZE = 10;
	
	function resetColor(indicator) {
	  var len = indicator.items.length;
	  if (typeof indicator.index !== 'undefined' && len > indicator.index) {
	    for (var i = 0; i < len; i++) {
	      var item = indicator.items[i];
	      if (indicator.index === i) {
	        item.classList.add('active');
	        item.style.backgroundColor = indicator.itemSelectedColor;
	      } else {
	        item.style.backgroundColor = indicator.itemColor;
	      }
	    }
	  }
	}
	
	function handleClick(indicator, idx, e) {
	  indicator.slider.slideTo(idx);
	}
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('div');
	    node.classList.add('weex-indicators');
	    node.classList.add('weex-element');
	    node.style.position = 'absolute';
	    this.node = node;
	    this.style.itemSize.call(this, 0);
	    this.updateStyle({
	      left: 0,
	      top: 0,
	      itemSize: 0
	    });
	    return node;
	  },
	  createChildren: function createChildren() {
	    var root = document.createDocumentFragment();
	    for (var i = 0; i < this.amount; i++) {
	      var indicator = document.createElement('div');
	      indicator.classList.add('weex-indicator');
	      indicator.style.boxSizing = 'border-box';
	      indicator.style.margin = '0 ' + DEFAULT_MARGIN_SIZE * this.data.scale + 'px';
	      indicator.style.width = this.itemSize + 'px';
	      indicator.style.height = this.itemSize + 'px';
	      indicator.setAttribute('index', i);
	      if (this.index === i) {
	        indicator.classList.add('active');
	        indicator.style.backgroundColor = this.itemSelectedColor;
	      } else {
	        indicator.style.backgroundColor = this.itemColor;
	      }
	      indicator.addEventListener('click', handleClick.bind(null, this, i));
	      this.items[i] = indicator;
	      root.appendChild(indicator);
	    }
	    this.node.appendChild(root);
	  },
	  setIndex: function setIndex(idx) {
	    if (idx >= this.amount) {
	      return;
	    }
	    var prev = this.items[this.index];
	    var cur = this.items[idx];
	    prev.classList.remove('active');
	    prev.style.backgroundColor = this.itemColor;
	    cur.classList.add('active');
	    cur.style.backgroundColor = this.itemSelectedColor;
	    this.index = idx;
	  }
	};
	
	var style = {
	  itemColor: function itemColor(val) {
	    this.itemColor = val || DEFAULT_ITEM_COLOR;
	    resetColor(this);
	  },
	  itemSelectedColor: function itemSelectedColor(val) {
	    this.itemSelectedColor = val || DEFAULT_ITEM_SELECTED_COLOR;
	    resetColor(this);
	  },
	  itemSize: function itemSize(val) {
	    val = parseInt(val) * this.data.scale || DEFAULT_ITEM_SIZE * this.data.scale;
	    this.itemSize = val;
	    this.node.style.height = val + 'px';
	    for (var i = 0, l = this.items.length; i < l; i++) {
	      this.items[i].style.width = val + 'px';
	      this.items[i].style.height = val + 'px';
	    }
	  },
	  width: function width(val) {
	    val = parseInt(val) * this.data.scale || parseInt(this.sliderWidth);
	    this.virtualWrapperWidth = val;
	  },
	  height: function height(val) {
	    val = parseInt(val) * this.data.scale || parseInt(this.sliderHeight);
	    this.virtualWrapperHeight = val;
	  },
	  top: function top(val) {
	    val = this.virtualWrapperHeight / 2 - this.itemSize / 2 + val * this.data.scale;
	    this.node.style.bottom = '';
	    this.node.style.top = val + 'px';
	  },
	  bottom: function bottom(val) {
	    val = this.virtualWrapperHeight / 2 - this.itemSize / 2 + val * this.data.scale;
	    this.node.style.top = '';
	    this.node.style.bottom = val + 'px';
	  },
	  left: function left(val) {
	    val = this.virtualWrapperWidth / 2 - (this.itemSize + 2 * DEFAULT_MARGIN_SIZE * this.data.scale) * this.amount / 2 + val * this.data.scale;
	    this.node.style.right = '';
	    this.node.style.left = val + 'px';
	  },
	  right: function right(val) {
	    val = this.virtualWrapperWidth / 2 - (this.itemSize + 2 * DEFAULT_MARGIN_SIZE * this.data.scale) * this.amount / 2 + val * this.data.scale;
	    this.node.style.left = '';
	    this.node.style.right = val + 'px';
	  }
	};
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	
	  // Style supported:
	  //   position: (default - absolute)
	  //   itemColor: color of indicator dots
	  //   itemSelectedColor: color of the selected indicator dot
	  //   itemSize: size of indicators
	  //   other layout styles
	  function Indicator(data) {
	    this.direction = 'row'; // 'column' is not temporarily supported.
	    this.amount = data.extra.amount;
	    this.index = data.extra.index;
	    this.sliderWidth = data.extra.width;
	    this.sliderHeight = data.extra.height;
	    var styles = data.style || {};
	    this.data = data;
	    this.style.width.call(this, styles.width);
	    this.style.height.call(this, styles.height);
	    this.itemColor = styles.itemColor || DEFAULT_ITEM_COLOR;
	    this.itemSelectedColor = styles.itemSelectedColor || DEFAULT_ITEM_SELECTED_COLOR;
	    this.items = [];
	    Atomic.call(this, data);
	  }
	  Indicator.prototype = Object.create(Atomic.prototype);
	  extend(Indicator.prototype, proto);
	  extend(Indicator.prototype, {
	    style: extend(Object.create(Atomic.prototype.style), style)
	  });
	
	  Weex.registerComponent('indicator', Indicator);
	}
	
	exports.default = { init: init };

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(172);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./indicator.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./indicator.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-indicators {\n  position: absolute;\n  white-space: nowrap;\n}\n.weex-indicators .weex-indicator {\n  float: left;\n  border-radius: 50%;\n}\n", ""]);
	
	// exports


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	// TODO: refactor this scss code since this is strongly
	// dependent on lib.flexible other than the value of
	// scale.
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	__webpack_require__(174);
	
	function initFoldBtn(tabheader) {
	  var node = tabheader.node;
	  var btn = document.createElement('span');
	  btn.className = 'fold-toggle iconfont';
	  btn.innerHTML = '&#xe661;';
	  node.appendChild(btn);
	
	  btn.addEventListener('click', function () {
	    if (tabheader.unfolding) {
	      folding(tabheader);
	    } else {
	      unfolding(tabheader);
	    }
	  });
	}
	
	function initMask(tabheader) {
	  var mask = document.createElement('div');
	  mask.className = 'tabheader-mask';
	  tabheader.mask = mask;
	  // stop default behavior: page moving.
	  mask.addEventListener('touchmove', function (evt) {
	    evt.preventDefault();
	  });
	  // click to unfold.
	  mask.addEventListener('click', function () {
	    folding(tabheader);
	  });
	
	  document.body.appendChild(mask);
	}
	
	function unfolding(tabheader) {
	  // mark the initial posiiton of tabheader
	  if (!tabheader.flag) {
	    var flag = document.createComment('tabheader');
	    tabheader.flag = flag;
	    tabheader.node.parentNode.insertBefore(flag, tabheader.node);
	  }
	  if (!tabheader.mask) {
	    initMask(tabheader);
	  }
	
	  // record the scroll position.
	  tabheader._scrollVal = tabheader._body.scrollLeft;
	  // record the position in document.
	  tabheader._topVal = tabheader.node.getBoundingClientRect().top;
	  tabheader._styleTop = tabheader.node.style.top;
	
	  document.body.appendChild(tabheader.node);
	  tabheader.node.classList.add('unfold-header');
	  tabheader.node.style.height = 'auto';
	  // recalc the position when it is unfolded.
	  var thHeight = tabheader.node.getBoundingClientRect().height;
	  if (thHeight + tabheader._topVal > window.innerHeight) {
	    tabheader._topVal = tabheader._topVal + (window.innerHeight - thHeight - tabheader._topVal);
	  }
	
	  tabheader.node.style.top = tabheader._topVal + 'px';
	  // process mask style
	  tabheader.mask.classList.add('unfold-header');
	  tabheader.mask.style.height = window.innerHeight + 'px';
	  tabheader.unfolding = true;
	}
	
	function folding(tabheader) {
	  if (tabheader.unfolding !== true) {
	    return;
	  }
	
	  tabheader.mask.classList.remove('unfold-header');
	  tabheader.node.classList.remove('unfold-header');
	
	  tabheader.node.style.height = '';
	  tabheader.node.style.top = tabheader._styleTop;
	
	  // recover the position of tabheader.
	  tabheader.flag.parentNode.insertBefore(tabheader.node, tabheader.flag);
	  // recover the position of scoller.
	  tabheader._body.scrollLeft = tabheader._scrollVal;
	
	  scrollToView(tabheader);
	  tabheader.unfolding = false;
	}
	
	function initEvent(tabheader) {
	  initClickEvent(tabheader);
	  initSelectEvent(tabheader);
	}
	
	// init events.
	function initClickEvent(tabheader) {
	  var box = tabheader.box;
	
	  box.addEventListener('click', function (evt) {
	    var target = evt.target;
	    if (target.nodeName === 'UL') {
	      return;
	    }
	
	    if (target.parentNode.nodeName === 'LI') {
	      target = target.parentNode;
	    }
	
	    var floor = target.getAttribute('data-floor');
	    /* eslint-disable eqeqeq */
	    if (tabheader.data.attr.selectedIndex == floor) {
	      // Duplicated clicking, not to trigger select event.
	      return;
	    }
	    /* eslint-enable eqeqeq */
	
	    fireEvent(target, 'select', { index: floor });
	  });
	}
	
	function initSelectEvent(tabheader) {
	  var node = tabheader.node;
	  node.addEventListener('select', function (evt) {
	    var index = void 0;
	    if (evt.index !== undefined) {
	      index = evt.index;
	    } else if (evt.data && evt.data.index !== undefined) {
	      index = evt.data.index;
	    }
	
	    if (index === undefined) {
	      return;
	    }
	
	    tabheader.attr.selectedIndex.call(tabheader, index);
	  });
	}
	
	function scrollToView(tabheader, node) {
	  if (!node) {
	    var _attr = tabheader.data.attr;
	    node = tabheader.node.querySelector('[data-floor="' + _attr.selectedIndex + '"]');
	  }
	  if (!node) {
	    return;
	  }
	
	  // const defaultVal = tabheader._body.scrollLeft
	  // const leftVal = defaultVal - node.offsetLeft + 300
	
	  var scrollVal = getScrollVal(tabheader._body.getBoundingClientRect(), node);
	  doScroll(tabheader._body, scrollVal);
	}
	
	// scroll the tabheader.
	// positive val means to scroll right.
	// negative val means to scroll left.
	function doScroll(node, val, finish) {
	  if (!val) {
	    return;
	  }
	  if (finish === undefined) {
	    finish = Math.abs(val);
	  }
	
	  if (finish <= 0) {
	    return;
	  }
	
	  setTimeout(function () {
	    if (val > 0) {
	      node.scrollLeft += 2;
	    } else {
	      node.scrollLeft -= 2;
	    }
	    finish -= 2;
	
	    doScroll(node, val, finish);
	  });
	}
	
	// get scroll distance.
	function getScrollVal(rect, node) {
	  var left = node.previousSibling;
	  var right = node.nextSibling;
	  var scrollVal = void 0;
	
	  // process left-side element first.
	  if (left) {
	    var leftRect = left.getBoundingClientRect();
	    // only need to compare the value of left.
	    if (leftRect.left < rect.left) {
	      scrollVal = leftRect.left;
	      return scrollVal;
	    }
	  }
	
	  if (right) {
	    var rightRect = right.getBoundingClientRect();
	    // compare the value of right.
	    if (rightRect.right > rect.right) {
	      scrollVal = rightRect.right - rect.right;
	      return scrollVal;
	    }
	  }
	
	  // process current node, from left to right.
	  var nodeRect = node.getBoundingClientRect();
	  if (nodeRect.left < rect.left) {
	    scrollVal = nodeRect.left;
	  } else if (nodeRect.right > rect.right) {
	    scrollVal = nodeRect.right - rect.right;
	  }
	
	  return scrollVal;
	}
	
	// trigger and broadcast events.
	function fireEvent(element, type, data) {
	  var evt = document.createEvent('Event');
	  evt.data = data;
	  for (var k in data) {
	    if (data.hasOwnProperty(k)) {
	      evt[k] = data[k];
	    }
	  }
	  // need bubble.
	  evt.initEvent(type, true, true);
	
	  element.dispatchEvent(evt);
	}
	
	function createHighlightIcon(code) {
	  var html = '<i class="hl-icon iconfont">' + '&#xe650' + '</i>';
	  return html;
	}
	
	function isValidColor(color) {
	  if (!color) {
	    return false;
	  }
	
	  if (color.charAt(0) !== '#') {
	    return false;
	  }
	
	  if (color.length !== 7) {
	    return false;
	  }
	
	  return true;
	}
	
	var proto = {
	  create: function create() {
	    // outside container.
	    var node = document.createElement('div');
	    node.className = 'tab-header';
	    // tip on the top.
	    var bar = document.createElement('div');
	    bar.className = 'header-bar';
	    bar.textContent = 'CHANGE FLOOR';
	    // middle layer.
	    var body = document.createElement('div');
	    body.className = 'header-body';
	    var box = document.createElement('ul');
	    box.className = 'tabheader';
	
	    body.appendChild(box);
	    node.appendChild(bar);
	    node.appendChild(body);
	    this._bar = bar;
	    this._body = body;
	    this.box = box;
	    this.node = node;
	    // init events.
	    initFoldBtn(this);
	    initEvent(this);
	    return node;
	  }
	};
	
	var attr = {
	  highlightIcon: function highlightIcon() {
	    return createHighlightIcon();
	  },
	  data: function data() {
	    var attr = this.data.attr;
	    // Ensure there is a default selected value.
	    if (attr.selectedIndex === undefined) {
	      attr.selectedIndex = 0;
	    }
	
	    var list = attr.data || [];
	    var curItem = attr.selectedIndex;
	
	    var ret = [];
	    var itemTmpl = '<li class="th-item" data-floor="{{floor}}">' + '{{hlIcon}}{{floorName}}</li>';
	
	    list.forEach(function (item, idx) {
	      var html = itemTmpl.replace('{{floor}}', idx);
	      /* eslint-disable eqeqeq */
	      if (curItem == idx) {
	        html = html.replace('{{hlIcon}}', createHighlightIcon());
	      } else {
	        html = html.replace('{{hlIcon}}', '');
	      }
	      /* eslint-enable eqeqeq */
	
	      html = html.replace('{{floorName}}', item);
	
	      ret.push(html);
	    }, this);
	
	    this.box.innerHTML = ret.join('');
	  },
	  selectedIndex: function selectedIndex(val) {
	    var attr = this.data.attr;
	
	    if (val === undefined) {
	      val = 0;
	    }
	
	    // if (val == attr.selectedIndex) {
	    //   return
	    // }
	
	    attr.selectedIndex = val;
	
	    this.attr.data.call(this);
	
	    folding(this);
	    this.style.textHighlightColor.call(this, this.textHighlightColor);
	  }
	};
	
	var style = {
	  opacity: function opacity(val) {
	    if (val === undefined || val < 0 || val > 1) {
	      val = 1;
	    }
	
	    this.node.style.opacity = val;
	  },
	  textColor: function textColor(val) {
	    if (!isValidColor(val)) {
	      return;
	    }
	
	    this.node.style.color = val;
	  },
	  textHighlightColor: function textHighlightColor(val) {
	    if (!isValidColor(val)) {
	      return;
	    }
	    this.textHighlightColor = val;
	    var attr = this.data.attr;
	
	    var node = this.node.querySelector('[data-floor="' + attr.selectedIndex + '"]');
	    if (node) {
	      node.style.color = val;
	      scrollToView(this, node);
	    }
	  }
	};
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	
	  function TabHeader(data) {
	    Atomic.call(this, data);
	  }
	  TabHeader.prototype = Object.create(Atomic.prototype);
	  extend(TabHeader.prototype, proto);
	  extend(TabHeader.prototype, { attr: attr });
	  extend(TabHeader.prototype, {
	    style: extend(Object.create(Atomic.prototype.style), style)
	  });
	
	  Weex.registerComponent('tabHeader', TabHeader);
	}
	
	exports.default = { init: init };

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(175);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./tabheader.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./tabheader.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".tab-header {\n  position: relative;\n  width: 10rem;\n  font-size: 14px;\n  color: #333;\n}\n.tab-header .header-bar {\n  height: 1.17rem;\n  line-height: 1.17rem;\n  display: none;\n  color: #999;\n  padding-left: 0.4rem;\n}\n.tab-header .header-body {\n  margin-right: 1.07rem;\n  overflow-x: auto;\n  overflow-y: hidden;\n}\n.tab-header .header-body::-webkit-scrollbar {\n  width: 0;\n  height: 0;\n  overflow: hidden;\n}\n.tab-header .fold-toggle {\n  position: absolute;\n  top: 0.59rem;\n  -webkit-transform: translateY(-50%);\n  right: 0.29rem;\n  width: 0.48rem;\n  height: 0.48rem;\n  line-height: 0.48rem;\n  text-align: center;\n  z-index: 99;\n  font-size: 14px;\n}\n.tab-header.unfold-header {\n  position: fixed !important;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.tabheader {\n  list-style: none;\n  white-space: nowrap;\n  height: 1.17rem;\n  line-height: 1.17rem;\n}\n.tabheader .th-item {\n  padding-left: 0.72rem;\n  position: relative;\n  display: inline-block;\n}\n.tabheader .hl-icon {\n  width: 0.4rem;\n  height: 0.4rem;\n  line-height: 0.4rem;\n  text-align: center;\n  position: absolute;\n  top: 50%;\n  -webkit-transform: translateY(-50%);\n  left: 0.24rem;\n  font-size: 14px;\n}\n\n.unfold-header .header-bar {\n  display: block;\n}\n.unfold-header .fold-toggle {\n  -webkit-transform: translateY(-50%) rotate(180deg);\n}\n.unfold-header .header-body {\n  margin-right: 0;\n  padding: 0.24rem;\n}\n.unfold-header .tabheader {\n  display: block;\n  height: auto;\n}\n.unfold-header .th-item {\n  box-sizing: border-box;\n  float: left;\n  width: 33.3333%;\n  height: 1.01rem;\n  line-height: 1.01rem;\n}\n.unfold-header .hl-icon {\n  margin-right: 0;\n  position: absolute;\n}\n.unfold-header.tabheader-mask {\n  display: block;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.6);\n}\n\n.tabheader-mask {\n  display: none;\n  position: fixed;\n  left: 0;\n  top: 0;\n}\n\n@font-face {\n  font-family: \"iconfont\";\n  src: url(\"data:application/x-font-ttf;charset=utf-8;base64,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R7AEQ7CAYmAgsAArIIqKYSCwAkNgZCOwA0NhZFBYsAJDYRuwA0NgWbADJbCAYmGwAiVGYTgjIDwjOBshICBGI0ewACsjYTghWbEkARQrLbA7LLAuKy6xJAEUKy2wPCywLyshIyAgPLAEI0IjOLEkARQrsARDLrAkKy2wPSywABUgR7AAI0KyAAEBFRQTLrAqKi2wPiywABUgR7AAI0KyAAEBFRQTLrAqKi2wPyyxAAEUE7ArKi2wQCywLSotsEEssAAWRSMgLiBGiiNhOLEkARQrLbBCLLAJI0KwQSstsEMssgAAOistsEQssgABOistsEUssgEAOistsEYssgEBOistsEcssgAAOystsEgssgABOystsEkssgEAOystsEossgEBOystsEsssgAANystsEwssgABNystsE0ssgEANystsE4ssgEBNystsE8ssgAAOSstsFAssgABOSstsFEssgEAOSstsFIssgEBOSstsFMssgAAPCstsFQssgABPCstsFUssgEAPCstsFYssgEBPCstsFcssgAAOCstsFgssgABOCstsFkssgEAOCstsFossgEBOCstsFsssDArLrEkARQrLbBcLLAwK7A0Ky2wXSywMCuwNSstsF4ssAAWsDArsDYrLbBfLLAxKy6xJAEUKy2wYCywMSuwNCstsGEssDErsDUrLbBiLLAxK7A2Ky2wYyywMisusSQBFCstsGQssDIrsDQrLbBlLLAyK7A1Ky2wZiywMiuwNistsGcssDMrLrEkARQrLbBoLLAzK7A0Ky2waSywMyuwNSstsGossDMrsDYrLbBrLCuwCGWwAyRQeLABFTAtAABLuADIUlixAQGOWbkIAAgAYyCwASNEILADI3CwDkUgIEu4AA5RS7AGU1pYsDQbsChZYGYgilVYsAIlYbABRWMjYrACI0SzCgkFBCuzCgsFBCuzDg8FBCtZsgQoCUVSRLMKDQYEK7EGAUSxJAGIUViwQIhYsQYDRLEmAYhRWLgEAIhYsQYBRFlZWVm4Af+FsASNsQUARAAAAA==\") format(\"truetype\");\n}\n.iconfont {\n  font-family: iconfont !important;\n  font-size: 16px;\n  font-style: normal;\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-stroke-width: 0.2px;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n[data-dpr=\"2\"] .tab-header {\n  font-size: 28px;\n}\n\n[data-dpr=\"3\"] .tab-header {\n  font-size: 42px;\n}\n\n[data-dpr=\"2\"] .tabheader .hl-icon {\n  font-size: 28px;\n}\n\n[data-dpr=\"3\"] .tabheader .hl-icon {\n  font-size: 42px;\n}\n\n[data-dpr=\"2\"] .tab-header .fold-toggle {\n  font-size: 28px;\n}\n\n[data-dpr=\"3\"] .tab-header .fold-toggle {\n  font-size: 42px;\n}\n", ""]);
	
	// exports


/***/ },
/* 176 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var appendStyle = void 0;
	
	var availableTypes = ['text', 'password', 'tel', 'email', 'url'];
	var DEFAULT_TYPE = 'text';
	
	function setPlaceholderColor(input, placeholderColor) {
	  if (!placeholderColor) {
	    return;
	  }
	  var vendors = ['::-webkit-input-placeholder', ':-moz-placeholder', '::-moz-placeholder', ':-ms-input-placeholder', ':placeholder-shown'];
	  var css = '';
	  var cssRule = 'color: ' + placeholderColor + ';';
	  for (var i = 0, l = vendors.length; i < l; i++) {
	    css += '.' + input.className + vendors[i] + '{' + cssRule + '}';
	  }
	  appendStyle(css, input.styleId, true);
	}
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('input');
	    var uuid = Math.floor(10000000000000 * Math.random()) + Date.now();
	    this.className = 'weex-ipt-' + uuid;
	    this.styleId = 'weex-style-' + uuid;
	    node.classList.add(this.className);
	    node.classList.add('weex-element');
	    this.placeholder && (node.placeholder = this.placeholder);
	    return node;
	  }
	};
	
	// updatable attributes
	var attr = {
	  disabled: function disabled(val) {
	    this.node.disabled = !!val;
	  },
	  placeholder: function placeholder(val) {
	    this.node.placeholder = val || '';
	  },
	  value: function value(val) {
	    this.node.value = val || '';
	  },
	  autofocus: function autofocus(val) {
	    this.node.autofocus = !!val;
	  },
	  type: function type(val) {
	    this.node.type = availableTypes.indexOf(val) !== -1 ? val : DEFAULT_TYPE;
	  }
	};
	
	// updatable styles
	var style = {
	  placeholderColor: function placeholderColor(val) {
	    setPlaceholderColor(this, val);
	  }
	};
	
	// events configurations
	var event = {
	  input: {
	    updator: function updator() {
	      return {
	        attrs: {
	          value: this.node.value
	        }
	      };
	    },
	    extra: function extra() {
	      return {
	        value: this.node.value,
	        timestamp: Date.now()
	      };
	    }
	  },
	
	  change: {
	    updator: function updator() {
	      return {
	        attrs: {
	          value: this.node.value
	        }
	      };
	    },
	    extra: function extra() {
	      return {
	        value: this.node.value,
	        timestamp: Date.now()
	      };
	    }
	  }
	};
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	  appendStyle = Weex.utils.appendStyle;
	
	  // attrs:
	  //   - type: text|password|tel|email|url
	  //   - value
	  //   - placeholder
	  //   - disabled
	  //   - autofocus
	  function Input(data) {
	    Atomic.call(this, data);
	  }
	  Input.prototype = Object.create(Atomic.prototype);
	  extend(Input.prototype, proto);
	  extend(Input.prototype, { attr: attr });
	  extend(Input.prototype, {
	    style: extend(Object.create(Atomic.prototype.style), style)
	  });
	  extend(Input.prototype, { event: event });
	
	  Weex.registerComponent('input', Input);
	}
	
	exports.default = { init: init };

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	__webpack_require__(178);
	
	function getProto(Weex) {
	  var Atomic = Weex.Atomic;
	  return {
	    create: function create() {
	      var node = document.createElement('video');
	      node.classList.add('weex-video', 'weex-element');
	      node.controls = true;
	      node.autoplay = this.autoPlay;
	      node.setAttribute('play-status', this.playStatus);
	      this.node = node;
	      if (this.autoPlay && this.playStatus === 'play') {
	        this.play();
	      }
	      return node;
	    },
	    bindEvents: function bindEvents(evts) {
	      Atomic.prototype.bindEvents.call(this, evts);
	
	      // convert w3c-video events to weex-video events.
	      var evtsMap = {
	        start: 'play',
	        finish: 'ended',
	        fail: 'error'
	      };
	      for (var evtName in evtsMap) {
	        this.node.addEventListener(evtsMap[evtName], function (type, e) {
	          this.dispatchEvent(type, e.data);
	        }.bind(this, evtName));
	      }
	    },
	    play: function play() {
	      var src = this.node.getAttribute('src');
	      if (!src) {
	        src = this.node.getAttribute('data-src');
	        src && this.node.setAttribute('src', src);
	      }
	      this.node.play();
	    },
	    pause: function pause() {
	      this.node.pause();
	    },
	    stop: function stop() {
	      this.node.pause();
	      this.node.autoplay = false;
	      this.node.setAttribute('data-src', this.node.src);
	      this.node.src = '';
	    }
	  };
	}
	
	var attr = {
	  playStatus: function playStatus(val) {
	    if (val !== 'play' && val !== 'stop' && val !== 'pause') {
	      val = 'pause';
	    }
	    if (this.playStatus === val) {
	      return;
	    }
	    this.playStatus = val;
	    this.node.setAttribute('play-status', val);
	    this[this.playStatus]();
	  },
	  autoPlay: function autoPlay(val) {
	    // DO NOTHING
	  }
	};
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	
	  // attrs:
	  //   - autoPlay: true | false (default: false)
	  //   - playStatus: play | pause | stop
	  //   - src: {string}
	  //   - poster: {string}
	  //   - loop: true | false (default: false)
	  //   - muted: true | false (default: false)
	  // events:
	  //   - start
	  //   - pause
	  //   - finish
	  //   - fail
	  function Video(data) {
	    var autoPlay = data.attr.autoPlay;
	    var playStatus = data.attr.playStatus;
	    this.autoPlay = autoPlay === true || autoPlay === 'true';
	    if (playStatus !== 'play' && playStatus !== 'stop' && playStatus !== 'pause') {
	      this.playStatus = 'pause';
	    } else {
	      this.playStatus = playStatus;
	    }
	    Atomic.call(this, data);
	  }
	  Video.prototype = Object.create(Atomic.prototype);
	  extend(Video.prototype, getProto(Weex));
	  extend(Video.prototype, { attr: attr });
	
	  Weex.registerComponent('video', Video);
	}
	
	exports.default = { init: init };

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(179);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./video.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./video.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-video {\n\tbackground-color: #000;\n}", ""]);
	
	// exports


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	__webpack_require__(181);
	
	var defaults = {
	  color: '#64bd63',
	  secondaryColor: '#dfdfdf',
	  jackColor: '#fff',
	  jackSecondaryColor: null,
	  className: 'weex-switch',
	  disabledOpacity: 0.5,
	  speed: '0.4s',
	  width: 100,
	  height: 60,
	  // is width and height scalable ?
	  scalable: false
	};
	
	function transitionize(element, props) {
	  var transitions = [];
	  for (var key in props) {
	    transitions.push(key + ' ' + props[key]);
	  }
	  element.style.transition = transitions.join(', ');
	  element.style.webkitTransition = transitions.join(', ');
	}
	
	function setSize(comp) {
	  var min = Math.min(comp.width, comp.height);
	  var max = Math.max(comp.width, comp.height);
	  comp.node.style.width = max + 'px';
	  comp.node.style.height = min + 'px';
	  comp.node.style.borderRadius = min / 2 + 'px';
	  comp.jack.style.width = comp.jack.style.height = min + 'px';
	}
	
	function setPosition(comp, clicked) {
	  var checked = comp.checked;
	  var node = comp.node;
	  var jack = comp.jack;
	
	  if (clicked && checked) {
	    checked = false;
	  } else if (clicked && !checked) {
	    checked = true;
	  }
	
	  if (checked === true) {
	    comp.checked = true;
	
	    if (window.getComputedStyle) {
	      jack.style.left = parseInt(window.getComputedStyle(node).width) - parseInt(window.getComputedStyle(jack).width) + 'px';
	    } else {
	      jack.style.left = parseInt(node.currentStyle['width']) - parseInt(jack.currentStyle['width']) + 'px';
	    }
	
	    comp.options.color && colorize(comp);
	    setSpeed(comp);
	  } else {
	    comp.checked = false;
	    jack.style.left = 0;
	    node.style.boxShadow = 'inset 0 0 0 0 ' + comp.options.secondaryColor;
	    node.style.borderColor = comp.options.secondaryColor;
	    node.style.backgroundColor = comp.options.secondaryColor !== defaults.secondaryColor ? comp.options.secondaryColor : '#fff';
	    jack.style.backgroundColor = comp.options.jackSecondaryColor !== comp.options.jackColor ? comp.options.jackSecondaryColor : comp.options.jackColor;
	    setSpeed(comp);
	  }
	}
	
	function setSpeed(comp) {
	  var switcherProp = {};
	  var jackProp = {
	    'background-color': comp.options.speed,
	    left: comp.options.speed.replace(/[a-z]/, '') / 2 + 's'
	  };
	
	  if (comp.checked) {
	    switcherProp = {
	      border: comp.options.speed,
	      'box-shadow': comp.options.speed,
	      'background-color': comp.options.speed.replace(/[a-z]/, '') * 3 + 's'
	    };
	  } else {
	    switcherProp = {
	      border: comp.options.speed,
	      'box-shadow': comp.options.speed
	    };
	  }
	
	  transitionize(comp.node, switcherProp);
	  transitionize(comp.jack, jackProp);
	}
	
	function colorize(comp) {
	  var nodeHeight = comp.node.offsetHeight / 2;
	
	  comp.node.style.backgroundColor = comp.options.color;
	  comp.node.style.borderColor = comp.options.color;
	  comp.node.style.boxShadow = 'inset 0 0 0 ' + nodeHeight + 'px ' + comp.options.color;
	  comp.jack.style.backgroundColor = comp.options.jackColor;
	}
	
	function getClickHandler(comp) {
	  if (!comp._clickHandler) {
	    comp._clickHandler = function () {
	      setPosition(comp, true);
	      comp.dispatchEvent('change', {
	        value: comp.checked
	      });
	    };
	  }
	  return comp._clickHandler;
	}
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('span');
	    this.jack = document.createElement('small');
	    node.appendChild(this.jack);
	    node.className = this.options.className;
	    this.node = node;
	    this.attr.disabled.call(this, this.data.attr.disabled);
	    return node;
	  },
	  onAppend: function onAppend() {
	    setSize(this);
	    setPosition(this);
	  },
	  enable: function enable() {
	    this.disabled && (this.disabled = false);
	    this.node.style.opacity = 1;
	    this.node.addEventListener('click', getClickHandler(this));
	  },
	  disable: function disable() {
	    !this.disabled && (this.disabled = true);
	    this.node.style.opacity = defaults.disabledOpacity;
	    this.node.removeEventListener('click', getClickHandler(this));
	  }
	};
	
	var attr = {
	  disabled: function disabled(val) {
	    this.disabled = val && val !== 'false';
	    this.disabled ? this.disable() : this.enable();
	  }
	};
	
	var style = {
	  width: function width(val) {
	    if (!this.options.scalable) {
	      return;
	    }
	    val = parseFloat(val);
	    if (isNaN(val) || val < 0) {
	      val = this.options.width;
	    }
	    this.width = val * this.data.scale;
	    this.setSize();
	  },
	
	  height: function height(val) {
	    if (!this.options.scalable) {
	      return;
	    }
	    val = parseFloat(val);
	    if (isNaN(val) || val < 0) {
	      val = this.options.height;
	    }
	    this.height = val * this.data.scale;
	    this.setSize();
	  }
	};
	
	var event = {
	  change: {
	    updator: function updator() {
	      return {
	        attrs: {
	          checked: this.checked
	        }
	      };
	    },
	    extra: function extra() {
	      return {
	        value: this.checked
	      };
	    }
	  }
	};
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	
	  // attrs:
	  //   - checked: if is checked.
	  //   - disabled: if true, this component is not available for interaction.
	  function Switch(data) {
	    this.options = extend({}, defaults);
	    this.checked = data.attr.checked && data.attr.checked !== 'false';
	    this.data = data;
	    this.width = this.options.width * data.scale;
	    this.height = this.options.height * data.scale;
	    Atomic.call(this, data);
	  }
	  Switch.prototype = Object.create(Atomic.prototype);
	  extend(Switch.prototype, proto);
	  extend(Switch.prototype, { attr: attr });
	  extend(Switch.prototype, {
	    style: extend(Object.create(Atomic.prototype.style), style)
	  });
	  extend(Switch.prototype, { event: event });
	
	  Weex.registerComponent('switch', Switch);
	}
	
	exports.default = { init: init };

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(182);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./switch.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./switch.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, "/* switch defaults. */\n.weex-switch {\n  background-color: #fff;\n  border: 1px solid #dfdfdf;\n  cursor: pointer;\n  display: inline-block;\n  position: relative;\n  vertical-align: middle;\n  -moz-user-select: none;\n  -khtml-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  box-sizing: content-box;\n  background-clip: content-box;\n}\n\n.weex-switch > small {\n  background: #fff;\n  border-radius: 100%;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);\n  position: absolute;\n  top: 0;\n}\n", ""]);
	
	// exports


/***/ },
/* 183 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	function getProto(Weex) {
	  var Component = Weex.Component;
	  return {
	    create: function create() {
	      var node = document.createElement('a');
	      node.classList.add('weex-container');
	      node.style.textDecoration = 'none';
	      return node;
	    },
	    bindEvents: function bindEvents(evts) {
	      // event handler for click event will be processed
	      // before the url redirection.
	      Component.prototype.bindEvents.call(this, evts);
	      this.node.addEventListener('click', function (evt) {
	        if (evt._alreadyFired && evt.target !== this.node) {
	          // if the event target is this.node, then this is
	          // just another click event handler for the same
	          // target, not a handler for a bubbling up event,
	          // otherwise it is a bubbling up event, and it
	          // should be disregarded.
	          return;
	        }
	        evt._alreadyFired = true;
	        location.href = this.href;
	      }.bind(this));
	    }
	  };
	}
	
	var attr = {
	  href: function href(val) {
	    if (!val) {
	      return console.warn('[web-render] href of <a> should not be a null value.');
	    }
	    this.href = val;
	    this.node.setAttribute('data-href', val);
	  }
	};
	
	function init(Weex) {
	  var Component = Weex.Component;
	  var extend = Weex.utils.extend;
	
	  // attrs:
	  //   - href
	  function A(data) {
	    Component.call(this, data);
	  }
	
	  A.prototype = Object.create(Component.prototype);
	  extend(A.prototype, getProto(Weex));
	  extend(A.prototype, { attr: attr });
	
	  Weex.registerComponent('a', A);
	}
	
	exports.default = { init: init };

/***/ },
/* 184 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var ID_PREFIX = 'weex_embed_';
	
	var getRandom = void 0;
	
	function _generateId() {
	  return ID_PREFIX + getRandom(10);
	}
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('div');
	    node.id = this.id;
	    node.style.overflow = 'scroll';
	    return node;
	  },
	  initWeex: function initWeex() {
	    this.id = _generateId();
	    this.node.id = this.id;
	    var config = {
	      appId: this.id,
	      source: this.source,
	      bundleUrl: this.source,
	      loader: this.loader,
	      jsonpCallback: this.jsonpCallback,
	      width: this.node.getBoundingClientRect().width,
	      rootId: this.id,
	      embed: true
	    };
	    window.weex.init(config);
	  },
	  destroyWeex: function destroyWeex() {
	    this.id && window.destroyInstance(this.id);
	    // TODO: unbind events and clear doms.
	    this.node.innerHTML = '';
	  },
	  reloadWeex: function reloadWeex() {
	    if (this.id) {
	      this.destroyWeex();
	      this.id = null;
	      this.node.id = null;
	      this.node.innerHTML = '';
	    }
	    this.initWeex();
	  }
	};
	
	// not recommended, because of the leak of memory.
	var attr = {
	  src: function src(value) {
	    this.source = value;
	    this.reloadWeex();
	  }
	};
	
	function init(Weex) {
	  var Component = Weex.Component;
	  var extend = Weex.utils.extend;
	  getRandom = Weex.utils.getRandom;
	
	  function Embed(data, nodeType) {
	    var attr = data.attr;
	    if (attr) {
	      this.source = attr.src;
	      this.loader = attr.loader || 'xhr';
	      this.jsonpCallback = attr.jsonpCallback;
	    }
	    Component.call(this, data, nodeType);
	  }
	
	  Embed.prototype = Object.create(Component.prototype);
	  extend(Embed.prototype, proto);
	  extend(Embed.prototype, { attr: attr });
	
	  Weex.registerComponent('embed', Embed);
	}
	
	exports.default = { init: init };

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/* global CSSRule */
	
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	__webpack_require__(186);
	
	var loopArray = void 0,
	    getRgb = void 0;
	
	function getStyleSheet(spinner) {
	  if (spinner.styleSheet) {
	    return;
	  }
	  var styles = document.styleSheets;
	  var i = void 0,
	      l = void 0,
	      j = void 0,
	      m = void 0;
	  /* eslint-disable no-labels */
	  outer: for (i = 0, l = styles.length; i < l; i++) {
	    var rules = styles[i].rules;
	    for (j = 0, m = rules.length; j < m; j++) {
	      var item = rules.item(j);
	      if ((item.type === CSSRule.KEYFRAMES_RULE || item.type === CSSRule.WEBKIT_KEYFRAMES_RULE) && item.name === 'spinner') {
	        break outer;
	      }
	    }
	  }
	  /* eslint-enable no-labels */
	  spinner.styleSheet = styles[i];
	}
	
	function setKeyframeColor(spinner, val) {
	  getStyleSheet(spinner);
	  var keyframeRules = computeKeyFrameRules(val);
	  var rules = spinner.styleSheet.rules;
	  for (var i = 0, l = rules.length; i < l; i++) {
	    var item = rules.item(i);
	    if ((item.type === CSSRule.KEYFRAMES_RULE || item.type === CSSRule.WEBKIT_KEYFRAMES_RULE) && item.name === 'spinner') {
	      var cssRules = item.cssRules;
	      for (var j = 0, m = cssRules.length; j < m; j++) {
	        var keyframe = cssRules[j];
	        if (keyframe.type === CSSRule.KEYFRAME_RULE || keyframe.type === CSSRule.WEBKIT_KEYFRAME_RULE) {
	          keyframe.style.boxShadow = keyframeRules[j];
	        }
	      }
	    }
	  }
	}
	
	function computeKeyFrameRules(rgb) {
	  if (!rgb) {
	    return;
	  }
	  var scaleArr = ['0em -2.6em 0em 0em', '1.8em -1.8em 0 0em', '2.5em 0em 0 0em', '1.75em 1.75em 0 0em', '0em 2.5em 0 0em', '-1.8em 1.8em 0 0em', '-2.6em 0em 0 0em', '-1.8em -1.8em 0 0em'];
	  var colorArr = ['1', '0.2', '0.2', '0.2', '0.2', '0.2', '0.5', '0.7'].map(function (e) {
	    return 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + e + ')';
	  });
	  var rules = [];
	
	  var _loop = function _loop(i) {
	    var tmpColorArr = loopArray(colorArr, i, 'r');
	    rules.push(scaleArr.map(function (scaleStr, i) {
	      return scaleStr + ' ' + tmpColorArr[i];
	    }).join(', '));
	  };
	
	  for (var i = 0; i < scaleArr.length; i++) {
	    _loop(i);
	  }
	  return rules;
	}
	
	var proto = {
	  create: function create() {
	    var node = document.createElement('div');
	    node.classList.add('weex-container', 'weex-spinner-wrap');
	    this.spinner = document.createElement('div');
	    this.spinner.classList.add('weex-element', 'weex-spinner');
	    node.appendChild(this.spinner);
	    return node;
	  }
	};
	
	var style = {
	  color: function color(val) {
	    var rgb = getRgb(val);
	    if (!rgb) {
	      return console.error('[web-render] invalid color value:', val);
	    }
	    setKeyframeColor(this, rgb);
	  }
	};
	
	// Spinner.prototype.updateStyle = function (style) {
	//   Atomic.prototype.updateStyle.call(this, style)
	//   if (style && style.color) {
	//     this.setKeyframeColor(global.weex.utils.getRgb(this.node.style.color))
	//   }
	// }
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	  getRgb = Weex.utils.getRgb;
	  loopArray = Weex.utils.loopArray;
	
	  function Spinner(data) {
	    Atomic.call(this, data);
	  }
	  Spinner.prototype = Object.create(Atomic.prototype);
	  extend(Spinner.prototype, proto);
	  extend(Spinner.prototype, {
	    style: extend(Object.create(Atomic.prototype.style), style)
	  });
	
	  Weex.registerComponent('spinner', Spinner);
	  Weex.registerComponent('loading-indicator', Spinner);
	}
	
	exports.default = { init: init };

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(187);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./spinner.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./spinner.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-spinner-wrap {\n  width: 1.013333rem; /* 76px */\n  height: 1.013333rem;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n  align-items: center;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  justify-content: center;\n  overflow: visible;\n}\n\n.weex-spinner {\n  font-size: 0.16rem; /* 12px */\n  width: 1em;\n  height: 1em;\n  border-radius: 50%;\n  position: relative;\n  text-indent: -9999em;\n  -webkit-animation: spinner 1.1s infinite ease;\n  animation: spinner 1.1s infinite ease;\n  -webkit-transform: translateZ(0);\n  -ms-transform: translateZ(0);\n  transform: translateZ(0);\n}\n@-webkit-keyframes spinner {\n  0%,\n  100% {\n    box-shadow: 0em -2.6em 0em 0em #ffffff, 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.5), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.7);\n  }\n  12.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.7), 1.8em -1.8em 0 0em #ffffff, 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.5);\n  }\n  25% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.5), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.7), 2.5em 0em 0 0em #ffffff, 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  37.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.5), 2.5em 0em 0 0em rgba(255, 255, 255, 0.7), 1.75em 1.75em 0 0em #ffffff, 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  50% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.5), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.7), 0em 2.5em 0 0em #ffffff, -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  62.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.5), 0em 2.5em 0 0em rgba(255, 255, 255, 0.7), -1.8em 1.8em 0 0em #ffffff, -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  75% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.5), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.7), -2.6em 0em 0 0em #ffffff, -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  87.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.5), -2.6em 0em 0 0em rgba(255, 255, 255, 0.7), -1.8em -1.8em 0 0em #ffffff;\n  }\n}\n@keyframes spinner {\n  0%,\n  100% {\n    box-shadow: 0em -2.6em 0em 0em #ffffff, 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.5), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.7);\n  }\n  12.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.7), 1.8em -1.8em 0 0em #ffffff, 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.5);\n  }\n  25% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.5), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.7), 2.5em 0em 0 0em #ffffff, 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  37.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.5), 2.5em 0em 0 0em rgba(255, 255, 255, 0.7), 1.75em 1.75em 0 0em #ffffff, 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  50% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.5), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.7), 0em 2.5em 0 0em #ffffff, -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  62.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.5), 0em 2.5em 0 0em rgba(255, 255, 255, 0.7), -1.8em 1.8em 0 0em #ffffff, -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  75% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.5), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.7), -2.6em 0em 0 0em #ffffff, -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  87.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.5), -2.6em 0em 0 0em rgba(255, 255, 255, 0.7), -1.8em -1.8em 0 0em #ffffff;\n  }\n}\n", ""]);
	
	// exports


/***/ },
/* 188 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var isArray = void 0;
	
	function handleMsg(web, evt) {
	  var msg = evt.data;
	  if (typeof msg === 'string') {
	    try {
	      msg = JSON.parse(msg);
	    } catch (e) {}
	  }
	  if (!msg) {
	    return;
	  }
	  if (msg.type === 'weex') {
	    if (!isArray(msg.content)) {
	      return console.error('[h5-render] weex msg received by web component.' + ' msg.content should be a array:', msg.content);
	    }
	    callNative(web.getComponentManager().instanceId, msg.content);
	  }
	}
	
	function getProto(Weex) {
	  var Atomic = Weex.Atomic;
	  return {
	    create: function create() {
	      // Iframe's defect: can't use position:absolute and top, left, right,
	      // bottom all setting to zero and use margin to leave specified
	      // height for a blank area, and have to use 100% to fill the parent
	      // container, otherwise it will use a unwanted default size instead.
	      // Therefore a div as a iframe wrapper is needed here.
	      var node = document.createElement('div');
	      node.classList.add('weex-container');
	      this.web = document.createElement('iframe');
	      node.appendChild(this.web);
	      this.web.classList.add('weex-element');
	      this.web.style.width = '100%';
	      this.web.style.height = '100%';
	      this.web.style.border = 'none';
	      return node;
	    },
	    bindEvents: function bindEvents(evts) {
	      Atomic.prototype.bindEvents.call(this, evts);
	      var that = this;
	      this.web.addEventListener('load', function (e) {
	        that.dispatchEvent('pagefinish', {
	          url: that.web.src
	        });
	      });
	      window.addEventListener('message', handleMsg.bind(null, this));
	    },
	    goBack: function goBack() {
	      this.web.contentWindow.history.back();
	    },
	    goForward: function goForward() {
	      this.web.contentWindow.history.forward();
	    },
	    reload: function reload() {
	      this.web.contentWindow.location.reload();
	    }
	  };
	}
	
	var attr = {
	  src: function src(val) {
	    this.web.src = val;
	    setTimeout(function () {
	      this.dispatchEvent('pagestart', { url: val });
	    }.bind(this), 0);
	  }
	};
	
	function init(Weex) {
	  var Atomic = Weex.Atomic;
	  var extend = Weex.utils.extend;
	  isArray = Weex.utils.isArray;
	
	  // A component to import web pages, which works like
	  // a iframe element or a webview.
	  // attrs:
	  //   - src
	  // events:
	  //   - pagestart
	  //   - pagefinish
	  //   - error
	  function Web(data) {
	    Atomic.call(this, data);
	  }
	  Web.prototype = Object.create(Atomic.prototype);
	  extend(Web.prototype, getProto(Weex));
	  extend(Web.prototype, { attr: attr });
	
	  Weex.registerComponent('web', Web);
	}
	
	exports.default = { init: init };

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _event = __webpack_require__(190);
	
	var _event2 = _interopRequireDefault(_event);
	
	var _pageInfo = __webpack_require__(191);
	
	var _pageInfo2 = _interopRequireDefault(_pageInfo);
	
	var _stream = __webpack_require__(192);
	
	var _stream2 = _interopRequireDefault(_stream);
	
	var _modal = __webpack_require__(193);
	
	var _modal2 = _interopRequireDefault(_modal);
	
	var _animation = __webpack_require__(210);
	
	var _animation2 = _interopRequireDefault(_animation);
	
	var _webview = __webpack_require__(212);
	
	var _webview2 = _interopRequireDefault(_webview);
	
	var _navigator = __webpack_require__(213);
	
	var _navigator2 = _interopRequireDefault(_navigator);
	
	var _storage = __webpack_require__(214);
	
	var _storage2 = _interopRequireDefault(_storage);
	
	var _clipboard = __webpack_require__(215);
	
	var _clipboard2 = _interopRequireDefault(_clipboard);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.install(_event2.default);
	    Weex.install(_pageInfo2.default);
	    Weex.install(_stream2.default);
	    Weex.install(_modal2.default);
	    Weex.install(_animation2.default);
	    Weex.install(_webview2.default);
	    // Weex.install(timer)
	    Weex.install(_navigator2.default);
	    Weex.install(_storage2.default);
	    Weex.install(_clipboard2.default);
	  }
	};
	// import timer from './timer'

/***/ },
/* 190 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var event = {
	  /**
	   * openUrl
	   * @param  {string} url
	   */
	  openURL: function openURL(url) {
	    location.href = url;
	  }
	
	};
	
	var meta = {
	  event: [{
	    name: 'openURL',
	    args: ['string']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('event', event, meta);
	  }
	};

/***/ },
/* 191 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var pageInfo = {
	
	  setTitle: function setTitle(title) {
	    title = title || 'Weex HTML5';
	    try {
	      title = decodeURIComponent(title);
	    } catch (e) {}
	    document.title = title;
	  }
	};
	
	var meta = {
	  pageInfo: [{
	    name: 'setTitle',
	    args: ['string']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('pageInfo', pageInfo, meta);
	  }
	};

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global lib, XMLHttpRequest */
	/* deps: httpurl */
	
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	__webpack_require__(135);
	
	var utils = void 0;
	
	var jsonpCnt = 0;
	var ERROR_STATE = -1;
	
	var TYPE_JSON = 'application/json;charset=UTF-8';
	var TYPE_FORM = 'application/x-www-form-urlencoded';
	
	var REG_FORM = /^(?:[^&=]+=[^&=]+)(?:&[^&=]+=[^&=]+)*$/;
	
	function _jsonp(config, callback, progressCallback) {
	  var cbName = 'jsonp_' + ++jsonpCnt;
	  var url = void 0;
	
	  if (!config.url) {
	    console.error('[h5-render] config.url should be set in _jsonp for \'fetch\' API.');
	  }
	
	  global[cbName] = function (cb) {
	    return function (response) {
	      callback(response);
	      delete global[cb];
	    };
	  }(cbName);
	
	  var script = document.createElement('script');
	  try {
	    url = lib.httpurl(config.url);
	  } catch (err) {
	    console.error('[h5-render] invalid config.url in _jsonp for \'fetch\' API: ' + config.url);
	  }
	  url.params.callback = cbName;
	  script.type = 'text/javascript';
	  script.src = url.toString();
	  // script.onerror is not working on IE or safari.
	  // but they are not considered here.
	  script.onerror = function (cb) {
	    return function (err) {
	      console.error('[h5-render] unexpected error in _jsonp for \'fetch\' API', err);
	      callback(err);
	      delete global[cb];
	    };
	  }(cbName);
	  var head = document.getElementsByTagName('head')[0];
	  head.insertBefore(script, null);
	}
	
	function _xhr(config, callback, progressCallback) {
	  var xhr = new XMLHttpRequest();
	  xhr.responseType = config.type;
	  xhr.open(config.method, config.url, true);
	
	  var headers = config.headers || {};
	  for (var k in headers) {
	    xhr.setRequestHeader(k, headers[k]);
	  }
	
	  xhr.onload = function (res) {
	    callback({
	      status: xhr.status,
	      ok: xhr.status >= 200 && xhr.status < 300,
	      statusText: xhr.statusText,
	      data: xhr.response,
	      headers: xhr.getAllResponseHeaders().split('\n').reduce(function (obj, headerStr) {
	        var headerArr = headerStr.match(/(.+): (.+)/);
	        if (headerArr) {
	          obj[headerArr[1]] = headerArr[2];
	        }
	        return obj;
	      }, {})
	    });
	  };
	
	  if (progressCallback) {
	    xhr.onprogress = function (e) {
	      progressCallback({
	        readyState: xhr.readyState,
	        status: xhr.status,
	        length: e.loaded,
	        total: e.total,
	        statusText: xhr.statusText,
	        headers: xhr.getAllResponseHeaders().split('\n').reduce(function (obj, headerStr) {
	          var headerArr = headerStr.match(/(.+): (.+)/);
	          if (headerArr) {
	            obj[headerArr[1]] = headerArr[2];
	          }
	          return obj;
	        }, {})
	      });
	    };
	  }
	
	  xhr.onerror = function (err) {
	    console.error('[h5-render] unexpected error in _xhr for \'fetch\' API', err);
	    callback({
	      status: ERROR_STATE,
	      ok: false,
	      statusText: '',
	      data: '',
	      headers: {}
	    });
	  };
	
	  xhr.send(config.body);
	}
	
	var stream = {
	
	  /**
	   * sendHttp
	   * @deprecated
	   * Note: This API is deprecated. Please use stream.fetch instead.
	   * send a http request through XHR.
	   * @param  {obj} params
	   *  - method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'PATCH',
	   *  - url: url requested
	   * @param  {string} callbackId
	   */
	  sendHttp: function sendHttp(param, callbackId) {
	    if (typeof param === 'string') {
	      try {
	        param = JSON.parse(param);
	      } catch (e) {
	        return;
	      }
	    }
	    if ((typeof param === 'undefined' ? 'undefined' : _typeof(param)) !== 'object' || !param.url) {
	      return console.error('[h5-render] invalid config or invalid config.url for sendHttp API');
	    }
	
	    var sender = this.sender;
	    var method = param.method || 'GET';
	    var xhr = new XMLHttpRequest();
	    xhr.open(method, param.url, true);
	    xhr.onload = function () {
	      sender.performCallback(callbackId, this.responseText);
	    };
	    xhr.onerror = function (error) {
	      return console.error('[h5-render] unexpected error in sendHttp API', error);
	      // sender.performCallback(
	      //   callbackId,
	      //   new Error('unexpected error in sendHttp API')
	      // )
	    };
	    xhr.send();
	  },
	
	  /**
	   * fetch
	   * use stream.fetch to request for a json file, a plain text file or
	   * a arraybuffer for a file stream. (You can use Blob and FileReader
	   * API implemented by most modern browsers to read a arraybuffer.)
	   * @param  {object} options config options
	   *   - method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'PATCH'
	   *   - headers {obj}
	   *   - url {string}
	   *   - mode {string} 'cors' | 'no-cors' | 'same-origin' | 'navigate'
	   *   - body
	   *   - type {string} 'json' | 'jsonp' | 'text'
	   * @param  {string} callbackId
	   * @param  {string} progressCallbackId
	   */
	  fetch: function fetch(options, callbackId, progressCallbackId) {
	    var DEFAULT_METHOD = 'GET';
	    var DEFAULT_MODE = 'cors';
	    var DEFAULT_TYPE = 'text';
	
	    var methodOptions = ['GET', 'POST', 'PUT', 'DELETE', 'HEAD', 'PATCH'];
	    var modeOptions = ['cors', 'no-cors', 'same-origin', 'navigate'];
	    var typeOptions = ['text', 'json', 'jsonp', 'arraybuffer'];
	
	    // const fallback = false  // fallback from 'fetch' API to XHR.
	    var sender = this.sender;
	
	    var config = utils.extend({}, options);
	
	    // validate options.method
	    if (typeof config.method === 'undefined') {
	      config.method = DEFAULT_METHOD;
	      console.warn('[h5-render] options.method for \'fetch\' API has been set to ' + 'default value \'' + config.method + '\'');
	    } else if (methodOptions.indexOf((config.method + '').toUpperCase()) === -1) {
	      return console.error('[h5-render] options.method \'' + config.method + '\' for \'fetch\' API should be one of ' + methodOptions + '.');
	    }
	
	    // validate options.url
	    if (!config.url) {
	      return console.error('[h5-render] options.url should be set for \'fetch\' API.');
	    }
	
	    // validate options.mode
	    if (typeof config.mode === 'undefined') {
	      config.mode = DEFAULT_MODE;
	    } else if (modeOptions.indexOf((config.mode + '').toLowerCase()) === -1) {
	      return console.error('[h5-render] options.mode \'' + config.mode + '\' for \'fetch\' API should be one of ' + modeOptions + '.');
	    }
	
	    // validate options.type
	    if (typeof config.type === 'undefined') {
	      config.type = DEFAULT_TYPE;
	      console.warn('[h5-render] options.type for \'fetch\' API has been set to ' + 'default value \'' + config.type + '\'.');
	    } else if (typeOptions.indexOf((config.type + '').toLowerCase()) === -1) {
	      return console.error('[h5-render] options.type \'' + config.type + '\' for \'fetch\' API should be one of ' + typeOptions + '.');
	    }
	
	    // validate options.headers
	    config.headers = config.headers || {};
	    if (!utils.isPlainObject(config.headers)) {
	      return console.error('[h5-render] options.headers should be a plain object');
	    }
	
	    // validate options.body
	    var body = config.body;
	    if (!config.headers['Content-Type'] && body) {
	      if (utils.isPlainObject(body)) {
	        // is a json data
	        try {
	          config.body = JSON.stringify(body);
	          config.headers['Content-Type'] = TYPE_JSON;
	        } catch (e) {}
	      } else if (utils.getType(body) === 'string' && body.match(REG_FORM)) {
	        // is form-data
	        config.body = encodeURI(body);
	        config.headers['Content-Type'] = TYPE_FORM;
	      }
	    }
	
	    // validate options.timeout
	    config.timeout = parseInt(config.timeout, 10) || 2500;
	
	    var _callArgs = [config, function (res) {
	      sender.performCallback(callbackId, res);
	    }];
	    if (progressCallbackId) {
	      _callArgs.push(function (res) {
	        // Set 'keepAlive' to true for sending continuous callbacks
	        sender.performCallback(progressCallbackId, res, true);
	      });
	    }
	
	    if (config.type === 'jsonp') {
	      _jsonp.apply(this, _callArgs);
	    } else {
	      _xhr.apply(this, _callArgs);
	    }
	  }
	
	};
	
	var meta = {
	  stream: [{
	    name: 'sendHttp',
	    args: ['object', 'function']
	  }, {
	    name: 'fetch',
	    args: ['object', 'function', 'function']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    utils = Weex.utils;
	    Weex.registerApiModule('stream', stream, meta);
	  }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _modals = __webpack_require__(194);
	
	var _modals2 = _interopRequireDefault(_modals);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var msg = {
	
	  // duration: default is 0.8 seconds.
	  toast: function toast(config) {
	    _modals2.default.toast(config.message, config.duration);
	  },
	
	  // config:
	  //  - message: string
	  //  - okTitle: title of ok button
	  //  - callback
	  alert: function alert(config, callbackId) {
	    var sender = this.sender;
	    config.callback = function () {
	      sender.performCallback(callbackId);
	    };
	    _modals2.default.alert(config);
	  },
	
	  // config:
	  //  - message: string
	  //  - okTitle: title of ok button
	  //  - cancelTitle: title of cancel button
	  //  - callback
	  confirm: function confirm(config, callbackId) {
	    var sender = this.sender;
	    config.callback = function (val) {
	      sender.performCallback(callbackId, val);
	    };
	    _modals2.default.confirm(config);
	  },
	
	  // config:
	  //  - message: string
	  //  - okTitle: title of ok button
	  //  - cancelTitle: title of cancel button
	  //  - callback
	  prompt: function prompt(config, callbackId) {
	    var sender = this.sender;
	    config.callback = function (val) {
	      sender.performCallback(callbackId, val);
	    };
	    _modals2.default.prompt(config);
	  }
	};
	
	var meta = {
	  modal: [{
	    name: 'toast',
	    args: ['object']
	  }, {
	    name: 'alert',
	    args: ['object', 'function']
	  }, {
	    name: 'confirm',
	    args: ['object', 'function']
	  }, {
	    name: 'prompt',
	    args: ['object', 'function']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('modal', msg, meta);
	  }
	};

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Alert = __webpack_require__(195)
	var Confirm = __webpack_require__(201)
	var Prompt = __webpack_require__(204)
	var toast = __webpack_require__(207)
	
	var modal = {
	
	  toast: function (msg, duration) {
	    toast.push(msg, duration)
	  },
	
	  alert: function (config) {
	    new Alert(config).show()
	  },
	
	  prompt: function (config) {
	    new Prompt(config).show()
	  },
	
	  confirm: function (config) {
	    new Confirm(config).show()
	  }
	
	}
	
	!window.lib && (window.lib = {})
	window.lib.modal = modal
	
	module.exports = modal

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Modal = __webpack_require__(196)
	__webpack_require__(199)
	
	var CONTENT_CLASS = 'content'
	var MSG_CLASS = 'content-msg'
	var BUTTON_GROUP_CLASS = 'btn-group'
	var BUTTON_CLASS = 'btn'
	
	function Alert(config) {
	  this.msg = config.message || ''
	  this.callback = config.callback
	  this.okTitle = config.okTitle || 'OK'
	  Modal.call(this)
	  this.node.classList.add('amfe-alert')
	}
	
	Alert.prototype = Object.create(Modal.prototype)
	
	Alert.prototype.createNodeContent = function () {
	  var content = document.createElement('div')
	  content.classList.add(CONTENT_CLASS)
	  this.node.appendChild(content)
	
	  var msg = document.createElement('div')
	  msg.classList.add(MSG_CLASS)
	  msg.appendChild(document.createTextNode(this.msg))
	  content.appendChild(msg)
	
	  var buttonGroup = document.createElement('div')
	  buttonGroup.classList.add(BUTTON_GROUP_CLASS)
	  this.node.appendChild(buttonGroup)
	  var button = document.createElement('div')
	  button.classList.add(BUTTON_CLASS, 'alert-ok')
	  button.appendChild(document.createTextNode(this.okTitle))
	  buttonGroup.appendChild(button)
	}
	
	Alert.prototype.bindEvents = function () {
	  Modal.prototype.bindEvents.call(this)
	  var button = this.node.querySelector('.' + BUTTON_CLASS)
	  button.addEventListener('click', function () {
	    this.destroy()
	    this.callback && this.callback()
	  }.bind(this))
	}
	
	module.exports = Alert


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(197)
	
	// there will be only one instance of modal.
	var MODAL_WRAP_CLASS = 'amfe-modal-wrap'
	var MODAL_NODE_CLASS = 'amfe-modal-node'
	
	function Modal() {
	  this.wrap = document.querySelector(MODAL_WRAP_CLASS)
	  this.node = document.querySelector(MODAL_NODE_CLASS)
	  if (!this.wrap) {
	    this.createWrap()
	  }
	  if (!this.node) {
	    this.createNode()
	  }
	  this.clearNode()
	  this.createNodeContent()
	  this.bindEvents()
	}
	
	Modal.prototype = {
	
	  show: function () {
	    this.wrap.style.display = 'block'
	    this.node.classList.remove('hide')
	  },
	
	  destroy: function () {
	    document.body.removeChild(this.wrap)
	    document.body.removeChild(this.node)
	    this.wrap = null
	    this.node = null
	  },
	
	  createWrap: function () {
	    this.wrap = document.createElement('div')
	    this.wrap.className = MODAL_WRAP_CLASS
	    document.body.appendChild(this.wrap)
	  },
	
	  createNode: function () {
	    this.node = document.createElement('div')
	    this.node.classList.add(MODAL_NODE_CLASS, 'hide')
	    document.body.appendChild(this.node)
	  },
	
	  clearNode: function () {
	    this.node.innerHTML = ''
	  },
	
	  createNodeContent: function () {
	
	    // do nothing.
	    // child classes can override this method.
	  },
	
	  bindEvents: function () {
	    this.wrap.addEventListener('click', function (e) {
	      e.preventDefault()
	      e.stopPropagation()
	    })
	  }
	}
	
	module.exports = Modal


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(198);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./modal.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./modal.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-modal-wrap {\n  display: none;\n  position: fixed;\n  z-index: 999999999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: #000;\n  opacity: 0.5;\n}\n\n.amfe-modal-node {\n  position: fixed;\n  z-index: 9999999999;\n  top: 50%;\n  left: 50%;\n  width: 6.666667rem;\n  min-height: 2.666667rem;\n  border-radius: 0.066667rem;\n  -webkit-transform: translate(-50%, -50%);\n  transform: translate(-50%, -50%);\n  background-color: #fff;\n}\n.amfe-modal-node.hide {\n  display: none;\n}\n.amfe-modal-node .content {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n  align-items: center;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  justify-content: center;\n  width: 100%;\n  min-height: 1.866667rem;\n  box-sizing: border-box;\n  font-size: 0.32rem;\n  line-height: 0.426667rem;\n  padding: 0.213333rem;\n  border-bottom: 1px solid #ddd;\n}\n.amfe-modal-node .btn-group {\n  width: 100%;\n  height: 0.8rem;\n  font-size: 0.373333rem;\n  text-align: center;\n  margin: 0;\n  padding: 0;\n  border: none;\n}\n.amfe-modal-node .btn-group .btn {\n  box-sizing: border-box;\n  height: 0.8rem;\n  line-height: 0.8rem;\n  margin: 0;\n  padding: 0;\n  border: none;\n  background: none;\n}\n", ""]);
	
	// exports


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(200);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./alert.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./alert.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-alert .amfe-alert-ok {\n  width: 100%;\n}\n", ""]);
	
	// exports


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Modal = __webpack_require__(196)
	__webpack_require__(202)
	
	var CONTENT_CLASS = 'content'
	var MSG_CLASS = 'content-msg'
	var BUTTON_GROUP_CLASS = 'btn-group'
	var BUTTON_CLASS = 'btn'
	
	function Confirm(config) {
	  this.msg = config.message || ''
	  this.callback = config.callback
	  this.okTitle = config.okTitle || 'OK'
	  this.cancelTitle = config.cancelTitle || 'Cancel'
	  Modal.call(this)
	  this.node.classList.add('amfe-confirm')
	}
	
	Confirm.prototype = Object.create(Modal.prototype)
	
	Confirm.prototype.createNodeContent = function () {
	  var content = document.createElement('div')
	  content.classList.add(CONTENT_CLASS)
	  this.node.appendChild(content)
	
	  var msg = document.createElement('div')
	  msg.classList.add(MSG_CLASS)
	  msg.appendChild(document.createTextNode(this.msg))
	  content.appendChild(msg)
	
	  var buttonGroup = document.createElement('div')
	  buttonGroup.classList.add(BUTTON_GROUP_CLASS)
	  this.node.appendChild(buttonGroup)
	  var btnOk = document.createElement('div')
	  btnOk.appendChild(document.createTextNode(this.okTitle))
	  btnOk.classList.add('btn-ok', BUTTON_CLASS)
	  var btnCancel = document.createElement('div')
	  btnCancel.appendChild(document.createTextNode(this.cancelTitle))
	  btnCancel.classList.add('btn-cancel', BUTTON_CLASS)
	  buttonGroup.appendChild(btnOk)
	  buttonGroup.appendChild(btnCancel)
	  this.node.appendChild(buttonGroup)
	}
	
	Confirm.prototype.bindEvents = function () {
	  Modal.prototype.bindEvents.call(this)
	  var btnOk = this.node.querySelector('.' + BUTTON_CLASS + '.btn-ok')
	  var btnCancel = this.node.querySelector('.' + BUTTON_CLASS + '.btn-cancel')
	  btnOk.addEventListener('click', function () {
	    this.destroy()
	    this.callback && this.callback(this.okTitle)
	  }.bind(this))
	  btnCancel.addEventListener('click', function () {
	    this.destroy()
	    this.callback && this.callback(this.cancelTitle)
	  }.bind(this))
	}
	
	module.exports = Confirm


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(203);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./confirm.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./confirm.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-confirm .btn-group .btn {\n  float: left;\n  width: 50%;\n}\n.amfe-confirm .btn-group .btn.btn-ok {\n  border-right: 1px solid #ddd;\n}\n", ""]);
	
	// exports


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Modal = __webpack_require__(196)
	__webpack_require__(205)
	
	var CONTENT_CLASS = 'content'
	var MSG_CLASS = 'content-msg'
	var BUTTON_GROUP_CLASS = 'btn-group'
	var BUTTON_CLASS = 'btn'
	var INPUT_WRAP_CLASS = 'input-wrap'
	var INPUT_CLASS = 'input'
	
	function Prompt(config) {
	  this.msg = config.message || ''
	  this.defaultMsg = config.default || ''
	  this.callback = config.callback
	  this.okTitle = config.okTitle || 'OK'
	  this.cancelTitle = config.cancelTitle || 'Cancel'
	  Modal.call(this)
	  this.node.classList.add('amfe-prompt')
	}
	
	Prompt.prototype = Object.create(Modal.prototype)
	
	Prompt.prototype.createNodeContent = function () {
	
	  var content = document.createElement('div')
	  content.classList.add(CONTENT_CLASS)
	  this.node.appendChild(content)
	
	  var msg = document.createElement('div')
	  msg.classList.add(MSG_CLASS)
	  msg.appendChild(document.createTextNode(this.msg))
	  content.appendChild(msg)
	
	  var inputWrap = document.createElement('div')
	  inputWrap.classList.add(INPUT_WRAP_CLASS)
	  content.appendChild(inputWrap)
	  var input = document.createElement('input')
	  input.classList.add(INPUT_CLASS)
	  input.type = 'text'
	  input.autofocus = true
	  input.placeholder = this.defaultMsg
	  inputWrap.appendChild(input)
	
	  var buttonGroup = document.createElement('div')
	  buttonGroup.classList.add(BUTTON_GROUP_CLASS)
	  var btnOk = document.createElement('div')
	  btnOk.appendChild(document.createTextNode(this.okTitle))
	  btnOk.classList.add('btn-ok', BUTTON_CLASS)
	  var btnCancel = document.createElement('div')
	  btnCancel.appendChild(document.createTextNode(this.cancelTitle))
	  btnCancel.classList.add('btn-cancel', BUTTON_CLASS)
	  buttonGroup.appendChild(btnOk)
	  buttonGroup.appendChild(btnCancel)
	  this.node.appendChild(buttonGroup)
	}
	
	Prompt.prototype.bindEvents = function () {
	  Modal.prototype.bindEvents.call(this)
	  var btnOk = this.node.querySelector('.' + BUTTON_CLASS + '.btn-ok')
	  var btnCancel = this.node.querySelector('.' + BUTTON_CLASS + '.btn-cancel')
	  var that = this
	  btnOk.addEventListener('click', function () {
	    var val = document.querySelector('input').value
	    this.destroy()
	    this.callback && this.callback({
	      result: that.okTitle,
	      data: val
	    })
	  }.bind(this))
	  btnCancel.addEventListener('click', function () {
	    var val = document.querySelector('input').value
	    this.destroy()
	    this.callback && this.callback({
	      result: that.cancelTitle,
	      data: val
	    })
	  }.bind(this))
	}
	
	module.exports = Prompt


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(206);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./prompt.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./prompt.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-prompt .input-wrap {\n  box-sizing: border-box;\n  width: 100%;\n  margin-top: 0.133333rem;\n  // padding: 0.24rem 0.213333rem 0.213333rem;\n  height: 0.96rem;\n}\n.amfe-prompt .input-wrap .input {\n  box-sizing: border-box;\n  width: 100%;\n  height: 0.56rem;\n  line-height: 0.56rem;\n  font-size: 0.32rem;\n  border: 1px solid #999;\n}\n.amfe-prompt .btn-group .btn {\n  float: left;\n  width: 50%;\n}\n.amfe-prompt .btn-group .btn.btn-ok {\n  border-right: 1px solid #ddd;\n}\n", ""]);
	
	// exports


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(208)
	
	var queue = []
	var timer
	var isProcessing = false
	var toastWin
	var TOAST_WIN_CLASS_NAME = 'amfe-toast'
	
	var DEFAULT_DURATION = 0.8
	
	function showToastWindow(msg, callback) {
	  var handleTransitionEnd = function () {
	    toastWin.removeEventListener('transitionend', handleTransitionEnd)
	    callback && callback()
	  }
	  if (!toastWin) {
	    toastWin = document.createElement('div')
	    toastWin.classList.add(TOAST_WIN_CLASS_NAME, 'hide')
	    document.body.appendChild(toastWin)
	  }
	  toastWin.innerHTML = msg
	  toastWin.addEventListener('transitionend', handleTransitionEnd)
	  setTimeout(function () {
	    toastWin.classList.remove('hide')
	  }, 0)
	}
	
	function hideToastWindow(callback) {
	  var handleTransitionEnd = function () {
	    toastWin.removeEventListener('transitionend', handleTransitionEnd)
	    callback && callback()
	  }
	  if (!toastWin) {
	    return
	  }
	  toastWin.addEventListener('transitionend', handleTransitionEnd)
	  toastWin.classList.add('hide')
	}
	
	var toast = {
	
	  push: function (msg, duration) {
	    queue.push({
	      msg: msg,
	      duration: duration || DEFAULT_DURATION
	    })
	    this.show()
	  },
	
	  show: function () {
	    var that = this
	
	    // All messages had been toasted already, so remove the toast window,
	    if (!queue.length) {
	      toastWin && toastWin.parentNode.removeChild(toastWin)
	      toastWin = null
	      return
	    }
	
	    // the previous toast is not ended yet.
	    if (isProcessing) {
	      return
	    }
	    isProcessing = true
	
	    var toastInfo = queue.shift()
	    showToastWindow(toastInfo.msg, function () {
	      timer = setTimeout(function () {
	        timer = null
	        hideToastWindow(function () {
	          isProcessing = false
	          that.show()
	        })
	      }, toastInfo.duration * 1000)
	    })
	  }
	
	}
	
	module.exports = {
	  push: toast.push.bind(toast)
	}


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(209);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(5)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./toast.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./toast.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(4)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-toast {\n  font-size: 0.32rem;\n  line-height: 0.426667rem;\n  position: fixed;\n  box-sizing: border-box;\n  max-width: 80%;\n  bottom: 2.666667rem;\n  left: 50%;\n  padding: 0.213333rem;\n  background-color: #000;\n  color: #fff;\n  text-align: center;\n  opacity: 0.6;\n  transition: all 0.4s ease-in-out;\n  border-radius: 0.066667rem;\n  -webkit-transform: translateX(-50%);\n  transform: translateX(-50%);\n}\n\n.amfe-toast.hide {\n  opacity: 0;\n}\n", ""]);
	
	// exports


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _lib = __webpack_require__(211);
	
	var _data = {};
	
	var animation = {
	
	  /**
	   * transition
	   * @param  {string} ref        [description]
	   * @param  {obj} config     [description]
	   * @param  {string} callbackId [description]
	   */
	  transition: function transition(ref, config, callbackId) {
	    var refData = _data[ref];
	    var stylesKey = JSON.stringify(config.styles);
	    var weexInstance = this;
	    // If the same component perform a animation with exactly the same
	    // styles in a sequence with so short interval that the prev animation
	    // is still in playing, then the next animation should be ignored.
	    if (refData && refData[stylesKey]) {
	      return;
	    }
	    if (!refData) {
	      refData = _data[ref] = {};
	    }
	    refData[stylesKey] = true;
	
	    var component = this.getComponentManager().getComponent(ref);
	    return (0, _lib.transitionOnce)(component, config, function () {
	      // Remove the stylesKey in refData so that the same animation
	      // can be played again after current animation is already finished.
	      delete refData[stylesKey];
	      weexInstance.sender.performCallback(callbackId);
	    });
	  }
	};
	
	var meta = {
	  animation: [{
	    name: 'transition',
	    args: ['string', 'object', 'function']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('animation', animation, meta);
	  }
	};

/***/ },
/* 211 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	
	  /**
	   * config:
	   *   - styles
	   *   - duration [Number] milliseconds(ms)
	   *   - timingFunction [string]
	   *   - dealy [Number] milliseconds(ms)
	   */
	  transitionOnce: function transitionOnce(comp, config, callback) {
	    var styles = config.styles || {};
	    var duration = config.duration || 1000; // ms
	    var timingFunction = config.timingFunction || 'ease';
	    var delay = config.delay || 0; // ms
	    var transitionValue = 'all ' + duration + 'ms ' + timingFunction + ' ' + delay + 'ms';
	    var dom = comp.node;
	    var transitionEndHandler = function transitionEndHandler(e) {
	      e.stopPropagation();
	      dom.removeEventListener('webkitTransitionEnd', transitionEndHandler);
	      dom.removeEventListener('transitionend', transitionEndHandler);
	      dom.style.transition = '';
	      dom.style.webkitTransition = '';
	      callback();
	    };
	    dom.style.transition = transitionValue;
	    dom.style.webkitTransition = transitionValue;
	    dom.addEventListener('webkitTransitionEnd', transitionEndHandler);
	    dom.addEventListener('transitionend', transitionEndHandler);
	    comp.updateStyle(styles);
	  }
	
	};

/***/ },
/* 212 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var webview = {
	
	  // ref: ref of the web component.
	  goBack: function goBack(ref) {
	    var webComp = this.getComponentManager().getComponent(ref);
	    if (!webComp.goBack) {
	      console.error('error: the specified component has no method of' + ' goBack. Please make sure it is a webview component.');
	      return;
	    }
	    webComp.goBack();
	  },
	
	  // ref: ref of the web component.
	  goForward: function goForward(ref) {
	    var webComp = this.getComponentManager().getComponent(ref);
	    if (!webComp.goForward) {
	      console.error('error: the specified component has no method of' + ' goForward. Please make sure it is a webview component.');
	      return;
	    }
	    webComp.goForward();
	  },
	
	  // ref: ref of the web component.
	  reload: function reload(ref) {
	    var webComp = this.getComponentManager().getComponent(ref);
	    if (!webComp.reload) {
	      console.error('error: the specified component has no method of' + ' reload. Please make sure it is a webview component.');
	      return;
	    }
	    webComp.reload();
	  }
	
	};
	
	var meta = {
	  webview: [{
	    name: 'goBack',
	    args: ['string']
	  }, {
	    name: 'goForward',
	    args: ['string']
	  }, {
	    name: 'reload',
	    args: ['string']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('webview', webview, meta);
	  }
	};

/***/ },
/* 213 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var navigator = {
	
	  // config
	  //  - url: the url to push
	  //  - animated: this configuration item is native only
	  //  callback is not currently supported
	  push: function push(config, callbackId) {
	    window.location.href = config.url;
	    this.sender.performCallback(callbackId);
	  },
	
	  // config
	  //  - animated: this configuration item is native only
	  //  callback is note currently supported
	  pop: function pop(config, callbackId) {
	    window.history.back();
	    this.sender.performCallback(callbackId);
	  }
	
	};
	
	var meta = {
	  navigator: [{
	    name: 'push',
	    args: ['object', 'function']
	  }, {
	    name: 'pop',
	    args: ['object', 'function']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('navigator', navigator, meta);
	  }
	};

/***/ },
/* 214 */
/***/ function(module, exports) {

	/* global localStorage */
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var supportLocalStorage = typeof localStorage !== 'undefined';
	var SUCCESS = 'success';
	var FAILED = 'failed';
	var INVALID_PARAM = 'invalid_param';
	var UNDEFINED = 'undefined';
	
	var storage = {
	
	  /**
	   * When passed a key name and value, will add that key to the storage,
	   * or update that key's value if it already exists.
	   * @param {string} key
	   * @param {string} value
	   * @param {function} callbackId
	   */
	  setItem: function setItem(key, value, callbackId) {
	    if (!supportLocalStorage) {
	      console.error('your browser is not support localStorage yet.');
	      return;
	    }
	    var sender = this.sender;
	    if (!key || !value) {
	      sender.performCallback(callbackId, {
	        result: 'failed',
	        data: INVALID_PARAM
	      });
	      return;
	    }
	    try {
	      localStorage.setItem(key, value);
	      sender.performCallback(callbackId, {
	        result: SUCCESS,
	        data: UNDEFINED
	      });
	    } catch (e) {
	      // accept any exception thrown during a storage attempt as a quota error
	      sender.performCallback(callbackId, {
	        result: FAILED,
	        data: UNDEFINED
	      });
	    }
	  },
	
	  /**
	   * When passed a key name, will return that key's value.
	   * @param {string} key
	   * @param {function} callbackId
	   */
	  getItem: function getItem(key, callbackId) {
	    if (!supportLocalStorage) {
	      console.error('your browser is not support localStorage yet.');
	      return;
	    }
	    var sender = this.sender;
	    if (!key) {
	      sender.performCallback(callbackId, {
	        result: FAILED,
	        data: INVALID_PARAM
	      });
	      return;
	    }
	    var val = localStorage.getItem(key);
	    sender.performCallback(callbackId, {
	      result: val ? SUCCESS : FAILED,
	      data: val || UNDEFINED
	    });
	  },
	
	  /**
	   *When passed a key name, will remove that key from the storage.
	   * @param {string} key
	   * @param {function} callbackId
	   */
	  removeItem: function removeItem(key, callbackId) {
	    if (!supportLocalStorage) {
	      console.error('your browser is not support localStorage yet.');
	      return;
	    }
	    var sender = this.sender;
	    if (!key) {
	      sender.performCallback(callbackId, {
	        result: FAILED,
	        data: INVALID_PARAM
	      });
	      return;
	    }
	    localStorage.removeItem(key);
	    sender.performCallback(callbackId, {
	      result: SUCCESS,
	      data: UNDEFINED
	    });
	  },
	
	  /**
	   * Returns an integer representing the number of data items stored in the Storage object.
	   * @param {function} callbackId
	   */
	  length: function length(callbackId) {
	    if (!supportLocalStorage) {
	      console.error('your browser is not support localStorage yet.');
	      return;
	    }
	    var sender = this.sender;
	    var len = localStorage.length;
	    sender.performCallback(callbackId, {
	      result: SUCCESS,
	      data: len
	    });
	  },
	
	  /**
	   * Returns an array that contains all keys stored in Storage object.
	   * @param {function} callbackId
	   */
	  getAllKeys: function getAllKeys(callbackId) {
	    if (!supportLocalStorage) {
	      console.error('your browser is not support localStorage yet.');
	      return;
	    }
	    var sender = this.sender;
	    var _arr = [];
	    for (var i = 0; i < localStorage.length; i++) {
	      _arr.push(localStorage.key(i));
	    }
	    sender.performCallback(callbackId, {
	      result: SUCCESS,
	      data: _arr
	    });
	  }
	};
	
	var meta = {
	  storage: [{
	    name: 'setItem',
	    args: ['string', 'string', 'function']
	  }, {
	    name: 'getItem',
	    args: ['string', 'function']
	  }, {
	    name: 'removeItem',
	    args: ['string', 'function']
	  }, {
	    name: 'length',
	    args: ['function']
	  }, {
	    name: 'getAllKeys',
	    args: ['function']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('storage', storage, meta);
	  }
	};

/***/ },
/* 215 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	
	AUCTION:
	taskQueue
	Clipboard.setString()  NOW not works, facing to user-act lose of taskQueue.
	
	works in Chrome Firefox Opera. but not in Safari.
	@see https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand#Browser_compatibility
	
	Clipboard.getString() unimplemented. There is no easy way to do paste from clipboard to js variable.
	
	So look out your app behavior, when downgrade to html5 render.
	Any idea is welcome.
	**/
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var WEEX_CLIPBOARD_ID = '__weex_clipboard_id__';
	
	var clipboard = {
	
	  getString: function getString(callbackId) {
	    // not supported in html5
	    console.log('clipboard.getString() is not supported now.');
	  },
	
	  setString: function setString(text) {
	    // not support safari
	    if (typeof text === 'string' && text !== '' && document.execCommand) {
	      var tempInput = element();
	      tempInput.value = text;
	
	      tempInput.select();
	      document.execCommand('copy');
	      // var out = document.execCommand('copy');
	      // console.log("execCommand out is " + out);
	      tempInput.value = '';
	      tempInput.blur();
	    } else {
	      console.log('only support string input now');
	    }
	  }
	
	};
	
	function element() {
	  var tempInput = document.getElementById(WEEX_CLIPBOARD_ID);
	  if (tempInput === undefined) {
	    tempInput = document.createElement('input');
	    tempInput.setAttribute('id', WEEX_CLIPBOARD_ID);
	    tempInput.style.cssText = 'height:1px;width:1px;border:none;';
	    // tempInput.style.cssText = "height:40px;width:300px;border:solid;"
	    document.body.appendChild(tempInput);
	  }
	  return tempInput;
	}
	
	var meta = {
	  clipboard: [{
	    name: 'getString',
	    args: ['function']
	  }, {
	    name: 'setString',
	    args: ['string']
	  }]
	};
	
	exports.default = {
	  init: function init(Weex) {
	    Weex.registerApiModule('clipboard', clipboard, meta);
	  }
	};

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMWZkMTkyNmFmNjlmZWMzZjhjZTUiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL3JlbmRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL3JlbmRlci9zdHlsZS9iYXNlLmNzcz8wNmI0Iiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvcmVuZGVyL3N0eWxlL2Jhc2UuY3NzIiwid2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvcnVudGltZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL3J1bnRpbWUvc2hhcmVkLmpzIiwid2VicGFjazovLy8uL2h0bWw1L3NoYXJlZC91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9zaGFyZWQvcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1zcGVjaWVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL3J1bnRpbWUvaW5pdC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL3J1bnRpbWUvY29uZmlnLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvcnVudGltZS9kZWZhdWx0L2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvcnVudGltZS9zdGF0aWMvY3JlYXRlLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvcnVudGltZS9hcHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9ydW50aW1lL2FwcC9jdHJsL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvcnVudGltZS9hcHAvY3RybC9pbml0LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC91dGlsL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvdXRpbHMvZnJhbWVVcGRhdGVyLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvdXRpbHMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9ydW50aW1lL2FwcC9idW5kbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9ydW50aW1lL2FwcC9idW5kbGUvYm9vdHN0cmFwLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2RlZmF1bHQvdm0vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC9jb3JlL3N0YXRlLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2RlZmF1bHQvY29yZS93YXRjaGVyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9kZWZhdWx0L2NvcmUvZGVwLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2RlZmF1bHQvY29yZS9vYnNlcnZlci5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9kZWZhdWx0L2NvcmUvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC92bS9jb21waWxlci5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9kZWZhdWx0L3ZtL2RpcmVjdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9kZWZhdWx0L2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9kZWZhdWx0L3ZtL2RvbS1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC92bS9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC9hcHAvcmVnaXN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC9hcHAvYnVuZGxlL21pc2MuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC9hcHAvYnVuZGxlL2RlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9kZWZhdWx0L2FwcC9jdHJsL21pc2MuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC9hcHAvaW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC9hcHAvZGlmZmVyLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2RlZmF1bHQvc3RhdGljL21hcC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9kZWZhdWx0L3N0YXRpYy9saWZlLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2RlZmF1bHQvc3RhdGljL3JlZ2lzdGVyLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2RlZmF1bHQvc3RhdGljL2JyaWRnZS5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9kZWZhdWx0L3N0YXRpYy9taXNjLmpzIiwid2VicGFjazovLy8uL2h0bWw1L3Zkb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvZGVmYXVsdC9hcGkvbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2RvbS9jb21wb25lbnRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZG9tL2FwcGVhcldhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9yZW5kZXIvY29uZmlnLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvcmVuZGVyL2xvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2JyaWRnZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2JyaWRnZS9wcm90b2NvbC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2JyaWRnZS9yZWNlaXZlci5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2JyaWRnZS9zZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9iYXNlL2NvbXBvbmVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2RvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2Jhc2UvY29tcG9uZW50L29wZXJhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9iYXNlL2NvbXBvbmVudC92YWx1ZUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2Jhc2UvY29tcG9uZW50L3Bvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvYmFzZS9jb21wb25lbnQvc3RpY2t5LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvYmFzZS9jb21wb25lbnQvZmxleGJveC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2Jhc2UvY29tcG9uZW50L2xhenlsb2FkLmpzIiwid2VicGFjazovLy8uL34vbGF6eWltZy9zcmMvYWRhcHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xhenlpbWcvfi9hcHBlYXJqcy9zcmMvYXBwZWFyLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvYmFzZS9hdG9taWMuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9yZW5kZXIvcmVnaXN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9lbnZkL2J1aWxkL2VudmQuY29tbW9uLmpzIiwid2VicGFjazovLy8uL34vaHR0cHVybC9idWlsZC9odHRwdXJsLmNvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL3JlbmRlci9nZXN0dXJlLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvYmFzZS9yb290LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvYmFzZS9kaXYuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL2ltYWdlL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvaW1hZ2UvaW1hZ2UuY3NzPzhlNWQiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9pbWFnZS9pbWFnZS5jc3MiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy90ZXh0LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvbGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvbGlzdC92bGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvbGlzdC9saXN0LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9zY3JvbGxhYmxlLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9zY3JvbGxhYmxlLmNzcz9hZmUxIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9zY3JvbGxhYmxlLmNzcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvc2Nyb2xsLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9tb3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL2xpc3QvaGxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL3Njcm9sbGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9yZWZyZXNoL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9yZWZyZXNoL3JlZnJlc2guY3NzPzUxNjQiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL3JlZnJlc2gvcmVmcmVzaC5jc3MiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL2xvYWRpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL2xvYWRpbmcvbG9hZGluZy5jc3M/MzhhMSIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvbG9hZGluZy9sb2FkaW5nLmNzcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NsaWRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NsaWRlci9jYXJyb3VzZWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jdWJpY2Jlemllci9idWlsZC9jdWJpY2Jlemllci5jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9hbmltYXRpb25qcy9idWlsZC9hbmltYXRpb24uY29tbW9uLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2xpZGVyL2NhcnJvdXNlbC5jc3M/M2MwMSIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NsaWRlci9jYXJyb3VzZWwuY3NzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2xpZGVyL3RpbWVyLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2xpZGVyL3NsaWRlci5jc3M/M2Q3ZSIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NsaWRlci9zbGlkZXIuY3NzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvaW5kaWNhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvaW5kaWNhdG9yL2luZGljYXRvci5jc3M/MTI5NCIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL2luZGljYXRvci9pbmRpY2F0b3IuY3NzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvdGFiaGVhZGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvdGFiaGVhZGVyL3RhYmhlYWRlci5jc3M/YTIwZCIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3RhYmhlYWRlci90YWJoZWFkZXIuY3NzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvaW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy92aWRlby9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3ZpZGVvL3ZpZGVvLmNzcz85MjU2Iiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvdmlkZW8vdmlkZW8uY3NzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc3dpdGNoL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc3dpdGNoL3N3aXRjaC5jc3M/MzRkNCIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3N3aXRjaC9zd2l0Y2guY3NzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvYS5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL2VtYmVkLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc3Bpbm5lci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NwaW5uZXIvc3Bpbm5lci5jc3M/MWRlMiIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NwaW5uZXIvc3Bpbm5lci5jc3MiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy93ZWIuanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvYXBpL2luZGV4LmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2FwaS9ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvcGFnZUluZm8uanMiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvYXBpL3N0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvbW9kYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tb2RhbHMvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbW9kYWxzL3NyYy9hbGVydC5qcyIsIndlYnBhY2s6Ly8vLi9+L21vZGFscy9zcmMvbW9kYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tb2RhbHMvc3R5bGVzL21vZGFsLmNzcz82YzZkIiwid2VicGFjazovLy8uL34vbW9kYWxzL3N0eWxlcy9tb2RhbC5jc3MiLCJ3ZWJwYWNrOi8vLy4vfi9tb2RhbHMvc3R5bGVzL2FsZXJ0LmNzcz9iZWFmIiwid2VicGFjazovLy8uL34vbW9kYWxzL3N0eWxlcy9hbGVydC5jc3MiLCJ3ZWJwYWNrOi8vLy4vfi9tb2RhbHMvc3JjL2NvbmZpcm0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9tb2RhbHMvc3R5bGVzL2NvbmZpcm0uY3NzPzBjOTIiLCJ3ZWJwYWNrOi8vLy4vfi9tb2RhbHMvc3R5bGVzL2NvbmZpcm0uY3NzIiwid2VicGFjazovLy8uL34vbW9kYWxzL3NyYy9wcm9tcHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tb2RhbHMvc3R5bGVzL3Byb21wdC5jc3M/ZDE1YyIsIndlYnBhY2s6Ly8vLi9+L21vZGFscy9zdHlsZXMvcHJvbXB0LmNzcyIsIndlYnBhY2s6Ly8vLi9+L21vZGFscy9zcmMvdG9hc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tb2RhbHMvc3R5bGVzL3RvYXN0LmNzcz9lMTJmIiwid2VicGFjazovLy8uL34vbW9kYWxzL3N0eWxlcy90b2FzdC5jc3MiLCJ3ZWJwYWNrOi8vLy4vaHRtbDUvYnJvd3Nlci9leHRlbmQvYXBpL2FuaW1hdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvYW5pbWF0aW9uL2xpYi5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvd2Vidmlldy5qcyIsIndlYnBhY2s6Ly8vLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvbmF2aWdhdG9yLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2FwaS9zdG9yYWdlLmpzIiwid2VicGFjazovLy8uL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2FwaS9jbGlwYm9hcmQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBOzs7Ozs7QUFFQTs7OztBQUtBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7OztBQUVBLGtCQUFLLE9BQUw7QUFDQSxrQkFBSyxPQUFMO0FBQ0Esa0JBQUssT0FBTDtBQUNBLGtCQUFLLE9BQUw7Ozs7Ozs7Ozs7QUNiQTs7Ozs7bUJBMER3QixJOztBQXhEeEI7O0FBRUE7O0FBRUE7Ozs7QUFDQTs7QUFDQTs7S0FBWSxLOztBQUNaOztBQUNBOzs7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QUEyQkEsVUFBUyxPQUFULEdBQW9CO0FBQ2xCLE9BQUksWUFBWSxTQUFTLGNBQVQsQ0FBd0IsaUJBQXhCLENBQWhCO0FBQ0EsT0FBSSxjQUFjLFNBQWxCLEVBQTZCO0FBQzNCLGlCQUFZLFNBQVMsYUFBVCxDQUF1QixPQUF2QixDQUFaO0FBQ0EsZUFBVSxZQUFWLENBQXVCLElBQXZCLEVBQTZCLGlCQUE3QjtBQUNBLGVBQVUsS0FBVixDQUFnQixPQUFoQixHQUEwQixtQ0FBMUI7O0FBRUEsY0FBUyxJQUFULENBQWMsV0FBZCxDQUEwQixTQUExQjtBQUNEO0FBQ0QsVUFBTyxTQUFQO0FBQ0Q7O0FBRUQsS0FBTSxPQUFPO0FBQ1gsY0FBVyxDQUFDO0FBQ1YsV0FBTSxXQURJO0FBRVYsV0FBTSxDQUFDLFVBQUQ7QUFGSSxJQUFELEVBR1I7QUFDRCxXQUFNLFdBREw7QUFFRCxXQUFNLENBQUMsUUFBRDtBQUZMLElBSFE7QUFEQSxFQUFiOzttQkFVZTtBQUNiLFNBQU0sY0FBVSxJQUFWLEVBQWdCO0FBQ3BCLFVBQUssaUJBQUwsQ0FBdUIsV0FBdkIsRUFBb0MsU0FBcEMsRUFBK0MsSUFBL0M7QUFDRDtBQUhZLEUiLCJmaWxlIjoiYnJvd3Nlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgMWZkMTkyNmFmNjlmZWMzZjhjZTVcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IFdlZXggZnJvbSAnLi9yZW5kZXInXG5cbi8qKlxuICogaW5zdGFsbCBjb21wb25lbnRzIGFuZCBBUElzXG4gKi9cbmltcG9ydCByb290IGZyb20gJy4vYmFzZS9yb290J1xuaW1wb3J0IGRpdiBmcm9tICcuL2Jhc2UvZGl2J1xuaW1wb3J0IGNvbXBvbmVudHMgZnJvbSAnLi9leHRlbmQvY29tcG9uZW50cydcbmltcG9ydCBhcGkgZnJvbSAnLi9leHRlbmQvYXBpJ1xuXG5XZWV4Lmluc3RhbGwocm9vdClcbldlZXguaW5zdGFsbChkaXYpXG5XZWV4Lmluc3RhbGwoY29tcG9uZW50cylcbldlZXguaW5zdGFsbChhcGkpXG5cbmV4cG9ydCBkZWZhdWx0IFdlZXhcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9pbmRleC5qc1xuICoqLyIsIi8qIGdsb2JhbCBsaWIsIFdlYlNvY2tldCAqL1xuXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0ICcuL3N0eWxlL2Jhc2UuY3NzJ1xuXG5pbXBvcnQgJy4uL3J1bnRpbWUnXG5cbmltcG9ydCBjb25maWcgZnJvbSAnLi9jb25maWcnXG5pbXBvcnQgeyBsb2FkIH0gZnJvbSAnLi9sb2FkZXInXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IFNlbmRlciwgcmVjZWl2ZXIgfSBmcm9tICcuLi9icmlkZ2UnXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL2Jhc2UvY29tcG9uZW50J1xuaW1wb3J0IEF0b21pYyBmcm9tICcuLi9iYXNlL2F0b21pYydcbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4uL2RvbS9jb21wb25lbnRNYW5hZ2VyJ1xuaW1wb3J0IHsgYmluZCBhcyBiaW5kUmVnaXN0ZXIgfSBmcm9tICcuL3JlZ2lzdGVyJ1xuXG5pbXBvcnQgJ2VudmQnXG5pbXBvcnQgJ2h0dHB1cmwnXG5cbi8vIGdlc3R1cmVcbmltcG9ydCAnLi9nZXN0dXJlJ1xuXG5jb25zdCBERUZBVUxUX0RFU0lHTl9XSURUSCA9IDc1MFxuY29uc3QgREVGQVVMVF9TQ0FMRSA9IHdpbmRvdy5pbm5lcldpZHRoIC8gREVGQVVMVF9ERVNJR05fV0lEVEhcbmNvbnN0IERFRkFVTFRfUk9PVF9JRCA9ICd3ZWV4J1xuY29uc3QgREVGQVVMVF9KU09OUF9DQUxMQkFDS19OQU1FID0gJ3dlZXhKc29ucENhbGxiYWNrJ1xuXG5nbG9iYWwuV1hFbnZpcm9ubWVudCA9IHtcbiAgd2VleFZlcnNpb246IGNvbmZpZy53ZWV4VmVyc2lvbixcbiAgYXBwTmFtZTogbGliLmVudi5hbGlhcHAgPyBsaWIuZW52LmFsaWFwcC5hcHBuYW1lIDogbnVsbCxcbiAgYXBwVmVyc2lvbjogbGliLmVudi5hbGlhcHAgPyBsaWIuZW52LmFsaWFwcC52ZXJzaW9uLnZhbCA6IG51bGwsXG4gIHBsYXRmb3JtOiAnV2ViJyxcbiAgb3NOYW1lOiBsaWIuZW52LmJyb3dzZXIgPyBsaWIuZW52LmJyb3dzZXIubmFtZSA6IG51bGwsXG4gIG9zVmVyc2lvbjogbGliLmVudi5icm93c2VyID8gbGliLmVudi5icm93c2VyLnZlcnNpb24udmFsIDogbnVsbCxcbiAgZGV2aWNlV2lkdGg6IERFRkFVTFRfREVTSUdOX1dJRFRILFxuICBkZXZpY2VIZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCAvIERFRkFVTFRfU0NBTEVcbn1cblxuY29uc3QgX3dlZXhJbnN0YW5jZSA9IHt9XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuOyAoZnVuY3Rpb24gaW5pdGlhbGl6ZVdpdGhVcmxQYXJhbXMgKCkge1xuICAvLyBpbiBjYXNwZXJqcyB0aGUgcHJvdG9jb2wgaXMgZmlsZS5cbiAgaWYgKGxvY2F0aW9uLnByb3RvY29sLm1hdGNoKC9maWxlLykpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHBhcmFtcyA9IGxpYi5odHRwdXJsKGxvY2F0aW9uLmhyZWYpLnBhcmFtc1xuXG4gIC8vIHNldCBnbG9iYWwgJ2RlYnVnJyBjb25maWcgdG8gdHJ1ZSBpZiB0aGVyZSdzIGEgZGVidWcgZmxhZyBpbiBjdXJyZW50IHVybC5cbiAgY29uc3QgZGVidWcgPSBwYXJhbXNbJ2RlYnVnJ11cbiAgaWYgKGRlYnVnID09PSB0cnVlIHx8IGRlYnVnID09PSAndHJ1ZScpIHtcbiAgICBjb25maWcuZGVidWcgPSB0cnVlXG4gIH1cblxuICAhY29uZmlnLmRlYnVnICYmIChjb25zb2xlLmRlYnVnID0gbm9vcClcbn0pKClcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gV2VleCAob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV2VleCkpIHtcbiAgICByZXR1cm4gbmV3IFdlZXgob3B0aW9ucylcbiAgfVxuXG4gIC8vIFdpZHRoIG9mIHRoZSByb290IGNvbnRhaW5lci4gRGVmYXVsdCBpcyB3aW5kb3cuaW5uZXJXaWR0aC5cbiAgdGhpcy53aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgd2luZG93LmlubmVyV2lkdGhcbiAgdGhpcy5idW5kbGVVcmwgPSBvcHRpb25zLmJ1bmRsZVVybCB8fCBsb2NhdGlvbi5ocmVmXG4gIHRoaXMuaW5zdGFuY2VJZCA9IG9wdGlvbnMuYXBwSWRcbiAgdGhpcy5yb290SWQgPSBvcHRpb25zLnJvb3RJZCB8fCAoREVGQVVMVF9ST09UX0lEICsgdXRpbHMuZ2V0UmFuZG9tKDEwKSlcbiAgdGhpcy5kZXNpZ25XaWR0aCA9IG9wdGlvbnMuZGVzaWduV2lkdGggfHwgREVGQVVMVF9ERVNJR05fV0lEVEhcbiAgdGhpcy5qc29ucENhbGxiYWNrID0gb3B0aW9ucy5qc29ucENhbGxiYWNrIHx8IERFRkFVTFRfSlNPTlBfQ0FMTEJBQ0tfTkFNRVxuICB0aGlzLnNvdXJjZSA9IG9wdGlvbnMuc291cmNlXG4gIHRoaXMubG9hZGVyID0gb3B0aW9ucy5sb2FkZXJcbiAgdGhpcy5lbWJlZCA9IG9wdGlvbnMuZW1iZWRcblxuICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGFcbiAgdGhpcy5zY2FsZSA9IHRoaXMud2lkdGggLyB0aGlzLmRlc2lnbldpZHRoXG4gIHJlY2VpdmVyLmluaXQodGhpcylcbiAgdGhpcy5zZW5kZXIgPSBuZXcgU2VuZGVyKHRoaXMpXG5cbiAgX3dlZXhJbnN0YW5jZVt0aGlzLmluc3RhbmNlSWRdID0gdGhpc1xuXG4gIC8vIGxvYWQgYnVuZGxlLlxuICBsb2FkKHtcbiAgICBqc29ucENhbGxiYWNrOiB0aGlzLmpzb25wQ2FsbGJhY2ssXG4gICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICBsb2FkZXI6IHRoaXMubG9hZGVyXG4gIH0sIGZ1bmN0aW9uIChlcnIsIGFwcENvZGUpIHtcbiAgICBpZiAoIWVycikge1xuICAgICAgdGhpcy5jcmVhdGVBcHAoY29uZmlnLCBhcHBDb2RlKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2xvYWQgYnVuZGxlIGVycjonLCBlcnIpXG4gICAgfVxuICB9LmJpbmQodGhpcykpXG59XG5cbldlZXguaW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmICh1dGlscy5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgIG5ldyBXZWV4KGNvbmZpZylcbiAgICB9KVxuICB9XG4gIGVsc2UgaWYgKHV0aWxzLmdldFR5cGUob3B0aW9ucykgPT09ICdvYmplY3QnKSB7XG4gICAgbmV3IFdlZXgob3B0aW9ucylcbiAgfVxufVxuXG5XZWV4LmdldEluc3RhbmNlID0gZnVuY3Rpb24gKGluc3RhbmNlSWQpIHtcbiAgcmV0dXJuIF93ZWV4SW5zdGFuY2VbaW5zdGFuY2VJZF1cbn1cblxuV2VleC5wcm90b3R5cGUgPSB7XG5cbiAgY3JlYXRlQXBwOiBmdW5jdGlvbiAoY29uZmlnLCBhcHBDb2RlKSB7XG4gICAgbGV0IHJvb3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIHRoaXMucm9vdElkKVxuICAgIGlmICghcm9vdCkge1xuICAgICAgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICByb290LmlkID0gdGhpcy5yb290SWRcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocm9vdClcbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YW5jZSA9IHdpbmRvdy5jcmVhdGVJbnN0YW5jZShcbiAgICAgIHRoaXMuaW5zdGFuY2VJZCxcbiAgICAgIGFwcENvZGUsXG4gICAgICB7XG4gICAgICAgIGJ1bmRsZVVybDogdGhpcy5idW5kbGVVcmwsXG4gICAgICAgIGRlYnVnOiBjb25maWcuZGVidWdcbiAgICAgIH0sXG4gICAgICB0aGlzLmRhdGFcbiAgICApXG5cbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0gY3JlYXRlSW5zdGFuY2UgZXJyb3I6IGdldCB2b2lkIGZvciBpbnN0YW5jZS4nKVxuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0nLCBpbnN0YW5jZSlcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHRoaXMuYXBwSW5zdGFuY2UgPSByZXNcbiAgICAgICAgLy8gV2VleC5faW5zdGFuY2VzW3RoaXMuaW5zdGFuY2VJZF0gPSB0aGlzLnJvb3RcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0nLCBlcnIpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuYXBwSW5zdGFuY2UgPSBpbnN0YW5jZVxuXG4gICAgLy8gRG8gbm90IGRlc3Ryb3kgaW5zdGFuY2UgYmVmb3JlIHVubG9hZCwgYmVjYXVzZSBpbiBtb3N0IGJyb3dzZXJcbiAgICAvLyBwcmVzcyBiYWNrIGJ1dHRvbiB0byBiYWNrIHRvIHRoaXMgcGFnZSB3aWxsIG5vdCByZWZyZXNoXG4gICAgLy8gdGhlIHdpbmRvdyBhbmQgdGhlIGluc3RhbmNlIHdpbGwgbm90IGJlIHJlY3JlYXRlZCB0aGVuLlxuICAgIC8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoZSkge1xuICAgIC8vIH0pXG4gIH0sXG5cbiAgZ2V0Q29tcG9uZW50TWFuYWdlcjogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fY29tcG9uZW50TWFuYWdlcikge1xuICAgICAgdGhpcy5fY29tcG9uZW50TWFuYWdlciA9IENvbXBvbmVudE1hbmFnZXIuZ2V0SW5zdGFuY2UodGhpcy5pbnN0YW5jZUlkKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50TWFuYWdlclxuICB9LFxuXG4gIGdldFJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycgKyB0aGlzLnJvb3RJZClcbiAgfVxufVxuXG5XZWV4LnN0b3BUaGVXb3JsZCA9IGZ1bmN0aW9uIChpbnN0YW5jZUlkKSB7XG4gIGlmICghaW5zdGFuY2VJZCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhfd2VleEluc3RhbmNlKS5tYXAoZnVuY3Rpb24gKGluc3RhbmNlSWQpIHtcbiAgICAgIFdlZXguc3RvcFRoZVdvcmxkKGluc3RhbmNlSWQpXG4gICAgfSlcbiAgfVxuICB3aW5kb3cuZGVzdHJveUluc3RhbmNlKGluc3RhbmNlSWQpXG59XG5cbi8vIGZvciB3ZWV4LXRvb2xraXQuXG47IChmdW5jdGlvbiBzdGFydFJlZnJlc2hDb250cm9sbGVyICgpIHtcbiAgaWYgKGxvY2F0aW9uLnByb3RvY29sLm1hdGNoKC9maWxlLykpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAobG9jYXRpb24uc2VhcmNoLmluZGV4T2YoJ2hvdC1yZWxvYWRfY29udHJvbGxlcicpID09PSAtMSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh0eXBlb2YgV2ViU29ja2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuaW5mbygnYXV0byByZWZyZXNoIG5lZWQgV2ViU29ja2V0IHN1cHBvcnQnKVxuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGhvc3QgPSBsb2NhdGlvbi5ob3N0bmFtZVxuICBjb25zdCBwb3J0ID0gODA4MlxuICBjb25zdCBjbGllbnQgPSBuZXcgV2ViU29ja2V0KCd3czovLycgKyBob3N0ICsgJzonICsgcG9ydCArICcvJyxcbiAgICAnZWNoby1wcm90b2NvbCdcbiAgKVxuICBjbGllbnQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zb2xlLmxvZygncmVmcmVzaCBjb250cm9sbGVyIHdlYnNvY2tldCBjb25uZWN0aW9uIGVycm9yJylcbiAgfVxuICBjbGllbnQub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQ6IFxcJycgKyBlLmRhdGEgKyAnXFwnJylcbiAgICBpZiAoZS5kYXRhID09PSAncmVmcmVzaCcpIHtcbiAgICAgIGxvY2F0aW9uLnJlbG9hZCgpXG4gICAgfVxuICB9XG59KSgpXG5cbmJpbmRSZWdpc3RlcihXZWV4KVxuXG51dGlscy5leHRlbmQoV2VleCwge1xuICBDb21wb25lbnQsXG4gIEF0b21pYyxcbiAgQ29tcG9uZW50TWFuYWdlcixcbiAgdXRpbHMsXG4gIGNvbmZpZ1xufSlcblxuZ2xvYmFsLndlZXggPSBXZWV4XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvcmVuZGVyL2luZGV4LmpzXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9iYXNlLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9iYXNlLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jhc2UuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vaHRtbDUvYnJvd3Nlci9yZW5kZXIvc3R5bGUvYmFzZS5jc3NcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIioge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIHRleHQtc2l6ZS1hZGp1c3Q6IG5vbmU7XFxufVxcblxcbnVsLCBvbCB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbn1cXG5cXG4ud2VleC1jb250YWluZXIge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIC13ZWJraXQtYm94LW9yaWVudDogdmVydGljYWw7XFxuICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgZmxleC1zaHJpbms6IDA7XFxuICBhbGlnbi1pdGVtczogc3RyZXRjaDtcXG4gIGJveC1hbGlnbjogc3RyZXRjaDtcXG4gIGFsaWduLWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBib3JkZXI6IDAgc29saWQgYmxhY2s7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWluLXdpZHRoOiAwO1xcbn1cXG5cXG4ud2VleC1lbGVtZW50IHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBmbGV4LXNocmluazogMDtcXG4gIGJvcmRlcjogMCBzb2xpZCBibGFjaztcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICBtaW4td2lkdGg6IDA7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9odG1sNS9icm93c2VyL3JlbmRlci9zdHlsZS9iYXNlLmNzc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBzdHlsZXNJbkRvbSA9IHt9LFxyXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xyXG5cdFx0dmFyIG1lbW87XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRyZXR1cm4gbWVtbztcclxuXHRcdH07XHJcblx0fSxcclxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAvbXNpZSBbNi05XVxcYi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcclxuXHR9KSxcclxuXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xyXG5cdH0pLFxyXG5cdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxyXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxyXG5cdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW107XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcclxuXHRpZih0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcclxuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xyXG5cdH1cclxuXHJcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XHJcblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xyXG5cclxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgPGhlYWQ+LlxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XHJcblxyXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XHJcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XHJcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xyXG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XHJcblx0XHR9XHJcblx0XHRpZihuZXdMaXN0KSB7XHJcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XHJcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcclxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xyXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcclxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XHJcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRpZihkb21TdHlsZSkge1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzKGxpc3QpIHtcclxuXHR2YXIgc3R5bGVzID0gW107XHJcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XHJcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xyXG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XHJcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xyXG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XHJcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XHJcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcclxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcclxuXHRcdGVsc2VcclxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xyXG5cdH1cclxuXHRyZXR1cm4gc3R5bGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KSB7XHJcblx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xyXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xyXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XHJcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XHJcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xyXG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xyXG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XHJcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHR2YXIgaWR4ID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZUVsZW1lbnQpO1xyXG5cdGlmKGlkeCA+PSAwKSB7XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHRzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KTtcclxuXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKSB7XHJcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XHJcblx0bGlua0VsZW1lbnQucmVsID0gXCJzdHlsZXNoZWV0XCI7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcclxuXHRyZXR1cm4gbGlua0VsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlO1xyXG5cclxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcclxuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XHJcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKTtcclxuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxyXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcclxuXHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlRWxlbWVudC5ocmVmKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZShvYmopO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XHJcblx0XHRpZihuZXdPYmopIHtcclxuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZW1vdmUoKTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcclxuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcclxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xyXG5cclxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xyXG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2RlcztcclxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblxyXG5cdGlmKG1lZGlhKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXHJcblx0fVxyXG5cclxuXHRpZihzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcclxuXHR9IGVsc2Uge1xyXG5cdFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xyXG5cclxuXHRpZihzb3VyY2VNYXApIHtcclxuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XHJcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XHJcblx0fVxyXG5cclxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcclxuXHJcblx0dmFyIG9sZFNyYyA9IGxpbmtFbGVtZW50LmhyZWY7XHJcblxyXG5cdGxpbmtFbGVtZW50LmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG5cclxuXHRpZihvbGRTcmMpXHJcblx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgJy4vc2hhcmVkJ1xuLy8gaW1wb3J0IGluaXQgZnJvbSAnLi4vLi4vcnVudGltZS9pbml0J1xuaW1wb3J0IGluaXQgZnJvbSAnLi9pbml0J1xuaW1wb3J0IGZyYW1ld29ya3MgZnJvbSAnLi9jb25maWcnXG5pbXBvcnQgeyBEb2N1bWVudCwgRWxlbWVudCwgQ29tbWVudCB9IGZyb20gJy4uLy4uL3Zkb20nXG4vLyBpbXBvcnQgeyBzdWJ2ZXJzaW9uIH0gZnJvbSAnLi4vLi4vLi4vcGFja2FnZS5qc29uJ1xuaW1wb3J0ICogYXMgbWV0aG9kcyBmcm9tICcuLi8uLi9kZWZhdWx0L2FwaS9tZXRob2RzJ1xuaW1wb3J0IExpc3RlbmVyIGZyb20gJy4uL2RvbS9jb21wb25lbnRNYW5hZ2VyJ1xuXG5jb25zdCBjb25maWcgPSB7XG4gIERvY3VtZW50LCBFbGVtZW50LCBDb21tZW50LCBMaXN0ZW5lciwgZnJhbWV3b3JrcyxcbiAgc2VuZFRhc2tzICguLi5hcmdzKSB7XG4gICAgZ2xvYmFsLmNhbGxOYXRpdmUoLi4uYXJncylcbiAgfVxufVxuXG5jb25zdCBydW50aW1lID0gaW5pdChjb25maWcpXG5cbi8vIGNvbnN0IHsgbmF0aXZlLCB0cmFuc2Zvcm1lciB9ID0gc3VidmVyc2lvblxuXG5mb3IgKGNvbnN0IG1ldGhvZE5hbWUgaW4gcnVudGltZSkge1xuICBnbG9iYWxbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGNvbnN0IHJldCA9IHJ1bnRpbWVbbWV0aG9kTmFtZV0oLi4uYXJncylcbiAgICBpZiAocmV0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IocmV0LnRvU3RyaW5nKCkpXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG4vLyBnbG9iYWwuZnJhbWV3b3JrVmVyc2lvbiA9IG5hdGl2ZVxuLy8gZ2xvYmFsLnRyYW5zZm9ybVZlcnNpb24gPSB0cmFuc2Zvcm1lclxuXG4vKipcbiAqIHJlZ2lzdGVyIG1ldGhvZHNcbiAqL1xuZ2xvYmFsLnJlZ2lzdGVyTWV0aG9kcyhtZXRob2RzKVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvcnVudGltZS9pbmRleC5qc1xuICoqLyIsImltcG9ydCAnLi4vLi4vc2hhcmVkL3Byb21pc2UnXG4vLyBpbXBvcnQgJy4uLy4uL3NoYXJlZC9jb25zb2xlJ1xuXG5leHBvcnQge1xuICBleHRlbmQsXG4gIGRlZixcbiAgcmVtb3ZlLFxuICBoYXNPd24sXG4gIGJpbmQsXG4gIHRvQXJyYXksXG4gIGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0XG59IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscydcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9ydW50aW1lL3NoYXJlZC5qc1xuICoqLyIsIi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b1xuICogQHBhcmFtIHtPYmplY3R9IGZyb21cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kICh0YXJnZXQsIC4uLnNyYykge1xuICBpZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgLi4uc3JjKVxuICB9XG4gIGVsc2Uge1xuICAgIGNvbnN0IGZpcnN0ID0gc3JjLnNoaWZ0KClcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmaXJzdCkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBmaXJzdFtrZXldXG4gICAgfVxuICAgIGlmIChzcmMubGVuZ3RoKSB7XG4gICAgICBleHRlbmQodGFyZ2V0LCAuLi5zcmMpXG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXRcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHBhcmFtIHtCb29sZWFufSBbZW51bWVyYWJsZV1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufVxuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7Kn0gaXRlbVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIGNvbnN0IGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSlcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5leHBvcnQgZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHhcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBiaW5kIChmbiwgY3R4KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgIGNvbnN0IGwgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LWxpa2V9IGxpc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRdIC0gc3RhcnQgaW5kZXhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDBcbiAgbGV0IGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0XG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheShpKVxuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuY29uc3QgT0JKRUNUX1NUUklORyA9ICdbb2JqZWN0IE9iamVjdF0nXG5leHBvcnQgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkdcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvc2hhcmVkL3V0aWxzLmpzXG4gKiovIiwiLy8gZml4IFByb21pc2UgUHJvYmxlbSBvbiBKU0NvbnRleHQgb2YgaU9TN344XG4vLyBAc2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzU4NjZcbi8vIGdsb2JhbC5Qcm9taXNlID0gbnVsbFxucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJylcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJylcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJylcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZScpXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L3NoYXJlZC9wcm9taXNlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIHRlc3QgICAgPSB7fTtcbnRlc3RbcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuaWYodGVzdCArICcnICE9ICdbb2JqZWN0IHpdJyl7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG4gIH0sIHRydWUpO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fY29mLmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBzdG9yZSAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgU3ltYm9sICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbFxuICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgU1JDICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpXG4gICwgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJ1xuICAsICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR11cbiAgLCBUUEwgICAgICAgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywga2V5LCB2YWwsIHNhZmUpe1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmKE9ba2V5XSA9PT0gdmFsKXJldHVybjtcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYoTyA9PT0gZ2xvYmFsKXtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaWYoIXNhZmUpe1xuICAgICAgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihPW2tleV0pT1trZXldID0gdmFsO1xuICAgICAgZWxzZSBoaWRlKE8sIGtleSwgdmFsKTtcbiAgICB9XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faGlkZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XHJcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xyXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19mYWlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19oYXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fY29yZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qc1xuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZSAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSlcbiAgICAsIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZih0YXJnZXQpcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYoZXhwb3J0c1trZXldICE9IG91dCloaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZihJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dClleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qc1xuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzXG4gKiogbW9kdWxlIGlkID0gMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGRlc2NyaXB0b3IgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCl7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXHJcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXHJcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxyXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcclxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXHJcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cclxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XHJcblxyXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXHJcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcclxuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xyXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXHJcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxyXG4gICAgLCBndCAgICAgPSAnPidcclxuICAgICwgaWZyYW1lRG9jdW1lbnQ7XHJcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XHJcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxyXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XHJcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xyXG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XHJcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xyXG4gIGlmcmFtZURvY3VtZW50LndyaXRlKCc8c2NyaXB0PmRvY3VtZW50LkY9T2JqZWN0PC9zY3JpcHQnICsgZ3QpO1xyXG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XHJcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XHJcbiAgd2hpbGUoaS0tKWRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xyXG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xyXG4gIHZhciByZXN1bHQ7XHJcbiAgaWYoTyAhPT0gbnVsbCl7XHJcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XHJcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XHJcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcclxuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcclxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xyXG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XHJcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZFAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxyXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxyXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpe1xyXG4gIGFuT2JqZWN0KE8pO1xyXG4gIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXHJcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXHJcbiAgICAsIGkgPSAwXHJcbiAgICAsIFA7XHJcbiAgd2hpbGUobGVuZ3RoID4gaSlkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xyXG4gIHJldHVybiBPO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qc1xuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcclxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxyXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XHJcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxyXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXHJcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxyXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcclxuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcclxuICAgICwgaSAgICAgID0gMFxyXG4gICAgLCByZXN1bHQgPSBbXVxyXG4gICAgLCBrZXk7XHJcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xyXG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcclxuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XHJcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbiAqKiBtb2R1bGUgaWQgPSA0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXG4gKiogbW9kdWxlIGlkID0gNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtYXggICAgICAgPSBNYXRoLm1heFxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxyXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcclxuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuICoqIG1vZHVsZSBpZCA9IDUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXHJcbm1vZHVsZS5leHBvcnRzID0gKFxyXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXHJcbikuc3BsaXQoJywnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19odG1sLmpzXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaGFzID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXG4gKiogbW9kdWxlIGlkID0gNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXHJcbnZhciBoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXHJcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXHJcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxyXG4gICwgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oTyl7XHJcbiAgTyA9IHRvT2JqZWN0KE8pO1xyXG4gIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xyXG4gIGlmKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3Ipe1xyXG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xyXG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzXG4gKiogbW9kdWxlIGlkID0gNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGl0ZXJhdG9ycyAgICA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJylcbiAgLCByZWRlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGdsb2JhbCAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBJdGVyYXRvcnMgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCB3a3MgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCBJVEVSQVRPUiAgICAgID0gd2tzKCdpdGVyYXRvcicpXG4gICwgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKVxuICAsIEFycmF5VmFsdWVzICAgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmZvcih2YXIgY29sbGVjdGlvbnMgPSBbJ05vZGVMaXN0JywgJ0RPTVRva2VuTGlzdCcsICdNZWRpYUxpc3QnLCAnU3R5bGVTaGVldExpc3QnLCAnQ1NTUnVsZUxpc3QnXSwgaSA9IDA7IGkgPCA1OyBpKyspe1xuICB2YXIgTkFNRSAgICAgICA9IGNvbGxlY3Rpb25zW2ldXG4gICAgLCBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdXG4gICAgLCBwcm90byAgICAgID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZVxuICAgICwga2V5O1xuICBpZihwcm90byl7XG4gICAgaWYoIXByb3RvW0lURVJBVE9SXSloaWRlKHByb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIGlmKCFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBBcnJheVZhbHVlcztcbiAgICBmb3Ioa2V5IGluICRpdGVyYXRvcnMpaWYoIXByb3RvW2tleV0pcmVkZWZpbmUocHJvdG8sIGtleSwgJGl0ZXJhdG9yc1trZXldLCB0cnVlKTtcbiAgfVxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBJdGVyYXRvcnMgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCB0b0lPYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKVxuICAsIEFycmF5UHJvdG8gID0gQXJyYXkucHJvdG90eXBlO1xuaWYoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKXJlcXVpcmUoJy4vX2hpZGUnKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qc1xuICoqIG1vZHVsZSBpZCA9IDU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGNsYXNzb2YgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsICRleHBvcnQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaXNPYmplY3QgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuSW5zdGFuY2UgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBmb3JPZiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIHNldFByb3RvICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldFxuICAsIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKVxuICAsIHRhc2sgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBtaWNyb3Rhc2sgICAgICAgICAgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpXG4gICwgUFJPTUlTRSAgICAgICAgICAgID0gJ1Byb21pc2UnXG4gICwgVHlwZUVycm9yICAgICAgICAgID0gZ2xvYmFsLlR5cGVFcnJvclxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgJFByb21pc2UgICAgICAgICAgID0gZ2xvYmFsW1BST01JU0VdXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBpc05vZGUgICAgICAgICAgICAgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJ1xuICAsIGVtcHR5ICAgICAgICAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBJbnRlcm5hbCwgR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSAgICAgPSAkUHJvbWlzZS5yZXNvbHZlKDEpXG4gICAgICAsIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbihleGVjKXsgZXhlYyhlbXB0eSwgZW1wdHkpOyB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgc2FtZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24oYSwgYil7XG4gIC8vIHdpdGggbGlicmFyeSB3cmFwcGVyIHNwZWNpYWwgY2FzZVxuICByZXR1cm4gYSA9PT0gYiB8fCBhID09PSAkUHJvbWlzZSAmJiBiID09PSBXcmFwcGVyO1xufTtcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICByZXR1cm4gc2FtZUNvbnN0cnVjdG9yKCRQcm9taXNlLCBDKVxuICAgID8gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgOiBuZXcgR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IEdlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbigkJHJlc29sdmUsICQkcmVqZWN0KXtcbiAgICBpZihyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ICA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCAgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn07XG52YXIgcGVyZm9ybSA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIGV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4ge2Vycm9yOiBlfTtcbiAgfVxufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbihwcm9taXNlLCBpc1JlamVjdCl7XG4gIGlmKHByb21pc2UuX24pcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBvayAgICA9IHByb21pc2UuX3MgPT0gMVxuICAgICAgLCBpICAgICA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uKHJlYWN0aW9uKXtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWxcbiAgICAgICAgLCByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZVxuICAgICAgICAsIHJlamVjdCAgPSByZWFjdGlvbi5yZWplY3RcbiAgICAgICAgLCBkb21haW4gID0gcmVhY3Rpb24uZG9tYWluXG4gICAgICAgICwgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgaWYoIW9rKXtcbiAgICAgICAgICAgIGlmKHByb21pc2UuX2ggPT0gMilvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihoYW5kbGVyID09PSB0cnVlKXJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYoZG9tYWluKWRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKXtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpe1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbigpe1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3ZcbiAgICAgICwgYWJydXB0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmKGlzVW5oYW5kbGVkKHByb21pc2UpKXtcbiAgICAgIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoaXNOb2RlKXtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pe1xuICAgICAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWV9KTtcbiAgICAgICAgfSBlbHNlIGlmKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3Ipe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZihhYnJ1cHQpdGhyb3cgYWJydXB0LmVycm9yO1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgaWYocHJvbWlzZS5faCA9PSAxKXJldHVybiBmYWxzZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jXG4gICAgLCBpICAgICA9IDBcbiAgICAsIHJlYWN0aW9uO1xuICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXtcbiAgICByZWFjdGlvbiA9IGNoYWluW2krK107XG4gICAgaWYocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbigpe1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmKGlzTm9kZSl7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpe1xuICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92fSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZihwcm9taXNlLl9kKXJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZighcHJvbWlzZS5fYSlwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXNcbiAgICAsIHRoZW47XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYocHJvbWlzZSA9PT0gdmFsdWUpdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKXtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgICAgICB2YXIgd3JhcHBlciA9IHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgICRyZWplY3QuY2FsbCh7X3c6IHByb21pc2UsIF9kOiBmYWxzZX0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZighVVNFX05BVElWRSl7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcil7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpe1xuICAgICAgdmFyIHJlYWN0aW9uICAgID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayAgICAgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgICA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHRoaXMuX2EpdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHRoaXMuX3Mpbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKXtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHByb21pc2UgID0gbmV3IEludGVybmFsO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCAgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtQcm9taXNlOiAkUHJvbWlzZX0pO1xucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKXtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVqZWN0ICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpe1xuICAgIC8vIGluc3RhbmNlb2YgaW5zdGVhZCBvZiBpbnRlcm5hbCBzbG90IGNoZWNrIGJlY2F1c2Ugd2Ugc2hvdWxkIGZpeCBpdCB3aXRob3V0IHJlcGxhY2VtZW50IG5hdGl2ZSBQcm9taXNlIGNvcmVcbiAgICBpZih4IGluc3RhbmNlb2YgJFByb21pc2UgJiYgc2FtZUNvbnN0cnVjdG9yKHguY29uc3RydWN0b3IsIHRoaXMpKXJldHVybiB4O1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZXNvbHZlICA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICAkJHJlc29sdmUoeCk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpe1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSB0aGlzXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZXNvbHZlICAgID0gY2FwYWJpbGl0eS5yZXNvbHZlXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgdmFyIHZhbHVlcyAgICA9IFtdXG4gICAgICAgICwgaW5kZXggICAgID0gMFxuICAgICAgICAsIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICB2YXIgJGluZGV4ICAgICAgICA9IGluZGV4KytcbiAgICAgICAgICAsIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICBpZihhbHJlYWR5Q2FsbGVkKXJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkICA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpe1xuICBpZighKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSl7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjYWxsICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGdldEl0ZXJGbiAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKVxuICAsIEJSRUFLICAgICAgID0ge31cbiAgLCBSRVRVUk4gICAgICA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1Ipe1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbigpeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpXG4gICAgLCBmICAgICAgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSlcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYoaXNBcnJheUl0ZXIoaXRlckZuKSlmb3IobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgKXtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLICA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpe1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2goZSl7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZihyZXQgIT09IHVuZGVmaW5lZClhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanNcbiAqKiBtb2R1bGUgaWQgPSA2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIElURVJBVE9SICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qc1xuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG4gIGFuT2JqZWN0KE8pO1xuICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanNcbiAqKiBtb2R1bGUgaWQgPSA2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXHJcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxyXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcclxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcclxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcclxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxyXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xyXG5cclxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XHJcbiAgTyA9IHRvSU9iamVjdChPKTtcclxuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XHJcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcclxuICAgIHJldHVybiBnT1BEKE8sIFApO1xyXG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cclxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbiAqKiBtb2R1bGUgaWQgPSA2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4gKiogbW9kdWxlIGlkID0gNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgU1BFQ0lFUyAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywgRCl7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3IsIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGludm9rZSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCl7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spe1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanNcbiAqKiBtb2R1bGUgaWQgPSA3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzXG4gKiogbW9kdWxlIGlkID0gNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBPYnNlcnZlciAgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgUHJvbWlzZSAgID0gZ2xvYmFsLlByb21pc2VcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKXBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUoaGVhZCl7XG4gICAgICBmbiAgID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgaWYoaGVhZClub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZihpc05vZGUpe1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmKE9ic2VydmVyKXtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZVxuICAgICAgLCBub2RlICAgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKXtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmbil7XG4gICAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWR9O1xuICAgIGlmKGxhc3QpbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZighaGVhZCl7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzXG4gKiogbW9kdWxlIGlkID0gNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjLCBzYWZlKXtcbiAgZm9yKHZhciBrZXkgaW4gc3JjKXJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgZFAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIFNQRUNJRVMgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVkpe1xuICB2YXIgQyA9IGdsb2JhbFtLRVldO1xuICBpZihERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKWRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1zcGVjaWVzLmpzXG4gKiogbW9kdWxlIGlkID0gNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBJVEVSQVRPUiAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMsIHNraXBDbG9zaW5nKXtcbiAgaWYoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHtkb25lOiBzYWZlID0gdHJ1ZX07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJsZXQgZnJhbWV3b3Jrc1xuXG5jb25zdCB2ZXJzaW9uUmVnRXhwID0gL15cXC9cXC8gKihcXHtbXlxcfV0qXFx9KSAqXFxyP1xcbi9cblxuZnVuY3Rpb24gY2hlY2tWZXJzaW9uIChjb2RlKSB7XG4gIGxldCBpbmZvXG4gIGNvbnN0IHJlc3VsdCA9IHZlcnNpb25SZWdFeHAuZXhlYyhjb2RlKVxuICBpZiAocmVzdWx0KSB7XG4gICAgdHJ5IHtcbiAgICAgIGluZm8gPSBKU09OLnBhcnNlKHJlc3VsdFsxXSlcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuIGluZm9cbn1cblxuY29uc3QgaW5zdGFuY2VNYXAgPSB7fVxuXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZSAoaWQsIGNvZGUsIGNvbmZpZywgZGF0YSkge1xuICBsZXQgaW5mbyA9IGluc3RhbmNlTWFwW2lkXVxuICBpZiAoIWluZm8pIHtcbiAgICBpbmZvID0gY2hlY2tWZXJzaW9uKGNvZGUpIHx8IHt9XG4gICAgaWYgKCFmcmFtZXdvcmtzW2luZm8uZnJhbWV3b3JrXSkge1xuICAgICAgaW5mby5mcmFtZXdvcmsgPSAnV2VleCdcbiAgICB9XG4gICAgaW5zdGFuY2VNYXBbaWRdID0gaW5mb1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fVxuICAgIGNvbmZpZy5idW5kbGVWZXJzaW9uID0gaW5mby52ZXJzaW9uXG4gICAgY29uc29sZS5kZWJ1ZyhgW0pTIEZyYW1ld29ya10gY3JlYXRlIGFuICR7aW5mby5mcmFtZXdvcmt9QCR7Y29uZmlnLmJ1bmRsZVZlcnNpb259IGluc3RhbmNlIGZyb20gJHtjb25maWcuYnVuZGxlVmVyc2lvbn1gKVxuICAgIHJldHVybiBmcmFtZXdvcmtzW2luZm8uZnJhbWV3b3JrXS5jcmVhdGVJbnN0YW5jZShpZCwgY29kZSwgY29uZmlnLCBkYXRhKVxuICB9XG4gIHJldHVybiBuZXcgRXJyb3IoYGludmFsaWQgaW5zdGFuY2UgaWQgXCIke2lkfVwiYClcbn1cblxuY29uc3QgbWV0aG9kcyA9IHtcbiAgY3JlYXRlSW5zdGFuY2Vcbn1cblxuZnVuY3Rpb24gZ2VuSW5pdCAobWV0aG9kTmFtZSkge1xuICBtZXRob2RzW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZnJhbWV3b3Jrcykge1xuICAgICAgY29uc3QgZnJhbWV3b3JrID0gZnJhbWV3b3Jrc1tuYW1lXVxuICAgICAgaWYgKGZyYW1ld29yayAmJiBmcmFtZXdvcmtbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgZnJhbWV3b3JrW21ldGhvZE5hbWVdKC4uLmFyZ3MpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkluc3RhbmNlIChtZXRob2ROYW1lKSB7XG4gIG1ldGhvZHNbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGNvbnN0IGlkID0gYXJnc1swXVxuICAgIGNvbnN0IGluZm8gPSBpbnN0YW5jZU1hcFtpZF1cbiAgICBpZiAoaW5mbyAmJiBmcmFtZXdvcmtzW2luZm8uZnJhbWV3b3JrXSkge1xuICAgICAgcmV0dXJuIGZyYW1ld29ya3NbaW5mby5mcmFtZXdvcmtdW21ldGhvZE5hbWVdKC4uLmFyZ3MpXG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoYGludmFsaWQgaW5zdGFuY2UgaWQgXCIke2lkfVwiYClcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGFwdEluc3RhbmNlIChtZXRob2ROYW1lLCBuYXRpdmVNZXRob2ROYW1lKSB7XG4gIG1ldGhvZHNbbmF0aXZlTWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIGNvbnN0IGlkID0gYXJnc1swXVxuICAgIGNvbnN0IGluZm8gPSBpbnN0YW5jZU1hcFtpZF1cbiAgICBpZiAoaW5mbyAmJiBmcmFtZXdvcmtzW2luZm8uZnJhbWV3b3JrXSkge1xuICAgICAgcmV0dXJuIGZyYW1ld29ya3NbaW5mby5mcmFtZXdvcmtdW21ldGhvZE5hbWVdKC4uLmFyZ3MpXG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoYGludmFsaWQgaW5zdGFuY2UgaWQgXCIke2lkfVwiYClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0IChjb25maWcpIHtcbiAgZnJhbWV3b3JrcyA9IGNvbmZpZy5mcmFtZXdvcmtzXG4gIGZvciAoY29uc3QgbmFtZSBpbiBmcmFtZXdvcmtzKSB7XG4gICAgY29uc3QgZnJhbWV3b3JrID0gZnJhbWV3b3Jrc1tuYW1lXVxuICAgIGZyYW1ld29yay5pbml0KGNvbmZpZylcbiAgfVxuXG4gIDsgWydkZXN0cm95SW5zdGFuY2UnLCAncmVmcmVzaEluc3RhbmNlJywgJ3JlY2VpdmVUYXNrcycsICdnZXRSb290J10uZm9yRWFjaChnZW5JbnN0YW5jZSlcblxuICA7IFsncmVnaXN0ZXJDb21wb25lbnRzJywgJ3JlZ2lzdGVyTW9kdWxlcycsICdyZWdpc3Rlck1ldGhvZHMnXS5mb3JFYWNoKGdlbkluaXQpXG5cbiAgYWRhcHRJbnN0YW5jZSgncmVjZWl2ZVRhc2tzJywgJ2NhbGxKUycpXG5cbiAgcmV0dXJuIG1ldGhvZHNcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9ydW50aW1lL2luaXQuanNcbiAqKi8iLCIvLyBidWlsdCBieSBucG0gcnVuIGJ1aWxkOmNvbmZpZ1xuXG5pbXBvcnQgKiBhcyBXZWV4IGZyb20gJy4vZGVmYXVsdCdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBXZWV4XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvcnVudGltZS9jb25maWcuanNcbiAqKi8iLCIvKipcbiAqIEBmaWxlT3ZlcnZpZXcgTWFpbiBlbnRyeSwgaW5zdGFuY2UgbWFuYWdlclxuICpcbiAqIC0gY3JlYXRlSW5zdGFuY2UoaW5zdGFuY2VJZCwgY29kZSwgb3B0aW9ucywgZGF0YSlcbiAqIC0gcmVmcmVzaEluc3RhbmNlKGluc3RhbmNlSWQsIGRhdGEpXG4gKiAtIGRlc3Ryb3lJbnN0YW5jZShpbnN0YW5jZUlkKVxuICogLSByZWdpc3RlckNvbXBvbmVudHMoY29tcG9uZW50cylcbiAqIC0gcmVnaXN0ZXJNb2R1bGVzKG1vZHVsZXMpXG4gKiAtIGdldFJvb3QoaW5zdGFuY2VJZClcbiAqIC0gaW5zdGFuY2VNYXBcbiAqIC0gY2FsbEpTKGluc3RhbmNlSWQsIHRhc2tzKVxuICogICAtIGZpcmVFdmVudChyZWYsIHR5cGUsIGRhdGEpXG4gKiAgIC0gY2FsbGJhY2soZnVuY0lkLCBkYXRhKVxuICovXG5leHBvcnQgeyBjcmVhdGVJbnN0YW5jZSB9IGZyb20gJy4uL3N0YXRpYy9jcmVhdGUnXG5leHBvcnQgeyBpbml0LCByZWZyZXNoSW5zdGFuY2UsIGRlc3Ryb3lJbnN0YW5jZSB9IGZyb20gJy4uLy4uLy4uL2RlZmF1bHQvc3RhdGljL2xpZmUnXG5leHBvcnQgeyByZWdpc3RlckNvbXBvbmVudHMsIHJlZ2lzdGVyTW9kdWxlcywgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vLi4vLi4vZGVmYXVsdC9zdGF0aWMvcmVnaXN0ZXInXG5leHBvcnQgeyByZWNlaXZlVGFza3MgfSBmcm9tICcuLi8uLi8uLi9kZWZhdWx0L3N0YXRpYy9icmlkZ2UnXG5leHBvcnQgeyBnZXRSb290IH0gZnJvbSAnLi4vLi4vLi4vZGVmYXVsdC9zdGF0aWMvbWlzYydcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9ydW50aW1lL2RlZmF1bHQvaW5kZXguanNcbiAqKi8iLCJpbXBvcnQgQXBwSW5zdGFuY2UgZnJvbSAnLi4vYXBwJ1xuaW1wb3J0IHsgaW5zdGFuY2VNYXAgfSBmcm9tICcuLi8uLi8uLi9kZWZhdWx0L3N0YXRpYy9tYXAnXG5cbi8qKlxuICogY3JlYXRlIGEgV2VleCBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gaW5zdGFuY2VJZFxuICogQHBhcmFtICB7c3RyaW5nfSBjb2RlXG4gKiBAcGFyYW0gIHtvYmplY3R9IFtvcHRpb25zXSBvcHRpb24gYEhBU19MT0dgIGVuYWJsZSBwcmludCBsb2dcbiAqIEBwYXJhbSAge29iamVjdH0gW2RhdGFdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZSAoaW5zdGFuY2VJZCwgY29kZSwgb3B0aW9ucywgZGF0YSkge1xuICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZU1hcFtpbnN0YW5jZUlkXVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGxldCByZXN1bHRcbiAgaWYgKCFpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlID0gbmV3IEFwcEluc3RhbmNlKGluc3RhbmNlSWQsIG9wdGlvbnMpXG4gICAgaW5zdGFuY2VNYXBbaW5zdGFuY2VJZF0gPSBpbnN0YW5jZVxuICAgIHJlc3VsdCA9IGluc3RhbmNlLmluaXQoY29kZSwgZGF0YSlcbiAgfVxuICBlbHNlIHtcbiAgICByZXN1bHQgPSBuZXcgRXJyb3IoYGludmFsaWQgaW5zdGFuY2UgaWQgXCIke2luc3RhbmNlSWR9XCJgKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdCB8fCBpbnN0YW5jZVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL3J1bnRpbWUvc3RhdGljL2NyZWF0ZS5qc1xuICoqLyIsIi8qKlxuICogQGZpbGVPdmVydmlld1xuICogV2VleCBpbnN0YW5jZSBjb25zdHJ1Y3RvciAmIGRlZmluaXRpb25cbiAqL1xuaW1wb3J0ICogYXMgY3RybCBmcm9tICcuL2N0cmwnXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuLi8uLi91dGlscydcbmltcG9ydCBBcHBJbnN0YW5jZSBmcm9tICcuLi8uLi8uLi9kZWZhdWx0L2FwcC9pbnN0YW5jZSdcblxuZXh0ZW5kKEFwcEluc3RhbmNlLnByb3RvdHlwZSwgY3RybClcblxuZXhwb3J0IGRlZmF1bHQgQXBwSW5zdGFuY2VcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9ydW50aW1lL2FwcC9pbmRleC5qc1xuICoqLyIsIi8qKlxuICogQGZpbGVPdmVydmlld1xuICogaW5zdGFuY2UgY29udHJvbHMgZnJvbSBuYXRpdmVcbiAqXG4gKiAtIGluaXQgYnVuZGxlXG4gKiAtIGZpcmUgZXZlbnRcbiAqIC0gY2FsbGJhY2tcbiAqIC0gZGVzdHJveVxuICpcbiAqIGNvcnJlc3BvbmRlZCB3aXRoIHRoZSBBUEkgb2YgaW5zdGFuY2UgbWFuYWdlciAoZnJhbWV3b3JrLmpzKVxuICovXG5leHBvcnQgeyBpbml0IH0gZnJvbSAnLi9pbml0J1xuXG5leHBvcnQge1xuXHR1cGRhdGVBY3Rpb25zLFxuICBkZXN0cm95LFxuICBnZXRSb290RWxlbWVudCxcbiAgZmlyZUV2ZW50LFxuICBjYWxsYmFjayxcbiAgcmVmcmVzaERhdGFcbn0gZnJvbSAnLi4vLi4vLi4vLi4vZGVmYXVsdC9hcHAvY3RybC9taXNjJ1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL3J1bnRpbWUvYXBwL2N0cmwvaW5kZXguanNcbiAqKi8iLCIvKipcbiAqIEBmaWxlT3ZlcnZpZXdcbiAqIGluc3RhbmNlIGNvbnRyb2xzIGZyb20gbmF0aXZlXG4gKlxuICogLSBpbml0IGJ1bmRsZVxuICogLSBmaXJlIGV2ZW50XG4gKiAtIGNhbGxiYWNrXG4gKiAtIGRlc3Ryb3lcbiAqXG4gKiBjb3JyZXNwb25kZWQgd2l0aCB0aGUgQVBJIG9mIGluc3RhbmNlIG1hbmFnZXIgKGZyYW1ld29yay5qcylcbiAqL1xuXG5pbXBvcnQgeyBiaW5kIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMnXG5cbmltcG9ydCB7XG4gIGRlZmluZSxcbiAgYm9vdHN0cmFwLFxuICByZWdpc3RlclxufSBmcm9tICcuLi9idW5kbGUnXG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0IChjb2RlLCBkYXRhKSB7XG4gIGNvbnNvbGUuZGVidWcoJ1tKUyBGcmFtZXdvcmtdIEludGlhbGl6ZSBhbiBpbnN0YW5jZSB3aXRoOlxcbicsIGRhdGEpXG5cbiAgbGV0IHJlc3VsdFxuICAvLyBAc2VlOiBsaWIvYXBwL2J1bmRsZS5qc1xuICBjb25zdCBidW5kbGVEZWZpbmUgPSBiaW5kKGRlZmluZSwgdGhpcylcbiAgY29uc3QgYnVuZGxlQm9vdHN0cmFwID0gKG5hbWUsIGNvbmZpZywgX2RhdGEpID0+IHtcbiAgICByZXN1bHQgPSBib290c3RyYXAodGhpcywgbmFtZSwgY29uZmlnLCBfZGF0YSB8fCBkYXRhKVxuICAgIHRoaXMudXBkYXRlQWN0aW9ucygpXG4gICAgdGhpcy5kb2MubGlzdGVuZXIuY3JlYXRlRmluaXNoKClcbiAgICBjb25zb2xlLmRlYnVnKGBbSlMgRnJhbWV3b3JrXSBBZnRlciBpbnRpYWxpemVkIGFuIGluc3RhbmNlKCR7dGhpcy5pZH0pYClcbiAgfVxuXG4gIC8vIGJhY2t3YXJkKHJlZ2lzdGVyL3JlbmRlcilcbiAgY29uc3QgYnVuZGxlUmVnaXN0ZXIgPSBiaW5kKHJlZ2lzdGVyLCB0aGlzKVxuICBjb25zdCBidW5kbGVSZW5kZXIgPSAobmFtZSwgX2RhdGEpID0+IHtcbiAgICByZXN1bHQgPSBib290c3RyYXAodGhpcywgbmFtZSwge30sIF9kYXRhKVxuICB9XG5cbiAgY29uc3QgYnVuZGxlUmVxdWlyZSA9IG5hbWUgPT4gX2RhdGEgPT4ge1xuICAgIHJlc3VsdCA9IGJvb3RzdHJhcCh0aGlzLCBuYW1lLCB7fSwgX2RhdGEpXG4gIH1cblxuICBjb25zdCBidW5kbGVEb2N1bWVudCA9IHRoaXMuZG9jXG5cbiAgbGV0IGZ1bmN0aW9uQm9keVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBjb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gYGZ1bmN0aW9uICgpIHsuLi59YCAtPiBgey4uLn1gXG4gICAgLy8gbm90IHZlcnkgc3RyaWN0XG4gICAgZnVuY3Rpb25Cb2R5ID0gY29kZS50b1N0cmluZygpLnN1YnN0cigxMilcbiAgfVxuICBlbHNlIGlmIChjb2RlKSB7XG4gICAgZnVuY3Rpb25Cb2R5ID0gY29kZS50b1N0cmluZygpXG4gIH1cblxuICBjb25zdCB7IFdYRW52aXJvbm1lbnQgfSA9IGdsb2JhbFxuXG4gIGlmIChXWEVudmlyb25tZW50KSB7XG4gICAgY29uc3QgZm4gPSBuZXcgRnVuY3Rpb24oXG4gICAgICAnZGVmaW5lJyxcbiAgICAgICdyZXF1aXJlJyxcbiAgICAgICdkb2N1bWVudCcsXG4gICAgICAnYm9vdHN0cmFwJyxcbiAgICAgICdyZWdpc3RlcicsXG4gICAgICAncmVuZGVyJyxcbiAgICAgICdfX3dlZXhfZGVmaW5lX18nLCAvLyBhbGlhcyBmb3IgZGVmaW5lXG4gICAgICAnX193ZWV4X2Jvb3RzdHJhcF9fJywgLy8gYWxpYXMgZm9yIGJvb3RzdHJhcFxuICAgICAgZnVuY3Rpb25Cb2R5XG4gICAgKVxuXG4gICAgZm4oXG4gICAgICBidW5kbGVEZWZpbmUsXG4gICAgICBidW5kbGVSZXF1aXJlLFxuICAgICAgYnVuZGxlRG9jdW1lbnQsXG4gICAgICBidW5kbGVCb290c3RyYXAsXG4gICAgICBidW5kbGVSZWdpc3RlcixcbiAgICAgIGJ1bmRsZVJlbmRlcixcbiAgICAgIGJ1bmRsZURlZmluZSxcbiAgICAgIGJ1bmRsZUJvb3RzdHJhcClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9ydW50aW1lL2FwcC9jdHJsL2luaXQuanNcbiAqKi8iLCIvKiBnbG9iYWwgSW1hZ2UgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8vIGNvbnN0IFdFQVBQX1NUWUxFX0lEID0gJ3dlYXBwLXN0eWxlJ1xuXG5pbXBvcnQgZnJhbWVVcGRhdGVyIGZyb20gJy4vZnJhbWVVcGRhdGVyJ1xuZXhwb3J0IHsgZnJhbWVVcGRhdGVyIH1cblxuZXhwb3J0IHtcbiAgZXh0ZW5kLFxuICBkZWYsXG4gIHJlbW92ZSxcbiAgaGFzT3duLFxuICBiaW5kLFxuICB0b0FycmF5LFxuICBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdCxcbiAgdHlwb2Zcbn0gZnJvbSAnLi4vLi4vZGVmYXVsdC91dGlsJ1xuXG5pbXBvcnQgeyBpc0FycmF5LCBzbGljZSB9IGZyb20gJy4vYXJyYXknXG5leHBvcnQgeyBpc0FycmF5LCBzbGljZSB9XG5cbmV4cG9ydCBjb25zdCB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXVxuXG5sZXQgX2lzV2VicFN1cHBvcnRlZCA9IGZhbHNlXG5cbjsgKGZ1bmN0aW9uIGlzU3VwcG9ydFdlYnAgKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHdlYlAgPSBuZXcgSW1hZ2UoKVxuICAgIHdlYlAuc3JjID0gJ2RhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsVWtsR1Jqb0FBQUJYUlVKUVZsQTRJQzRBQUFDeUFnQ2RBJ1xuICAgICAgICAgICAgICArICdTb0NBQUlBTG1rMG1rMGlJaUlpSWdCb1N5Z0FCYzZXV2dBQS92ZWZmLzBQUDhiQS8vTHdZQUFBJ1xuICAgIHdlYlAub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHdlYlAuaGVpZ2h0ID09PSAyKSB7XG4gICAgICAgIF9pc1dlYnBTdXBwb3J0ZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhdGNoIChlKSB7XG4gICAgLy8gZG8gbm90aGluZy5cbiAgfVxufSkoKVxuXG5sZXQgX2lzU3RpY2t5U3VwcG9ydGVkID0gZmFsc2VcblxuOyAoZnVuY3Rpb24gaXNTdXBwb3J0U3RpY2t5ICgpIHtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGNvbnN0IGVsZW1lbnRTdHlsZSA9IGVsZW1lbnQuc3R5bGVcbiAgZWxlbWVudFN0eWxlLmNzc1RleHQgPSB2ZW5kb3JzLmNvbmNhdChbJyddKS5tYXAoZnVuY3Rpb24gKHZlbmRvcikge1xuICAgIHJldHVybiAncG9zaXRpb246J1xuICAgICAgKyAodmVuZG9yID8gJy0nICsgdmVuZG9yICsgJy0nIDogJycpXG4gICAgICArICdzdGlja3knXG4gIH0pLmpvaW4oJzsnKSArICc7J1xuICBfaXNTdGlja3lTdXBwb3J0ZWQgPSBlbGVtZW50U3R5bGUucG9zaXRpb24uaW5kZXhPZignc3RpY2t5JykgIT09IC0xXG59KSgpXG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBleHRlbmQgKHRvLCBmcm9tKSB7XG4vLyAgIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcbi8vICAgICB0b1trZXldID0gZnJvbVtrZXldXG4vLyAgIH1cbi8vICAgcmV0dXJuIHRvXG4vLyB9XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbi8vICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopXG4vLyAgICAgLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0J1xuLy8gfVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZSAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKVxuICAgIC5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kU3R5bGUgKGNzcywgc3R5bGVJZCwgcmVwbGFjZSkge1xuICBsZXQgc3R5bGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdHlsZUlkKVxuICBpZiAoc3R5bGUgJiYgcmVwbGFjZSkge1xuICAgIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpXG4gICAgc3R5bGUgPSBudWxsXG4gIH1cbiAgaWYgKCFzdHlsZSkge1xuICAgIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnXG4gICAgc3R5bGVJZCAmJiAoc3R5bGUuaWQgPSBzdHlsZUlkKVxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc3R5bGUpXG4gIH1cbiAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaXF1ZUZyb21BcnJheSAoYXJyKSB7XG4gIGlmICghaXNBcnJheShhcnIpKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgY29uc3QgcmVzID0gW11cbiAgY29uc3QgdW5pcXVlID0ge31cbiAgbGV0IHZhbFxuICBmb3IgKGxldCBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YWwgPSBhcnJbaV1cbiAgICBpZiAodW5pcXVlW3ZhbF0pIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHVuaXF1ZVt2YWxdID0gdHJ1ZVxuICAgIHJlcy5wdXNoKHZhbClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RXZWJwICgpIHtcbiAgcmV0dXJuIF9pc1dlYnBTdXBwb3J0ZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdFN0aWNreSAoKSB7XG4gIHJldHVybiBfaXNTdGlja3lTdXBwb3J0ZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmRvbSAobnVtKSB7XG4gIGNvbnN0IF9kZWZhdWx0TnVtID0gMTBcbiAgaWYgKHR5cGVvZiBudW0gIT09ICdudW1iZXInIHx8IG51bSA8PSAwKSB7XG4gICAgbnVtID0gX2RlZmF1bHROdW1cbiAgfVxuICBjb25zdCBfbWF4ID0gTWF0aC5wb3coMTAsIG51bSlcbiAgcmV0dXJuIE1hdGguZmxvb3IoRGF0ZS5ub3coKSArIE1hdGgucmFuZG9tKCkgKiBfbWF4KSAlIF9tYXhcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJnYiAoY29sb3IpIHtcbiAgbGV0IG1hdGNoXG4gIGNvbG9yID0gY29sb3IgKyAnJ1xuICBtYXRjaCA9IGNvbG9yLm1hdGNoKC8jKFtcXGRhLWZBLUZdezJ9KShbXFxkYS1mQS1GXXsyfSkoW1xcZGEtZkEtRl17Mn0pLylcbiAgaWYgKG1hdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IHBhcnNlSW50KG1hdGNoWzFdLCAxNiksXG4gICAgICBnOiBwYXJzZUludChtYXRjaFsyXSwgMTYpLFxuICAgICAgYjogcGFyc2VJbnQobWF0Y2hbM10sIDE2KVxuICAgIH1cbiAgfVxuICBtYXRjaCA9IGNvbG9yLm1hdGNoKC9yZ2JcXCgoXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspXFwpLylcbiAgaWYgKG1hdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IHBhcnNlSW50KG1hdGNoWzFdKSxcbiAgICAgIGc6IHBhcnNlSW50KG1hdGNoWzJdKSxcbiAgICAgIGI6IHBhcnNlSW50KG1hdGNoWzNdKVxuICAgIH1cbiAgfVxufVxuXG4vLyBkaXJlY3Rpb246ICdsJyB8ICdyJywgZGVmYXVsdCBpcyAncidcbi8vIG51bTogaG93IG1hbnkgdGltZXMgdG8gbG9vcCwgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlclxuZXhwb3J0IGZ1bmN0aW9uIGxvb3BBcnJheSAoYXJyLCBudW0sIGRpcmVjdGlvbikge1xuICBpZiAoIWlzQXJyYXkoYXJyKSkge1xuICAgIHJldHVyblxuICB9XG4gIGxldCBpc0xlZnQgPSAoZGlyZWN0aW9uICsgJycpLnRvTG93ZXJDYXNlKCkgPT09ICdsJ1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoXG4gIG51bSA9IG51bSAlIGxlblxuICBpZiAobnVtIDwgMCkge1xuICAgIG51bSA9IC1udW1cbiAgICBpc0xlZnQgPSAhaXNMZWZ0XG4gIH1cbiAgaWYgKG51bSA9PT0gMCkge1xuICAgIHJldHVybiBhcnJcbiAgfVxuICBsZXQgbHAsIHJwXG4gIGlmIChpc0xlZnQpIHtcbiAgICBscCA9IGFyci5zbGljZSgwLCBudW0pXG4gICAgcnAgPSBhcnIuc2xpY2UobnVtKVxuICB9XG4gIGVsc2Uge1xuICAgIGxwID0gYXJyLnNsaWNlKDAsIGxlbiAtIG51bSlcbiAgICBycCA9IGFyci5zbGljZShsZW4gLSBudW0pXG4gIH1cbiAgcmV0dXJuIHJwLmNvbmNhdChscClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlIChmdW5jLCB3YWl0KSB7XG4gIGxldCByZXN1bHRcbiAgbGV0IHRpbWVySWQgPSBudWxsXG4gIGxldCBwcmV2aW91cyA9IDBcbiAgbGV0IGNvbnRleHRcbiAgbGV0IGFyZ3NcbiAgY29uc3QgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJldmlvdXMgPSBEYXRlLm5vdygpXG4gICAgdGltZXJJZCA9IG51bGxcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpXG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cylcbiAgICBjb250ZXh0ID0gdGhpc1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZClcbiAgICAgIHRpbWVySWQgPSBudWxsXG4gICAgICBwcmV2aW91cyA9IG5vd1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKVxuICAgIH1cbiAgICBlbHNlIGlmICghdGltZXJJZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZylcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvdXRpbHMvaW5kZXguanNcbiAqKi8iLCJleHBvcnQge1xuICBleHRlbmQsXG4gIGRlZixcbiAgcmVtb3ZlLFxuICBoYXNPd24sXG4gIGJpbmQsXG4gIHRvQXJyYXksXG4gIGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0XG59IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscydcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgY29uc3QgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKVxuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xuZXhwb3J0IGNvbnN0IGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge31cblxubGV0IF9TZXRcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIFNldC50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0XG59XG5lbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICB9XG4gIF9TZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRba2V5XSAhPT0gdW5kZWZpbmVkXG4gIH1cbiAgX1NldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHRoaXMuc2V0W2tleV0gPSAxXG4gIH1cbiAgX1NldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIH1cbn1cblxuZXhwb3J0IHsgX1NldCB9XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdXG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH1cbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxtaXRlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2dcbmV4cG9ydCBjb25zdCBjYW1lbGl6ZSA9IGNhY2hlZChzdHIgPT4ge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgdG9VcHBlcilcbn0pXG5cbmZ1bmN0aW9uIHRvVXBwZXIgKF8sIGMpIHtcbiAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJ1xufVxuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmNvbnN0IGh5cGhlbmF0ZVJFID0gLyhbYS16XFxkXSkoW0EtWl0pL2dcbmV4cG9ydCBjb25zdCBoeXBoZW5hdGUgPSBjYWNoZWQoc3RyID0+IHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpXG59KVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwb2YgKHYpIHtcbiAgY29uc3QgcyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KVxuICByZXR1cm4gcy5zdWJzdHJpbmcoOCwgcy5sZW5ndGggLSAxKS50b0xvd2VyQ2FzZSgpXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvdXRpbC9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgIGZ1bmN0aW9uIChjYWxsbGJhY2spIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGxiYWNrLCAxNilcbiAgICAgICAgICB9XG5cbmxldCByYWZJZFxuY29uc3Qgb2JzZXJ2ZXJzID0gW11cbmxldCBwYXVzZWQgPSBmYWxzZVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJhZklkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByYWZJZCA9IHJhZihmdW5jdGlvbiBydW5Mb29wICgpIHtcbiAgICAgIGlmICghcGF1c2VkKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb2JzZXJ2ZXJzW2ldKClcbiAgICAgICAgfVxuICAgICAgICByYWYocnVuTG9vcClcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuXG4gIGlzQWN0aXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICFwYXVzZWRcbiAgfSxcblxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIHBhdXNlZCA9IHRydWVcbiAgICByYWZJZCA9IHVuZGVmaW5lZFxuICB9LFxuXG4gIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgIHBhdXNlZCA9IGZhbHNlXG4gICAgdGhpcy5zdGFydCgpXG4gIH0sXG5cbiAgYWRkVXBkYXRlT2JzZXJ2ZXI6IGZ1bmN0aW9uIChvYnNlcnZlTWV0aG9kKSB7XG4gICAgb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZU1ldGhvZClcbiAgfVxufVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvdXRpbHMvZnJhbWVVcGRhdGVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5IChhcnIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXlcbiAgICA/IEFycmF5LmlzQXJyYXkoYXJyKVxuICAgIDogKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSAnW29iamVjdCBBcnJheV0nKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2xpY2UgKGFyciwgc3RhcnQsIGVuZCkge1xuICBpZiAoaXNBcnJheShhcnIpKSB7XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kKVxuICB9XG4gIGNvbnN0IHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gIHJldHVybiBzbGljZS5jYWxsKGFyciwgc3RhcnQsIGVuZClcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci91dGlscy9hcnJheS5qc1xuICoqLyIsIi8qKlxuICogQGZpbGVPdmVydmlld1xuICogYXBpIHRoYXQgaW52b2tlZCBieSBqcyBidW5kbGUgY29kZVxuICpcbiAqIC0gZGVmaW5lKG5hbWUsIGZhY3RvcnkpOiBkZWZpbmUgYSBuZXcgY29tcG9zZWQgY29tcG9uZW50IHR5cGVcbiAqIC0gYm9vdHN0cmFwKHR5cGUsIGNvbmZpZywgZGF0YSk6IHJlcXVpcmUgYSBjZXJ0YWluIHR5cGUgJlxuICogICAgICAgICByZW5kZXIgd2l0aCAob3B0aW9uYWwpIGRhdGFcbiAqXG4gKiBkZXByZWNhdGVkOlxuICogLSByZWdpc3Rlcih0eXBlLCBvcHRpb25zKTogcmVnaXN0ZXIgYSBuZXcgY29tcG9zZWQgY29tcG9uZW50IHR5cGVcbiAqIC0gcmVuZGVyKHR5cGUsIGRhdGEpOiByZW5kZXIgYnkgYSBjZXJ0YWluIHR5cGUgd2l0aCAob3B0aW9uYWwpIGRhdGFcbiAqIC0gcmVxdWlyZSh0eXBlKShkYXRhKTogcmVxdWlyZSBhIHR5cGUgdGhlbiByZW5kZXIgd2l0aCBkYXRhXG4gKi9cblxuZXhwb3J0IHsgYm9vdHN0cmFwIH0gZnJvbSAnLi9ib290c3RyYXAnXG5leHBvcnQgeyBjbGVhckNvbW1vbk1vZHVsZXMsIGRlZmluZSwgcmVnaXN0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9kZWZhdWx0L2FwcC9idW5kbGUvZGVmaW5lJ1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL3J1bnRpbWUvYXBwL2J1bmRsZS9pbmRleC5qc1xuICoqLyIsIi8vIGltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJ1xuaW1wb3J0IFZtIGZyb20gJy4uLy4uLy4uLy4uL2RlZmF1bHQvdm0nXG4vLyBpbXBvcnQgKiBhcyBkb3duZ3JhZGUgZnJvbSAnLi4vZG93bmdyYWRlJ1xuaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzJ1xuaW1wb3J0IHtcbiAgaXNXZWV4Q29tcG9uZW50LFxuICBpc05wbU1vZHVsZSxcbiAgcmVtb3ZlV2VleFByZWZpeCxcbiAgcmVtb3ZlSlNTdXJmaXhcbn0gZnJvbSAnLi4vLi4vLi4vLi4vZGVmYXVsdC9hcHAvYnVuZGxlL21pc2MnXG5cbmV4cG9ydCBmdW5jdGlvbiBib290c3RyYXAgKGFwcCwgbmFtZSwgY29uZmlnLCBkYXRhKSB7XG4gIGNvbnNvbGUuZGVidWcoYFtKUyBGcmFtZXdvcmtdIGJvb3RzdHJhcCBmb3IgJHtuYW1lfWApXG5cbiAgbGV0IGNsZWFuTmFtZVxuXG4gIGlmIChpc1dlZXhDb21wb25lbnQobmFtZSkpIHtcbiAgICBjbGVhbk5hbWUgPSByZW1vdmVXZWV4UHJlZml4KG5hbWUpXG4gIH1cbiAgZWxzZSBpZiAoaXNOcG1Nb2R1bGUobmFtZSkpIHtcbiAgICBjbGVhbk5hbWUgPSByZW1vdmVKU1N1cmZpeChuYW1lKVxuICAgIC8vIGNoZWNrIGlmIGRlZmluZSBieSBvbGQgJ2RlZmluZScgbWV0aG9kXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFhcHAuY3VzdG9tQ29tcG9uZW50TWFwW2NsZWFuTmFtZV0pIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoYEl0J3Mgbm90IGEgY29tcG9uZW50OiAke25hbWV9YClcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihgV3JvbmcgY29tcG9uZW50IG5hbWU6ICR7bmFtZX1gKVxuICB9XG5cbiAgY29uZmlnID0gaXNQbGFpbk9iamVjdChjb25maWcpID8gY29uZmlnIDoge31cblxuICBjb25zb2xlLmxvZyhgdHJhbnNmb3JtZXJWZXJzaW9uOiAke2NvbmZpZy50cmFuc2Zvcm1lclZlcnNpb259LCBgXG4gICAgKyBgYXZhaWxhYmxlIHRyYW5zZm9ybWVyVmVyc2lvbjogJHtnbG9iYWwudHJhbnNmb3JtVmVyc2lvbn1gKVxuXG4gIC8vIGlmICh0eXBlb2YgY29uZmlnLnRyYW5zZm9ybWVyVmVyc2lvbiA9PT0gJ3N0cmluZycgJiZcbiAgLy8gICB0eXBlb2YgZ2xvYmFsLnRyYW5zZm9ybWVyVmVyc2lvbiA9PT0gJ3N0cmluZycgJiZcbiAgLy8gICAhc2VtdmVyLnNhdGlzZmllcyhjb25maWcudHJhbnNmb3JtZXJWZXJzaW9uLFxuICAvLyAgICAgZ2xvYmFsLnRyYW5zZm9ybWVyVmVyc2lvbikpIHtcbiAgLy8gICByZXR1cm4gbmV3IEVycm9yKGBKUyBCdW5kbGUgdmVyc2lvbjogJHtjb25maWcudHJhbnNmb3JtZXJWZXJzaW9ufSBgICtcbiAgLy8gICAgIGBub3QgY29tcGF0aWJsZSB3aXRoICR7Z2xvYmFsLnRyYW5zZm9ybWVyVmVyc2lvbn1gKVxuICAvLyB9XG5cbiAgLy8gY29uc3QgX2NoZWNrRG93bmdyYWRlID0gZG93bmdyYWRlLmNoZWNrKGNvbmZpZy5kb3duZ3JhZGUpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAvLyBpZiAoX2NoZWNrRG93bmdyYWRlLmlzRG93bmdyYWRlKSB7XG4gIC8vICAgYXBwLmNhbGxUYXNrcyhbe1xuICAvLyAgICAgbW9kdWxlOiAnaW5zdGFuY2VXcmFwJyxcbiAgLy8gICAgIG1ldGhvZDogJ2Vycm9yJyxcbiAgLy8gICAgIGFyZ3M6IFtcbiAgLy8gICAgICAgX2NoZWNrRG93bmdyYWRlLmVycm9yVHlwZSxcbiAgLy8gICAgICAgX2NoZWNrRG93bmdyYWRlLmNvZGUsXG4gIC8vICAgICAgIF9jaGVja0Rvd25ncmFkZS5lcnJvck1lc3NhZ2VcbiAgLy8gICAgIF1cbiAgLy8gICB9XSlcbiAgLy8gICByZXR1cm4gbmV3IEVycm9yKGBEb3duZ3JhZGVbJHtfY2hlY2tEb3duZ3JhZGUuY29kZX1dOiAke19jaGVja0Rvd25ncmFkZS5lcnJvck1lc3NhZ2V9YClcbiAgLy8gfVxuXG4gIGFwcC52bSA9IG5ldyBWbShjbGVhbk5hbWUsIG51bGwsIHsgX2FwcDogYXBwIH0sIG51bGwsIGRhdGEpXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvcnVudGltZS9hcHAvYnVuZGxlL2Jvb3RzdHJhcC5qc1xuICoqLyIsIi8qKlxuICogQGZpbGVPdmVydmlld1xuICogVmlld01vZGVsIENvbnN0cnVjdG9yICYgZGVmaW5pdGlvblxuICovXG5cbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL3V0aWwnXG5pbXBvcnQge1xuICBpbml0U3RhdGVcbn0gZnJvbSAnLi4vY29yZS9zdGF0ZSdcbmltcG9ydCB7XG4gIGJ1aWxkXG59IGZyb20gJy4vY29tcGlsZXInXG5pbXBvcnQge1xuICBpbml0RXZlbnRzLFxuICBtaXhpbkV2ZW50c1xufSBmcm9tICcuL2V2ZW50cydcbmltcG9ydCB7XG4gIHJlZ2lzdGVyTW9kdWxlcyxcbiAgcmVnaXN0ZXJNZXRob2RzXG59IGZyb20gJy4uL2FwcC9yZWdpc3RlcidcblxuLyoqXG4gKiBWaWV3TW9kZWwgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICAgY29tcG9uZW50IG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRWbSAgIHdoaWNoIGNvbnRhaW5zIF9hcHBcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRFbCAgIHJvb3QgZWxlbWVudCBvciBmcmFnIGJsb2NrXG4gKiBAcGFyYW0ge29iamVjdH0gbWVyZ2VkRGF0YSBleHRlcm5hbCBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gZXh0ZXJuYWxFdmVudHMgZXh0ZXJuYWwgZXZlbnRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFZtIChcbiAgdHlwZSxcbiAgb3B0aW9ucyxcbiAgcGFyZW50Vm0sXG4gIHBhcmVudEVsLFxuICBtZXJnZWREYXRhLFxuICBleHRlcm5hbEV2ZW50c1xuKSB7XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudFZtLl9yZWFsUGFyZW50ID8gcGFyZW50Vm0uX3JlYWxQYXJlbnQgOiBwYXJlbnRWbVxuICB0aGlzLl9hcHAgPSBwYXJlbnRWbS5fYXBwXG4gIHBhcmVudFZtLl9jaGlsZHJlblZtcyAmJiBwYXJlbnRWbS5fY2hpbGRyZW5WbXMucHVzaCh0aGlzKVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB0aGlzLl9hcHAuY3VzdG9tQ29tcG9uZW50TWFwW3R5cGVdIHx8IHt9XG4gIH1cbiAgY29uc3QgZGF0YSA9IG9wdGlvbnMuZGF0YSB8fCB7fVxuXG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gIHRoaXMuX21ldGhvZHMgPSBvcHRpb25zLm1ldGhvZHMgfHwge31cbiAgdGhpcy5fY29tcHV0ZWQgPSBvcHRpb25zLmNvbXB1dGVkIHx8IHt9XG4gIHRoaXMuX2NzcyA9IG9wdGlvbnMuc3R5bGUgfHwge31cbiAgdGhpcy5faWRzID0ge31cbiAgdGhpcy5fdm1FdmVudHMgPSB7fVxuICB0aGlzLl9jaGlsZHJlblZtcyA9IFtdXG4gIHRoaXMuX3R5cGUgPSB0eXBlXG5cbiAgLy8gYmluZCBldmVudHMgYW5kIGxpZmVjeWNsZXNcbiAgaW5pdEV2ZW50cyh0aGlzLCBleHRlcm5hbEV2ZW50cylcblxuICBjb25zb2xlLmRlYnVnKGBbSlMgRnJhbWV3b3JrXSBcImluaXRcIiBsaWZlY3ljbGUgaW4gVm0oJHt0aGlzLl90eXBlfSlgKVxuICB0aGlzLiRlbWl0KCdob29rOmluaXQnKVxuICB0aGlzLl9pbml0ZWQgPSB0cnVlXG5cbiAgLy8gcHJveHkgZGF0YSBhbmQgbWV0aG9kc1xuICAvLyBvYnNlcnZlIGRhdGEgYW5kIGFkZCB0aGlzIHRvIHZtc1xuICB0aGlzLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicgPyBkYXRhKCkgOiBkYXRhXG4gIGlmIChtZXJnZWREYXRhKSB7XG4gICAgZXh0ZW5kKHRoaXMuX2RhdGEsIG1lcmdlZERhdGEpXG4gIH1cbiAgaW5pdFN0YXRlKHRoaXMpXG5cbiAgY29uc29sZS5kZWJ1ZyhgW0pTIEZyYW1ld29ya10gXCJjcmVhdGVkXCIgbGlmZWN5Y2xlIGluIFZtKCR7dGhpcy5fdHlwZX0pYClcbiAgdGhpcy4kZW1pdCgnaG9vazpjcmVhdGVkJylcbiAgdGhpcy5fY3JlYXRlZCA9IHRydWVcblxuICAvLyBiYWNrd2FyZCBvbGQgcmVhZHkgZW50cnlcbiAgaWYgKG9wdGlvbnMubWV0aG9kcyAmJiBvcHRpb25zLm1ldGhvZHMucmVhZHkpIHtcbiAgICBjb25zb2xlLndhcm4oJ1wiZXhwb3J0cy5tZXRob2RzLnJlYWR5XCIgaXMgZGVwcmVjYXRlZCwgJyArXG4gICAgICAncGxlYXNlIHVzZSBcImV4cG9ydHMuY3JlYXRlZFwiIGluc3RlYWQnKVxuICAgIG9wdGlvbnMubWV0aG9kcy5yZWFkeS5jYWxsKHRoaXMpXG4gIH1cblxuICAvLyBpZiBubyBwYXJlbnRFbGVtZW50IHRoZW4gc3BlY2lmeSB0aGUgZG9jdW1lbnRFbGVtZW50XG4gIHRoaXMuX3BhcmVudEVsID0gcGFyZW50RWwgfHwgdGhpcy5fYXBwLmRvYy5kb2N1bWVudEVsZW1lbnRcbiAgYnVpbGQodGhpcylcbn1cblxubWl4aW5FdmVudHMoVm0ucHJvdG90eXBlKVxuXG5leHRlbmQoVm0sIHtcbiAgcmVnaXN0ZXJNb2R1bGVzLFxuICByZWdpc3Rlck1ldGhvZHNcbn0pXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvdm0vaW5kZXguanNcbiAqKi8iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5pbXBvcnQgV2F0Y2hlciBmcm9tICcuL3dhdGNoZXInXG5pbXBvcnQgRGVwIGZyb20gJy4vZGVwJ1xuaW1wb3J0IHtcbiAgb2JzZXJ2ZSxcbiAgcHJveHksXG4gIHVucHJveHlcbn0gZnJvbSAnLi9vYnNlcnZlcidcbmltcG9ydCB7XG4gIGlzUGxhaW5PYmplY3QsXG4gIGJpbmRcbn0gZnJvbSAnLi4vdXRpbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW11cbiAgaW5pdERhdGEodm0pXG4gIGluaXRDb21wdXRlZCh2bSlcbiAgaW5pdE1ldGhvZHModm0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgbGV0IGRhdGEgPSB2bS5fZGF0YVxuXG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fVxuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpXG4gIGxldCBpID0ga2V5cy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIHByb3h5KHZtLCBrZXlzW2ldKVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHZtKVxufVxuXG5mdW5jdGlvbiBub29wICgpIHtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0pIHtcbiAgY29uc3QgY29tcHV0ZWQgPSB2bS5fY29tcHV0ZWRcbiAgaWYgKGNvbXB1dGVkKSB7XG4gICAgZm9yIChsZXQga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICBjb25zdCB1c2VyRGVmID0gY29tcHV0ZWRba2V5XVxuICAgICAgY29uc3QgZGVmID0ge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkZWYuZ2V0ID0gbWFrZUNvbXB1dGVkR2V0dGVyKHVzZXJEZWYsIHZtKVxuICAgICAgICBkZWYuc2V0ID0gbm9vcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICAgICAgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICAgICAgPyBtYWtlQ29tcHV0ZWRHZXR0ZXIodXNlckRlZi5nZXQsIHZtKVxuICAgICAgICAgICAgOiBiaW5kKHVzZXJEZWYuZ2V0LCB2bSlcbiAgICAgICAgICA6IG5vb3BcbiAgICAgICAgZGVmLnNldCA9IHVzZXJEZWYuc2V0XG4gICAgICAgICAgPyBiaW5kKHVzZXJEZWYuc2V0LCB2bSlcbiAgICAgICAgICA6IG5vb3BcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2bSwga2V5LCBkZWYpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VDb21wdXRlZEdldHRlciAoZ2V0dGVyLCBvd25lcikge1xuICBjb25zdCB3YXRjaGVyID0gbmV3IFdhdGNoZXIob3duZXIsIGdldHRlciwgbnVsbCwge1xuICAgIGxhenk6IHRydWVcbiAgfSlcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpXG4gICAgfVxuICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICB3YXRjaGVyLmRlcGVuZCgpXG4gICAgfVxuICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSkge1xuICBjb25zdCBtZXRob2RzID0gdm0uX21ldGhvZHNcbiAgaWYgKG1ldGhvZHMpIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XVxuICAgIH1cbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9kZWZhdWx0L2NvcmUvc3RhdGUuanNcbiAqKi8iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5pbXBvcnQgRGVwIGZyb20gJy4vZGVwJ1xuLy8gaW1wb3J0IHsgcHVzaFdhdGNoZXIgfSBmcm9tICcuL2JhdGNoZXInXG5pbXBvcnQge1xuICB3YXJuLFxuICByZW1vdmUsXG4gIGV4dGVuZCxcbiAgaXNPYmplY3QsXG4gIHBhcnNlUGF0aCxcbiAgX1NldCBhcyBTZXRcbn0gZnJvbSAnLi4vdXRpbCdcblxubGV0IHVpZCA9IDBcbmxldCBwcmV2VGFyZ2V0XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gZXhwT3JGblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgICAgICAgICAgICAgICAgLSB7QXJyYXl9IGZpbHRlcnNcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSB0d29XYXlcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBkZWVwXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gdXNlclxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHN5bmNcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSBsYXp5XG4gKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IFtwcmVQcm9jZXNzXVxuICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBbcG9zdFByb2Nlc3NdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBXYXRjaGVyICh2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpIHtcbiAgLy8gbWl4IGluIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBleHRlbmQodGhpcywgb3B0aW9ucylcbiAgfVxuICBjb25zdCBpc0ZuID0gdHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbidcbiAgdGhpcy52bSA9IHZtXG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpXG4gIHRoaXMuZXhwcmVzc2lvbiA9IGV4cE9yRm5cbiAgdGhpcy5jYiA9IGNiXG4gIHRoaXMuaWQgPSArK3VpZCAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZVxuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdXG4gIHRoaXMubmV3RGVwcyA9IFtdXG4gIHRoaXMuZGVwSWRzID0gbmV3IFNldCgpXG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IFNldCgpXG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAoaXNGbikge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGblxuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pXG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnRmFpbGVkIHdhdGNoaW5nIHBhdGg6ICcgKyBleHBPckZuICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgIClcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpXG4gIC8vIHN0YXRlIGZvciBhdm9pZGluZyBmYWxzZSB0cmlnZ2VycyBmb3IgZGVlcCBhbmQgQXJyYXlcbiAgLy8gd2F0Y2hlcnMgZHVyaW5nIHZtLl9kaWdlc3QoKVxuICB0aGlzLnF1ZXVlZCA9IHRoaXMuc2hhbGxvdyA9IGZhbHNlXG59XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5iZWZvcmVHZXQoKVxuICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodGhpcy52bSwgdGhpcy52bSlcbiAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICBpZiAodGhpcy5kZWVwKSB7XG4gICAgdHJhdmVyc2UodmFsdWUpXG4gIH1cbiAgdGhpcy5hZnRlckdldCgpXG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIFByZXBhcmUgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5iZWZvcmVHZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHByZXZUYXJnZXQgPSBEZXAudGFyZ2V0XG4gIERlcC50YXJnZXQgPSB0aGlzXG59XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0RlcH0gZGVwXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gKGRlcCkge1xuICBjb25zdCBpZCA9IGRlcC5pZFxuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpXG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKVxuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuYWZ0ZXJHZXQgPSBmdW5jdGlvbiAoKSB7XG4gIERlcC50YXJnZXQgPSBwcmV2VGFyZ2V0XG4gIGxldCBpID0gdGhpcy5kZXBzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3QgZGVwID0gdGhpcy5kZXBzW2ldXG4gICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzKVxuICAgIH1cbiAgfVxuICBsZXQgdG1wID0gdGhpcy5kZXBJZHNcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkc1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcFxuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpXG4gIHRtcCA9IHRoaXMuZGVwc1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHNcbiAgdGhpcy5uZXdEZXBzID0gdG1wXG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwXG59XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hhbGxvd1xuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChzaGFsbG93KSB7XG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIHRoaXMucnVuKClcbiAgfVxuICAvLyB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAvLyAgIHRoaXMucnVuKClcbiAgLy8gfSBlbHNlIHtcbiAgLy8gICAvLyBpZiBxdWV1ZWQsIG9ubHkgb3ZlcndyaXRlIHNoYWxsb3cgd2l0aCBub24tc2hhbGxvdyxcbiAgLy8gICAvLyBidXQgbm90IHRoZSBvdGhlciB3YXkgYXJvdW5kLlxuICAvLyAgIHRoaXMuc2hhbGxvdyA9IHRoaXMucXVldWVkXG4gIC8vICAgICA/IHNoYWxsb3dcbiAgLy8gICAgICAgPyB0aGlzLnNoYWxsb3dcbiAgLy8gICAgICAgOiBmYWxzZVxuICAvLyAgICAgOiAhIXNoYWxsb3dcbiAgLy8gICB0aGlzLnF1ZXVlZCA9IHRydWVcbiAgLy8gICBwdXNoV2F0Y2hlcih0aGlzKVxuICAvLyB9XG59XG5cbi8qKlxuICogQmF0Y2hlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIGJhdGNoZXIuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KClcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQ7IGJ1dCBvbmx5IGRvIHNvIGlmIHRoaXMgaXMgYVxuICAgICAgLy8gbm9uLXNoYWxsb3cgdXBkYXRlIChjYXVzZWQgYnkgYSB2bSBkaWdlc3QpLlxuICAgICAgKChpc09iamVjdCh2YWx1ZSkgfHwgdGhpcy5kZWVwKSAmJiAhdGhpcy5zaGFsbG93KVxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnZhbHVlXG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpXG4gICAgfVxuICAgIHRoaXMucXVldWVkID0gdGhpcy5zaGFsbG93ID0gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gYXZvaWQgb3ZlcndyaXRpbmcgYW5vdGhlciB3YXRjaGVyIHRoYXQgaXMgYmVpbmdcbiAgLy8gY29sbGVjdGVkLlxuICBjb25zdCBjdXJyZW50ID0gRGVwLnRhcmdldFxuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKVxuICB0aGlzLmRpcnR5ID0gZmFsc2VcbiAgRGVwLnRhcmdldCA9IGN1cnJlbnRcbn1cblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBpID0gdGhpcy5kZXBzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YmNyaWJlciBsaXN0LlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQgb3IgaXMgcGVyZm9ybWluZyBhIHYtZm9yXG4gICAgLy8gcmUtcmVuZGVyICh0aGUgd2F0Y2hlciBsaXN0IGlzIHRoZW4gZmlsdGVyZWQgYnkgdi1mb3IpLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdGhpcy52bS5fdkZvclJlbW92aW5nKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpXG4gICAgfVxuICAgIGxldCBpID0gdGhpcy5kZXBzLmxlbmd0aFxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcylcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZVxuICAgIHRoaXMudm0gPSB0aGlzLmNiID0gdGhpcy52YWx1ZSA9IG51bGxcbiAgfVxufVxuXG4vKipcbiAqIFJlY3J1c2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHBhcmFtIHtTZXR9IHNlZW5cbiAqL1xuXG5jb25zdCBzZWVuT2JqZWN0cyA9IG5ldyBTZXQoKVxuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICBsZXQgaSwga2V5cywgaXNBLCBpc09cbiAgaWYgKCFzZWVuKSB7XG4gICAgc2VlbiA9IHNlZW5PYmplY3RzXG4gICAgc2Vlbi5jbGVhcigpXG4gIH1cbiAgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpXG4gIGlzTyA9IGlzT2JqZWN0KHZhbClcbiAgaWYgKGlzQSB8fCBpc08pIHtcbiAgICBpZiAodmFsLl9fb2JfXykge1xuICAgICAgY29uc3QgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZFxuICAgICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW4uYWRkKGRlcElkKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNBKSB7XG4gICAgICBpID0gdmFsLmxlbmd0aFxuICAgICAgd2hpbGUgKGktLSkgdHJhdmVyc2UodmFsW2ldLCBzZWVuKVxuICAgIH0gZWxzZSBpZiAoaXNPKSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKVxuICAgICAgaSA9IGtleXMubGVuZ3RoXG4gICAgICB3aGlsZSAoaS0tKSB0cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pXG4gICAgfVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvY29yZS93YXRjaGVyLmpzXG4gKiovIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGVzbGludC1kaXNhYmxlICovXG5cbmltcG9ydCB7IHJlbW92ZSB9IGZyb20gJy4uL3V0aWwnXG5cbmxldCB1aWQgPSAwXG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrK1xuICB0aGlzLnN1YnMgPSBbXVxufVxuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsXG5cbi8qKlxuICogQWRkIGEgZGlyZWN0aXZlIHN1YnNjcmliZXIuXG4gKlxuICogQHBhcmFtIHtEaXJlY3RpdmV9IHN1YlxuICovXG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpXG59XG5cbi8qKlxuICogUmVtb3ZlIGEgZGlyZWN0aXZlIHN1YnNjcmliZXIuXG4gKlxuICogQHBhcmFtIHtEaXJlY3RpdmV9IHN1YlxuICovXG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpXG59XG5cbi8qKlxuICogQWRkIHNlbGYgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSB0YXJnZXQgd2F0Y2hlci5cbiAqL1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgRGVwLnRhcmdldC5hZGREZXAodGhpcylcbn1cblxuLyoqXG4gKiBOb3RpZnkgYWxsIHN1YnNjcmliZXJzIG9mIGEgbmV3IHZhbHVlLlxuICovXG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAvLyBzdGFibGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIGNvbnN0IHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKVxuICBmb3IgKGxldCBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvY29yZS9kZXAuanNcbiAqKi8iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5pbXBvcnQgRGVwIGZyb20gJy4vZGVwJ1xuaW1wb3J0IHsgYXJyYXlNZXRob2RzIH0gZnJvbSAnLi9hcnJheSdcbmltcG9ydCB7XG4gIGRlZixcbiAgcmVtb3ZlLFxuICBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdCxcbiAgaGFzUHJvdG8sXG4gIGhhc093bixcbiAgaXNSZXNlcnZlZFxufSBmcm9tICcuLi91dGlsJ1xuXG5jb25zdCBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpXG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gdmFsdWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIHRoaXMuZGVwID0gbmV3IERlcCgpXG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnRcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cylcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpXG4gIH1cbn1cblxuLy8gSW5zdGFuY2UgbWV0aG9kc1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICB0aGlzLmNvbnZlcnQoa2V5LCBvYmpba2V5XSlcbiAgfVxufVxuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIChpdGVtcykge1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgcHJvcGVydHkgaW50byBnZXR0ZXIvc2V0dGVyIHNvIHdlIGNhbiBlbWl0XG4gKiB0aGUgZXZlbnRzIHdoZW4gdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkL2NoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICBkZWZpbmVSZWFjdGl2ZSh0aGlzLnZhbHVlLCBrZXksIHZhbClcbn1cblxuLyoqXG4gKiBBZGQgYW4gb3duZXIgdm0sIHNvIHRoYXQgd2hlbiAkc2V0LyRkZWxldGUgbXV0YXRpb25zXG4gKiBoYXBwZW4gd2UgY2FuIG5vdGlmeSBvd25lciB2bXMgdG8gcHJveHkgdGhlIGtleXMgYW5kXG4gKiBkaWdlc3QgdGhlIHdhdGNoZXJzLiBUaGlzIGlzIG9ubHkgY2FsbGVkIHdoZW4gdGhlIG9iamVjdFxuICogaXMgb2JzZXJ2ZWQgYXMgYW4gaW5zdGFuY2UncyByb290ICRkYXRhLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5hZGRWbSA9IGZ1bmN0aW9uICh2bSkge1xuICAodGhpcy52bXMgfHwgKHRoaXMudm1zID0gW10pKS5wdXNoKHZtKVxufVxuXG4vKipcbiAqIFJlbW92ZSBhbiBvd25lciB2bS4gVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgb2JqZWN0IGlzXG4gKiBzd2FwcGVkIG91dCBhcyBhbiBpbnN0YW5jZSdzICRkYXRhIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUucmVtb3ZlVm0gPSBmdW5jdGlvbiAodm0pIHtcbiAgcmVtb3ZlKHRoaXMudm1zLCB2bSlcbn1cblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICovXG5cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyY1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG9cbiAqL1xuXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKVxuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtWdWV9IFt2bV1cbiAqIEByZXR1cm4ge09ic2VydmVyfHVuZGVmaW5lZH1cbiAqIEBzdGF0aWNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIHZtKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgbGV0IG9iXG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fXG4gIH0gZWxzZSBpZiAoXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSlcbiAgfVxuICBpZiAob2IgJiYgdm0pIHtcbiAgICBvYi5hZGRWbSh2bSlcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUgKG9iaiwga2V5LCB2YWwpIHtcbiAgY29uc3QgZGVwID0gbmV3IERlcCgpXG5cbiAgY29uc3QgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KVxuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIGNvbnN0IGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldFxuICBjb25zdCBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXRcblxuICBsZXQgY2hpbGRPYiA9IG9ic2VydmUodmFsKVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbFxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpXG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKClcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBmb3IgKGxldCBlLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZSA9IHZhbHVlW2ldXG4gICAgICAgICAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbFxuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsXG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpXG4gICAgICBkZXAubm90aWZ5KClcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldCAob2JqLCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5zcGxpY2Uoa2V5LCAxLCB2YWwpXG4gIH1cbiAgaWYgKGhhc093bihvYmosIGtleSkpIHtcbiAgICBvYmpba2V5XSA9IHZhbFxuICAgIHJldHVyblxuICB9XG4gIGlmIChvYmouX2lzVnVlKSB7XG4gICAgc2V0KG9iai5fZGF0YSwga2V5LCB2YWwpXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3Qgb2IgPSBvYmouX19vYl9fXG4gIGlmICghb2IpIHtcbiAgICBvYmpba2V5XSA9IHZhbFxuICAgIHJldHVyblxuICB9XG4gIG9iLmNvbnZlcnQoa2V5LCB2YWwpXG4gIG9iLmRlcC5ub3RpZnkoKVxuICBpZiAob2Iudm1zKSB7XG4gICAgbGV0IGkgPSBvYi52bXMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY29uc3Qgdm0gPSBvYi52bXNbaV1cbiAgICAgIHByb3h5KHZtLCBrZXkpXG4gICAgICB2bS4kZm9yY2VVcGRhdGUoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbCAob2JqLCBrZXkpIHtcbiAgaWYgKCFoYXNPd24ob2JqLCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIG9ialtrZXldXG4gIGNvbnN0IG9iID0gb2JqLl9fb2JfX1xuXG4gIGlmICghb2IpIHtcbiAgICBpZiAob2JqLl9pc1Z1ZSkge1xuICAgICAgZGVsZXRlIG9iai5fZGF0YVtrZXldXG4gICAgICBvYmouJGZvcmNlVXBkYXRlKClcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpXG4gIGlmIChvYi52bXMpIHtcbiAgICBsZXQgaSA9IG9iLnZtcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCB2bSA9IG9iLnZtc1tpXVxuICAgICAgdW5wcm94eSh2bSwga2V5KVxuICAgICAgdm0uJGZvcmNlVXBkYXRlKClcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgS0VZX1dPUkRTID0gWyckaW5kZXgnLCAnJHZhbHVlJywgJyRldmVudCddXG5leHBvcnQgZnVuY3Rpb24gcHJveHkgKHZtLCBrZXkpIHtcbiAgaWYgKEtFWV9XT1JEUy5pbmRleE9mKGtleSkgPiAtMSB8fCAhaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZtLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICAgICAgcmV0dXJuIHZtLl9kYXRhW2tleV1cbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICAgICAgdm0uX2RhdGFba2V5XSA9IHZhbFxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVucHJveHkgKHZtLCBrZXkpIHtcbiAgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICBkZWxldGUgdm1ba2V5XVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvY29yZS9vYnNlcnZlci5qc1xuICoqLyIsIi8qIGVzbGludC1kaXNhYmxlICovXG5cbmltcG9ydCB7IGRlZiB9IGZyb20gJy4uL3V0aWwnXG5cbmNvbnN0IGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGVcbmV4cG9ydCBjb25zdCBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pXG5cbi8qKlxuICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gKi9cblxuO1tcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl1cbi5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIGNvbnN0IG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdXG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgLy8gYXZvaWQgbGVha2luZyBhcmd1bWVudHM6XG4gICAgLy8gaHR0cDovL2pzcGVyZi5jb20vY2xvc3VyZS13aXRoLWFyZ3VtZW50c1xuICAgIGxldCBpID0gYXJndW1lbnRzLmxlbmd0aFxuICAgIGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoaSlcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgY29uc3Qgb2IgPSB0aGlzLl9fb2JfX1xuICAgIGxldCBpbnNlcnRlZFxuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMilcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpXG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKVxuICAgIHJldHVybiByZXN1bHRcbiAgfSlcbn0pXG5cbi8qKlxuICogU3dhcCB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aCBhIG5ldyB2YWx1ZVxuICogYW5kIGVtaXRzIGNvcnJlc3BvbmRpbmcgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Kn0gLSByZXBsYWNlZCBlbGVtZW50XG4gKi9cblxuZGVmKFxuICBhcnJheVByb3RvLFxuICAnJHNldCcsXG4gIGZ1bmN0aW9uICRzZXQgKGluZGV4LCB2YWwpIHtcbiAgICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gaW5kZXggKyAxXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMSwgdmFsKVswXVxuICB9XG4pXG5cbi8qKlxuICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSB0aGUgZWxlbWVudCBhdCBnaXZlbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuZGVmKFxuICBhcnJheVByb3RvLFxuICAnJHJlbW92ZScsXG4gIGZ1bmN0aW9uICRyZW1vdmUgKGluZGV4KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF0aGlzLmxlbmd0aCkgcmV0dXJuXG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGluZGV4ID0gdGhpcy5pbmRleE9mKGluZGV4KVxuICAgIH1cbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG4pXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvY29yZS9hcnJheS5qc1xuICoqLyIsIi8qKlxuICogQGZpbGVPdmVydmlld1xuICogVmlld01vZGVsIHRlbXBsYXRlIHBhcnNlciAmIGRhdGEtYmluZGluZyBwcm9jZXNzXG4gKlxuICogcmVxdWlyZWQ6XG4gKiBpbmRleC5qczogVm1cbiAqIGRvbS1oZWxwZXIuanM6IGNyZWF0ZUVsZW1lbnQsIGNyZWF0ZUJsb2NrXG4gKiBkb20taGVscGVyLmpzOiBhdHRhY2hUYXJnZXQsIG1vdmVUYXJnZXQsIHJlbW92ZVRhcmdldFxuICogZGlyZWN0aXZlLmpzOiBiaW5kRWxlbWVudCwgYmluZFN1YlZtLCBzZXRJZCwgd2F0Y2hcbiAqIGV2ZW50cy5qczogJG9uXG4gKi9cblxuaW1wb3J0IHtcbiAgZXh0ZW5kLFxuICBpc09iamVjdCxcbiAgYmluZFxufSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IHtcbiAgaW5pdERhdGEsXG4gIGluaXRDb21wdXRlZFxufSBmcm9tICcuLi9jb3JlL3N0YXRlJ1xuaW1wb3J0IHtcbiAgYmluZEVsZW1lbnQsXG4gIHNldElkLFxuICBiaW5kU3ViVm0sXG4gIGJpbmRTdWJWbUFmdGVySW5pdGlhbGl6ZWQsXG4gIGFwcGx5TmFpdHZlQ29tcG9uZW50T3B0aW9ucyxcbiAgd2F0Y2hcbn0gZnJvbSAnLi9kaXJlY3RpdmUnXG5pbXBvcnQge1xuICBjcmVhdGVCbG9jayxcbiAgY3JlYXRlQm9keSxcbiAgY3JlYXRlRWxlbWVudCxcbiAgYXR0YWNoVGFyZ2V0LFxuICBtb3ZlVGFyZ2V0LFxuICByZW1vdmVUYXJnZXRcbn0gZnJvbSAnLi9kb20taGVscGVyJ1xuXG4vKipcbiAqIGJ1aWxkKGV4dGVybmFsRGlycylcbiAqICAgY3JlYXRlVm0oKVxuICogICBtZXJnZShleHRlcm5hbERpcnMsIGRpcnMpXG4gKiAgIGNvbXBpbGUodGVtcGxhdGUsIHBhcmVudE5vZGUpXG4gKiAgICAgaWYgKHR5cGUgaXMgY29udGVudCkgY3JlYXRlIGNvbnRlbnROb2RlXG4gKiAgICAgZWxzZSBpZiAoZGlycyBoYXZlIHYtZm9yKSBmb3JlYWNoIC0+IGNyZWF0ZSBjb250ZXh0XG4gKiAgICAgICAtPiBjb21waWxlKHRlbXBsYXRlV2l0aG91dEZvciwgcGFyZW50Tm9kZSk6IGRpZmYobGlzdCkgb25jaGFuZ2VcbiAqICAgICBlbHNlIGlmIChkaXJzIGhhdmUgdi1pZikgYXNzZXJ0XG4gKiAgICAgICAtPiBjb21waWxlKHRlbXBsYXRlV2l0aG91dElmLCBwYXJlbnROb2RlKTogdG9nZ2xlKHNob3duKSBvbmNoYW5nZVxuICogICAgIGVsc2UgaWYgKHR5cGUgaXMgZHluYW1pYylcbiAqICAgICAgIC0+IGNvbXBpbGUodGVtcGxhdGVXaXRob3V0RHluYW1pY1R5cGUsIHBhcmVudE5vZGUpOiB3YXRjaCh0eXBlKSBvbmNoYW5nZVxuICogICAgIGVsc2UgaWYgKHR5cGUgaXMgY3VzdG9tKVxuICogICAgICAgYWRkQ2hpbGRWbSh2bSwgcGFyZW50Vm0pXG4gKiAgICAgICBidWlsZChleHRlcm5hbERpcnMpXG4gKiAgICAgICBmb3JlYWNoIGNoaWxkTm9kZXMgLT4gY29tcGlsZShjaGlsZE5vZGUsIHRlbXBsYXRlKVxuICogICAgIGVsc2UgaWYgKHR5cGUgaXMgbmF0aXZlKVxuICogICAgICAgc2V0KGRpcnMpOiB1cGRhdGUoaWQvYXR0ci9zdHlsZS9jbGFzcykgb25jaGFuZ2VcbiAqICAgICAgIGFwcGVuZCh0ZW1wbGF0ZSwgcGFyZW50Tm9kZSlcbiAqICAgICAgIGZvcmVhY2ggY2hpbGROb2RlcyAtPiBjb21waWxlKGNoaWxkTm9kZSwgdGVtcGxhdGUpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZCAodm0pIHtcbiAgY29uc3Qgb3B0ID0gdm0uX29wdGlvbnMgfHwge31cbiAgY29uc3QgdGVtcGxhdGUgPSBvcHQudGVtcGxhdGUgfHwge31cblxuICBpZiAob3B0LnJlcGxhY2UpIHtcbiAgICBpZiAodGVtcGxhdGUuY2hpbGRyZW4gJiYgdGVtcGxhdGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb21waWxlKHZtLCB0ZW1wbGF0ZS5jaGlsZHJlblswXSwgdm0uX3BhcmVudEVsKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbXBpbGUodm0sIHRlbXBsYXRlLmNoaWxkcmVuLCB2bS5fcGFyZW50RWwpXG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGNvbXBpbGUodm0sIHRlbXBsYXRlLCB2bS5fcGFyZW50RWwpXG4gIH1cblxuICBjb25zb2xlLmRlYnVnKGBbSlMgRnJhbWV3b3JrXSBcInJlYWR5XCIgbGlmZWN5Y2xlIGluIFZtKCR7dm0uX3R5cGV9KWApXG4gIHZtLiRlbWl0KCdob29rOnJlYWR5JylcbiAgdm0uX3JlYWR5ID0gdHJ1ZVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGVsZW1lbnRzIGJ5IGNoaWxkIG9yIGNoaWxkcmVuIGFuZCBhcHBlbmQgdG8gcGFyZW50IGVsZW1lbnRzLlxuICogUm9vdCBlbGVtZW50IGluZm8gd291bGQgYmUgbWVyZ2VkIGlmIGhhcy4gVGhlIGZpcnN0IGFyZ3VtZW50IG1heSBiZSBhbiBhcnJheVxuICogaWYgdGhlIHJvb3QgZWxlbWVudCB3aXRoIG9wdGlvbnMucmVwbGFjZSBoYXMgbm90IG9ubHkgb25lIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGFycmF5fSB0YXJnZXRcbiAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICBkZXN0XG4gKiBAcGFyYW0ge29iamVjdH0gICAgICAgbWV0YVxuICovXG5mdW5jdGlvbiBjb21waWxlICh2bSwgdGFyZ2V0LCBkZXN0LCBtZXRhKSB7XG4gIGNvbnN0IGFwcCA9IHZtLl9hcHAgfHwge31cblxuICBpZiAoYXBwLmxhc3RTaWduYWwgPT09IC0xKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAodGFyZ2V0SXNGcmFnbWVudCh0YXJnZXQpKSB7XG4gICAgY29tcGlsZUZyYWdtZW50KHZtLCB0YXJnZXQsIGRlc3QsIG1ldGEpXG4gICAgcmV0dXJuXG4gIH1cbiAgbWV0YSA9IG1ldGEgfHwge31cbiAgaWYgKHRhcmdldElzQ29udGVudCh0YXJnZXQpKSB7XG4gICAgY29uc29sZS5kZWJ1ZygnW0pTIEZyYW1ld29ya10gY29tcGlsZSBcImNvbnRlbnRcIiBibG9jayBieScsIHRhcmdldClcbiAgICB2bS5fY29udGVudCA9IGNyZWF0ZUJsb2NrKHZtLCBkZXN0KVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHRhcmdldE5lZWRDaGVja1JlcGVhdCh0YXJnZXQsIG1ldGEpKSB7XG4gICAgY29uc29sZS5kZWJ1ZygnW0pTIEZyYW1ld29ya10gY29tcGlsZSBcInJlcGVhdFwiIGxvZ2ljIGJ5JywgdGFyZ2V0KVxuICAgIGNvbXBpbGVSZXBlYXQodm0sIHRhcmdldCwgZGVzdClcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodGFyZ2V0TmVlZENoZWNrU2hvd24odGFyZ2V0LCBtZXRhKSkge1xuICAgIGNvbnNvbGUuZGVidWcoJ1tKUyBGcmFtZXdvcmtdIGNvbXBpbGUgXCJpZlwiIGxvZ2ljIGJ5JywgdGFyZ2V0KVxuICAgIGNvbXBpbGVTaG93bih2bSwgdGFyZ2V0LCBkZXN0LCBtZXRhKVxuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHR5cGVHZXR0ZXIgPSBtZXRhLnR5cGUgfHwgdGFyZ2V0LnR5cGVcbiAgaWYgKHRhcmdldE5lZWRDaGVja1R5cGUodHlwZUdldHRlciwgbWV0YSkpIHtcbiAgICBjb21waWxlVHlwZSh2bSwgdGFyZ2V0LCBkZXN0LCB0eXBlR2V0dGVyLCBtZXRhKVxuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHR5cGUgPSB0eXBlR2V0dGVyXG4gIGNvbnN0IGNvbXBvbmVudCA9IHRhcmdldElzQ29tcG9zZWQodm0sIHRhcmdldCwgdHlwZSlcbiAgaWYgKGNvbXBvbmVudCkge1xuICAgIGNvbnNvbGUuZGVidWcoJ1tKUyBGcmFtZXdvcmtdIGNvbXBpbGUgY29tcG9zZWQgY29tcG9uZW50IGJ5JywgdGFyZ2V0KVxuICAgIGNvbXBpbGVDdXN0b21Db21wb25lbnQodm0sIGNvbXBvbmVudCwgdGFyZ2V0LCBkZXN0LCB0eXBlLCBtZXRhKVxuICAgIHJldHVyblxuICB9XG4gIGNvbnNvbGUuZGVidWcoJ1tKUyBGcmFtZXdvcmtdIGNvbXBpbGUgbmF0aXZlIGNvbXBvbmVudCBieScsIHRhcmdldClcbiAgY29tcGlsZU5hdGl2ZUNvbXBvbmVudCh2bSwgdGFyZ2V0LCBkZXN0LCB0eXBlKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRhcmdldCBpcyBhIGZyYWdtZW50IChhbiBhcnJheSkuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSAgdGFyZ2V0XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB0YXJnZXRJc0ZyYWdtZW50ICh0YXJnZXQpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGFyZ2V0KVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRhcmdldCB0eXBlIGlzIGNvbnRlbnQvc2xvdC5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9ICB0YXJnZXRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHRhcmdldElzQ29udGVudCAodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQudHlwZSA9PT0gJ2NvbnRlbnQnIHx8IHRhcmdldC50eXBlID09PSAnc2xvdCdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0YXJnZXQgbmVlZCB0byBjb21waWxlIGJ5IGEgbGlzdC5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9ICB0YXJnZXRcbiAqIEBwYXJhbSAge29iamVjdH0gIG1ldGFcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHRhcmdldE5lZWRDaGVja1JlcGVhdCAodGFyZ2V0LCBtZXRhKSB7XG4gIHJldHVybiAhbWV0YS5oYXNPd25Qcm9wZXJ0eSgncmVwZWF0JykgJiYgdGFyZ2V0LnJlcGVhdFxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRhcmdldCBuZWVkIHRvIGNvbXBpbGUgYnkgYSBib29sZWFuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gIHRhcmdldFxuICogQHBhcmFtICB7b2JqZWN0fSAgbWV0YVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdGFyZ2V0TmVlZENoZWNrU2hvd24gKHRhcmdldCwgbWV0YSkge1xuICByZXR1cm4gIW1ldGEuaGFzT3duUHJvcGVydHkoJ3Nob3duJykgJiYgdGFyZ2V0LnNob3duXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGFyZ2V0IG5lZWQgdG8gY29tcGlsZSBieSBhIGR5bmFtaWMgdHlwZS5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd8ZnVuY3Rpb259IHR5cGVHZXR0ZXJcbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgbWV0YVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdGFyZ2V0TmVlZENoZWNrVHlwZSAodHlwZUdldHRlciwgbWV0YSkge1xuICByZXR1cm4gKHR5cGVvZiB0eXBlR2V0dGVyID09PSAnZnVuY3Rpb24nKSAmJiAhbWV0YS5oYXNPd25Qcm9wZXJ0eSgndHlwZScpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBraW5kIG9mIGNvbXBvbmVudCBpcyBjb21wb3NlZC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB0YXJnZXRJc0NvbXBvc2VkICh2bSwgdGFyZ2V0LCB0eXBlKSB7XG4gIGxldCBjb21wb25lbnRcbiAgaWYgKHZtLl9hcHAgJiYgdm0uX2FwcC5jdXN0b21Db21wb25lbnRNYXApIHtcbiAgICBjb21wb25lbnQgPSB2bS5fYXBwLmN1c3RvbUNvbXBvbmVudE1hcFt0eXBlXVxuICB9XG4gIGlmICh2bS5fb3B0aW9ucyAmJiB2bS5fb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgY29tcG9uZW50ID0gdm0uX29wdGlvbnMuY29tcG9uZW50c1t0eXBlXVxuICB9XG4gIGlmICh0YXJnZXQuY29tcG9uZW50KSB7XG4gICAgY29tcG9uZW50ID0gY29tcG9uZW50IHx8IHt9XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudFxufVxuXG4vKipcbiAqIENvbXBpbGUgYSBsaXN0IG9mIHRhcmdldHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtvYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVGcmFnbWVudCAodm0sIHRhcmdldCwgZGVzdCwgbWV0YSkge1xuICBjb25zdCBmcmFnQmxvY2sgPSBjcmVhdGVCbG9jayh2bSwgZGVzdClcbiAgdGFyZ2V0LmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgY29tcGlsZSh2bSwgY2hpbGQsIGZyYWdCbG9jaywgbWV0YSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgdGFyZ2V0IHdpdGggcmVwZWF0IGRpcmVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge29iamVjdH0gZGVzdFxuICovXG5mdW5jdGlvbiBjb21waWxlUmVwZWF0ICh2bSwgdGFyZ2V0LCBkZXN0KSB7XG4gIGNvbnN0IHJlcGVhdCA9IHRhcmdldC5yZXBlYXRcbiAgY29uc3Qgb2xkU3R5bGUgPSB0eXBlb2YgcmVwZWF0ID09PSAnZnVuY3Rpb24nXG4gIGxldCBnZXR0ZXIgPSByZXBlYXQuZ2V0dGVyIHx8IHJlcGVhdC5leHByZXNzaW9uIHx8IHJlcGVhdFxuICBpZiAodHlwZW9mIGdldHRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGdldHRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH1cbiAgfVxuICBjb25zdCBrZXkgPSByZXBlYXQua2V5IHx8ICckaW5kZXgnXG4gIGNvbnN0IHZhbHVlID0gcmVwZWF0LnZhbHVlIHx8ICckdmFsdWUnXG4gIGNvbnN0IHRyYWNrQnkgPSByZXBlYXQudHJhY2tCeSB8fCB0YXJnZXQudHJhY2tCeSB8fFxuICAgICh0YXJnZXQuYXR0ciAmJiB0YXJnZXQuYXR0ci50cmFja0J5KVxuXG4gIGNvbnN0IGZyYWdCbG9jayA9IGNyZWF0ZUJsb2NrKHZtLCBkZXN0KVxuICBmcmFnQmxvY2suY2hpbGRyZW4gPSBbXVxuICBmcmFnQmxvY2suZGF0YSA9IFtdXG4gIGZyYWdCbG9jay52bXMgPSBbXVxuXG4gIGJpbmRSZXBlYXQodm0sIHRhcmdldCwgZnJhZ0Jsb2NrLCB7IGdldHRlciwga2V5LCB2YWx1ZSwgdHJhY2tCeSwgb2xkU3R5bGUgfSlcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgdGFyZ2V0IHdpdGggaWYgZGlyZWN0aXZlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge29iamVjdH0gbWV0YVxuICovXG5mdW5jdGlvbiBjb21waWxlU2hvd24gKHZtLCB0YXJnZXQsIGRlc3QsIG1ldGEpIHtcbiAgY29uc3QgbmV3TWV0YSA9IHsgc2hvd246IHRydWUgfVxuICBjb25zdCBmcmFnQmxvY2sgPSBjcmVhdGVCbG9jayh2bSwgZGVzdClcblxuICBpZiAoZGVzdC5lbGVtZW50ICYmIGRlc3QuY2hpbGRyZW4pIHtcbiAgICBkZXN0LmNoaWxkcmVuLnB1c2goZnJhZ0Jsb2NrKVxuICB9XG5cbiAgaWYgKG1ldGEucmVwZWF0KSB7XG4gICAgbmV3TWV0YS5yZXBlYXQgPSBtZXRhLnJlcGVhdFxuICB9XG5cbiAgYmluZFNob3duKHZtLCB0YXJnZXQsIGZyYWdCbG9jaywgbmV3TWV0YSlcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgdGFyZ2V0IHdpdGggZHluYW1pYyBjb21wb25lbnQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gICB0YXJnZXRcbiAqIEBwYXJhbSB7b2JqZWN0fSAgIGRlc3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR5cGVHZXR0ZXJcbiAqL1xuZnVuY3Rpb24gY29tcGlsZVR5cGUgKHZtLCB0YXJnZXQsIGRlc3QsIHR5cGVHZXR0ZXIsIG1ldGEpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVHZXR0ZXIuY2FsbCh2bSlcbiAgY29uc3QgbmV3TWV0YSA9IGV4dGVuZCh7IHR5cGUgfSwgbWV0YSlcbiAgY29uc3QgZnJhZ0Jsb2NrID0gY3JlYXRlQmxvY2sodm0sIGRlc3QpXG5cbiAgaWYgKGRlc3QuZWxlbWVudCAmJiBkZXN0LmNoaWxkcmVuKSB7XG4gICAgZGVzdC5jaGlsZHJlbi5wdXNoKGZyYWdCbG9jaylcbiAgfVxuXG4gIHdhdGNoKHZtLCB0eXBlR2V0dGVyLCAodmFsdWUpID0+IHtcbiAgICBjb25zdCBuZXdNZXRhID0gZXh0ZW5kKHsgdHlwZTogdmFsdWUgfSwgbWV0YSlcbiAgICByZW1vdmVUYXJnZXQodm0sIGZyYWdCbG9jaywgdHJ1ZSlcbiAgICBjb21waWxlKHZtLCB0YXJnZXQsIGZyYWdCbG9jaywgbmV3TWV0YSlcbiAgfSlcblxuICBjb21waWxlKHZtLCB0YXJnZXQsIGZyYWdCbG9jaywgbmV3TWV0YSlcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgY29tcG9zZWQgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjb21waWxlQ3VzdG9tQ29tcG9uZW50ICh2bSwgY29tcG9uZW50LCB0YXJnZXQsIGRlc3QsIHR5cGUsIG1ldGEpIHtcbiAgY29uc3QgQ3RvciA9IHZtLmNvbnN0cnVjdG9yXG4gIGNvbnN0IHN1YlZtID0gbmV3IEN0b3IodHlwZSwgY29tcG9uZW50LCB2bSwgZGVzdCwgdW5kZWZpbmVkLCB7XG4gICAgJ2hvb2s6aW5pdCc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldElkKHZtLCBudWxsLCB0YXJnZXQuaWQsIHRoaXMpXG4gICAgICAvLyBiaW5kIHRlbXBsYXRlIGVhcmxpZXIgYmVjYXVzZSBvZiBsaWZlY3ljbGUgaXNzdWVzXG4gICAgICB0aGlzLl9leHRlcm5hbEJpbmRpbmcgPSB7XG4gICAgICAgIHBhcmVudDogdm0sXG4gICAgICAgIHRlbXBsYXRlOiB0YXJnZXRcbiAgICAgIH1cbiAgICB9LFxuICAgICdob29rOmNyZWF0ZWQnOiBmdW5jdGlvbiAoKSB7XG4gICAgICBiaW5kU3ViVm0odm0sIHRoaXMsIHRhcmdldCwgbWV0YS5yZXBlYXQpXG4gICAgfSxcbiAgICAnaG9vazpyZWFkeSc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICAgIGNvbXBpbGVDaGlsZHJlbih2bSwgdGFyZ2V0LCB0aGlzLl9jb250ZW50KVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgYmluZFN1YlZtQWZ0ZXJJbml0aWFsaXplZCh2bSwgc3ViVm0sIHRhcmdldClcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBlbGVtZW50IGZyb20gdGVtcGxhdGUgYW5kIGF0dGFjaCB0byB0aGUgZGVzdCBpZiBuZWVkZWQuXG4gKiBUaGUgdGltZSB0byBhdHRhY2ggZGVwZW5kcyBvbiB3aGV0aGVyIHRoZSBtb2RlIHN0YXR1cyBpcyBub2RlIG9yIHRyZWUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHRlbXBsYXRlXG4gKiBAcGFyYW0ge29iamVjdH0gZGVzdFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY29tcGlsZU5hdGl2ZUNvbXBvbmVudCAodm0sIHRlbXBsYXRlLCBkZXN0LCB0eXBlKSB7XG4gIGFwcGx5TmFpdHZlQ29tcG9uZW50T3B0aW9ucyh0ZW1wbGF0ZSlcblxuICBsZXQgZWxlbWVudFxuICBpZiAoZGVzdC5yZWYgPT09ICdfZG9jdW1lbnRFbGVtZW50Jykge1xuICAgIC8vIGlmIGl0cyBwYXJlbnQgaXMgZG9jdW1lbnRFbGVtZW50IHRoZW4gaXQncyBhIGJvZHlcbiAgICBjb25zb2xlLmRlYnVnKGBbSlMgRnJhbWV3b3JrXSBjb21waWxlIHRvIGNyZWF0ZSBib2R5IGZvciAke3R5cGV9YClcbiAgICBlbGVtZW50ID0gY3JlYXRlQm9keSh2bSwgdHlwZSlcbiAgfVxuICBlbHNlIHtcbiAgICBjb25zb2xlLmRlYnVnKGBbSlMgRnJhbWV3b3JrXSBjb21waWxlIHRvIGNyZWF0ZSBlbGVtZW50IGZvciAke3R5cGV9YClcbiAgICBlbGVtZW50ID0gY3JlYXRlRWxlbWVudCh2bSwgdHlwZSlcbiAgfVxuXG4gIGlmICghdm0uX3Jvb3RFbCkge1xuICAgIHZtLl9yb290RWwgPSBlbGVtZW50XG4gICAgLy8gYmluZCBldmVudCBlYXJsaWVyIGJlY2F1c2Ugb2YgbGlmZWN5Y2xlIGlzc3Vlc1xuICAgIGNvbnN0IGJpbmRpbmcgPSB2bS5fZXh0ZXJuYWxCaW5kaW5nIHx8IHt9XG4gICAgY29uc3QgdGFyZ2V0ID0gYmluZGluZy50ZW1wbGF0ZVxuICAgIGNvbnN0IHBhcmVudFZtID0gYmluZGluZy5wYXJlbnRcbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5ldmVudHMgJiYgcGFyZW50Vm0gJiYgZWxlbWVudCkge1xuICAgICAgZm9yIChjb25zdCB0eXBlIGluIHRhcmdldC5ldmVudHMpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHBhcmVudFZtW3RhcmdldC5ldmVudHNbdHlwZV1dXG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudCh0eXBlLCBiaW5kKGhhbmRsZXIsIHBhcmVudFZtKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGJpbmRFbGVtZW50KHZtLCBlbGVtZW50LCB0ZW1wbGF0ZSlcblxuICBpZiAodGVtcGxhdGUuYXR0ciAmJiB0ZW1wbGF0ZS5hdHRyLmFwcGVuZCkgeyAvLyBiYWNrd2FyZCwgYXBwZW5kIHByb3AgaW4gYXR0clxuICAgIHRlbXBsYXRlLmFwcGVuZCA9IHRlbXBsYXRlLmF0dHIuYXBwZW5kXG4gIH1cblxuICBpZiAodGVtcGxhdGUuYXBwZW5kKSB7IC8vIGdpdmUgdGhlIGFwcGVuZCBhdHRyaWJ1dGUgZm9yIGlvcyBhZGFwdGF0aW9uXG4gICAgZWxlbWVudC5hdHRyID0gZWxlbWVudC5hdHRyIHx8IHt9XG4gICAgZWxlbWVudC5hdHRyLmFwcGVuZCA9IHRlbXBsYXRlLmFwcGVuZFxuICB9XG5cbiAgY29uc3QgdHJlZU1vZGUgPSB0ZW1wbGF0ZS5hcHBlbmQgPT09ICd0cmVlJ1xuICBjb25zdCBhcHAgPSB2bS5fYXBwIHx8IHt9XG4gIGlmIChhcHAubGFzdFNpZ25hbCAhPT0gLTEgJiYgIXRyZWVNb2RlKSB7XG4gICAgY29uc29sZS5kZWJ1ZygnW0pTIEZyYW1ld29ya10gY29tcGlsZSB0byBhcHBlbmQgc2luZ2xlIG5vZGUgZm9yJywgZWxlbWVudClcbiAgICBhcHAubGFzdFNpZ25hbCA9IGF0dGFjaFRhcmdldCh2bSwgZWxlbWVudCwgZGVzdClcbiAgfVxuICBpZiAoYXBwLmxhc3RTaWduYWwgIT09IC0xKSB7XG4gICAgY29tcGlsZUNoaWxkcmVuKHZtLCB0ZW1wbGF0ZSwgZWxlbWVudClcbiAgfVxuICBpZiAoYXBwLmxhc3RTaWduYWwgIT09IC0xICYmIHRyZWVNb2RlKSB7XG4gICAgY29uc29sZS5kZWJ1ZygnW0pTIEZyYW1ld29ya10gY29tcGlsZSB0byBhcHBlbmQgd2hvbGUgdHJlZSBmb3InLCBlbGVtZW50KVxuICAgIGFwcC5sYXN0U2lnbmFsID0gYXR0YWNoVGFyZ2V0KHZtLCBlbGVtZW50LCBkZXN0KVxuICB9XG59XG5cbi8qKlxuICogU2V0IGFsbCBjaGlsZHJlbiB0byBhIGNlcnRhaW4gcGFyZW50IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHRlbXBsYXRlXG4gKiBAcGFyYW0ge29iamVjdH0gZGVzdFxuICovXG5mdW5jdGlvbiBjb21waWxlQ2hpbGRyZW4gKHZtLCB0ZW1wbGF0ZSwgZGVzdCkge1xuICBjb25zdCBhcHAgPSB2bS5fYXBwIHx8IHt9XG4gIGNvbnN0IGNoaWxkcmVuID0gdGVtcGxhdGUuY2hpbGRyZW5cbiAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGNoaWxkcmVuLmV2ZXJ5KChjaGlsZCkgPT4ge1xuICAgICAgY29tcGlsZSh2bSwgY2hpbGQsIGRlc3QpXG4gICAgICByZXR1cm4gYXBwLmxhc3RTaWduYWwgIT09IC0xXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIFdhdGNoIHRoZSBsaXN0IHVwZGF0ZSBhbmQgcmVmcmVzaCB0aGUgY2hhbmdlcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge29iamVjdH0gZnJhZ0Jsb2NrIHt2bXMsIGRhdGEsIGNoaWxkcmVufVxuICogQHBhcmFtIHtvYmplY3R9IGluZm8gICAgICB7Z2V0dGVyLCBrZXksIHZhbHVlLCB0cmFja0J5LCBvbGRTdHlsZX1cbiAqL1xuZnVuY3Rpb24gYmluZFJlcGVhdCAodm0sIHRhcmdldCwgZnJhZ0Jsb2NrLCBpbmZvKSB7XG4gIGNvbnN0IHZtcyA9IGZyYWdCbG9jay52bXNcbiAgY29uc3QgY2hpbGRyZW4gPSBmcmFnQmxvY2suY2hpbGRyZW5cbiAgY29uc3QgeyBnZXR0ZXIsIHRyYWNrQnksIG9sZFN0eWxlIH0gPSBpbmZvXG4gIGNvbnN0IGtleU5hbWUgPSBpbmZvLmtleVxuICBjb25zdCB2YWx1ZU5hbWUgPSBpbmZvLnZhbHVlXG5cbiAgZnVuY3Rpb24gY29tcGlsZUl0ZW0gKGl0ZW0sIGluZGV4LCBjb250ZXh0KSB7XG4gICAgbGV0IG1lcmdlZERhdGFcbiAgICBpZiAob2xkU3R5bGUpIHtcbiAgICAgIG1lcmdlZERhdGEgPSBpdGVtXG4gICAgICBpZiAoaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgbWVyZ2VkRGF0YVtrZXlOYW1lXSA9IGluZGV4XG4gICAgICAgIGlmICghbWVyZ2VkRGF0YS5oYXNPd25Qcm9wZXJ0eSgnSU5ERVgnKSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXJnZWREYXRhLCAnSU5ERVgnLCB7XG4gICAgICAgICAgICB2YWx1ZTogKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tKUyBGcmFtZXdvcmtdIFwiSU5ERVhcIiBpbiByZXBlYXQgaXMgZGVwcmVjYXRlZCwgJyArXG4gICAgICAgICAgICAgICAgJ3BsZWFzZSB1c2UgXCIkaW5kZXhcIiBpbnN0ZWFkJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbSlMgRnJhbWV3b3JrXSBFYWNoIGxpc3QgaXRlbSBtdXN0IGJlIGFuIG9iamVjdCBpbiBvbGQtc3R5bGUgcmVwZWF0LCAnXG4gICAgICAgICAgKyAncGxlYXNlIHVzZSBgcmVwZWF0PXt7diBpbiBsaXN0fX1gIGluc3RlYWQuJylcbiAgICAgICAgbWVyZ2VkRGF0YSA9IHt9XG4gICAgICAgIG1lcmdlZERhdGFba2V5TmFtZV0gPSBpbmRleFxuICAgICAgICBtZXJnZWREYXRhW3ZhbHVlTmFtZV0gPSBpdGVtXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbWVyZ2VkRGF0YSA9IHt9XG4gICAgICBtZXJnZWREYXRhW2tleU5hbWVdID0gaW5kZXhcbiAgICAgIG1lcmdlZERhdGFbdmFsdWVOYW1lXSA9IGl0ZW1cbiAgICB9XG4gICAgY29uc3QgbmV3Q29udGV4dCA9IG1lcmdlQ29udGV4dChjb250ZXh0LCBtZXJnZWREYXRhKVxuICAgIHZtcy5wdXNoKG5ld0NvbnRleHQpXG4gICAgY29tcGlsZShuZXdDb250ZXh0LCB0YXJnZXQsIGZyYWdCbG9jaywgeyByZXBlYXQ6IGl0ZW0gfSlcbiAgfVxuXG4gIGNvbnN0IGxpc3QgPSB3YXRjaEJsb2NrKHZtLCBmcmFnQmxvY2ssIGdldHRlciwgJ3JlcGVhdCcsXG4gICAgKGRhdGEpID0+IHtcbiAgICAgIGNvbnNvbGUuZGVidWcoJ1tKUyBGcmFtZXdvcmtdIHRoZSBcInJlcGVhdFwiIGl0ZW0gaGFzIGNoYW5nZWQnLCBkYXRhKVxuICAgICAgaWYgKCFmcmFnQmxvY2spIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9sZENoaWxkcmVuID0gY2hpbGRyZW4uc2xpY2UoKVxuICAgICAgY29uc3Qgb2xkVm1zID0gdm1zLnNsaWNlKClcbiAgICAgIGNvbnN0IG9sZERhdGEgPSBmcmFnQmxvY2suZGF0YS5zbGljZSgpXG4gICAgICAvLyAxLiBjb2xsZWN0IGFsbCBuZXcgcmVmcyB0cmFjayBieVxuICAgICAgY29uc3QgdHJhY2tNYXAgPSB7fVxuICAgICAgY29uc3QgcmV1c2VkTWFwID0ge31cbiAgICAgIGRhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gdHJhY2tCeSA/IGl0ZW1bdHJhY2tCeV0gOiAob2xkU3R5bGUgPyBpdGVtW2tleU5hbWVdIDogaW5kZXgpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoa2V5ID09IG51bGwgfHwga2V5ID09PSAnJykge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHRyYWNrTWFwW2tleV0gPSBpdGVtXG4gICAgICB9KVxuXG4gICAgICAvLyAyLiByZW1vdmUgdW51c2VkIGVsZW1lbnQgZm9yZWFjaCBvbGQgaXRlbVxuICAgICAgY29uc3QgcmV1c2VkTGlzdCA9IFtdXG4gICAgICBvbGREYXRhLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRyYWNrQnkgPyBpdGVtW3RyYWNrQnldIDogKG9sZFN0eWxlID8gaXRlbVtrZXlOYW1lXSA6IGluZGV4KVxuICAgICAgICBpZiAodHJhY2tNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHJldXNlZE1hcFtrZXldID0ge1xuICAgICAgICAgICAgaXRlbSwgaW5kZXgsIGtleSxcbiAgICAgICAgICAgIHRhcmdldDogb2xkQ2hpbGRyZW5baW5kZXhdLFxuICAgICAgICAgICAgdm06IG9sZFZtc1tpbmRleF1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV1c2VkTGlzdC5wdXNoKGl0ZW0pXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlVGFyZ2V0KHZtLCBvbGRDaGlsZHJlbltpbmRleF0pXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8vIDMuIGNyZWF0ZSBuZXcgZWxlbWVudCBmb3JlYWNoIG5ldyBpdGVtXG4gICAgICBjaGlsZHJlbi5sZW5ndGggPSAwXG4gICAgICB2bXMubGVuZ3RoID0gMFxuICAgICAgZnJhZ0Jsb2NrLmRhdGEgPSBkYXRhLnNsaWNlKClcbiAgICAgIGZyYWdCbG9jay51cGRhdGVNYXJrID0gZnJhZ0Jsb2NrLnN0YXJ0XG5cbiAgICAgIGRhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gdHJhY2tCeSA/IGl0ZW1bdHJhY2tCeV0gOiAob2xkU3R5bGUgPyBpdGVtW2tleU5hbWVdIDogaW5kZXgpXG4gICAgICAgIGNvbnN0IHJldXNlZCA9IHJldXNlZE1hcFtrZXldXG4gICAgICAgIGlmIChyZXVzZWQpIHtcbiAgICAgICAgICBpZiAocmV1c2VkLml0ZW0gPT09IHJldXNlZExpc3RbMF0pIHtcbiAgICAgICAgICAgIHJldXNlZExpc3Quc2hpZnQoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldXNlZExpc3QuJHJlbW92ZShyZXVzZWQuaXRlbSlcbiAgICAgICAgICAgIG1vdmVUYXJnZXQodm0sIHJldXNlZC50YXJnZXQsIGZyYWdCbG9jay51cGRhdGVNYXJrLCB0cnVlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHJldXNlZC50YXJnZXQpXG4gICAgICAgICAgdm1zLnB1c2gocmV1c2VkLnZtKVxuICAgICAgICAgIGlmIChvbGRTdHlsZSkge1xuICAgICAgICAgICAgcmV1c2VkLnZtID0gaXRlbVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldXNlZC52bVt2YWx1ZU5hbWVdID0gaXRlbVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXVzZWQudm1ba2V5TmFtZV0gPSBpbmRleFxuICAgICAgICAgIGZyYWdCbG9jay51cGRhdGVNYXJrID0gcmV1c2VkLnRhcmdldFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbXBpbGVJdGVtKGl0ZW0sIGluZGV4LCB2bSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgZGVsZXRlIGZyYWdCbG9jay51cGRhdGVNYXJrXG4gICAgfVxuICApXG5cbiAgZnJhZ0Jsb2NrLmRhdGEgPSBsaXN0LnNsaWNlKDApXG4gIGxpc3QuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICBjb21waWxlSXRlbShpdGVtLCBpbmRleCwgdm0pXG4gIH0pXG59XG5cbi8qKlxuICogV2F0Y2ggdGhlIGRpc3BsYXkgdXBkYXRlIGFuZCBhZGQvcmVtb3ZlIHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gIHtvYmplY3R9IGZyYWdCbG9ja1xuICogQHBhcmFtICB7b2JqZWN0fSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGJpbmRTaG93biAodm0sIHRhcmdldCwgZnJhZ0Jsb2NrLCBtZXRhKSB7XG4gIGNvbnN0IGRpc3BsYXkgPSB3YXRjaEJsb2NrKHZtLCBmcmFnQmxvY2ssIHRhcmdldC5zaG93biwgJ3Nob3duJyxcbiAgICAoZGlzcGxheSkgPT4ge1xuICAgICAgY29uc29sZS5kZWJ1ZygnW0pTIEZyYW1ld29ya10gdGhlIFwiaWZcIiBpdGVtIHdhcyBjaGFuZ2VkJywgZGlzcGxheSlcblxuICAgICAgaWYgKCFmcmFnQmxvY2sgfHwgISFmcmFnQmxvY2suZGlzcGxheSA9PT0gISFkaXNwbGF5KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZnJhZ0Jsb2NrLmRpc3BsYXkgPSAhIWRpc3BsYXlcbiAgICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICAgIGNvbXBpbGUodm0sIHRhcmdldCwgZnJhZ0Jsb2NrLCBtZXRhKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZVRhcmdldCh2bSwgZnJhZ0Jsb2NrLCB0cnVlKVxuICAgICAgfVxuICAgIH1cbiAgKVxuXG4gIGZyYWdCbG9jay5kaXNwbGF5ID0gISFkaXNwbGF5XG4gIGlmIChkaXNwbGF5KSB7XG4gICAgY29tcGlsZSh2bSwgdGFyZ2V0LCBmcmFnQmxvY2ssIG1ldGEpXG4gIH1cbn1cblxuLyoqXG4gKiBXYXRjaCBjYWxjIHZhbHVlIGNoYW5nZXMgYW5kIGFwcGVuZCBjZXJ0YWluIHR5cGUgYWN0aW9uIHRvIGRpZmZlci5cbiAqIEl0IGlzIHVzZWQgZm9yIGlmIG9yIHJlcGVhdCBkYXRhLWJpbmRpbmcgZ2VuZXJhdG9yLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gICBmcmFnQmxvY2tcbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxjXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgdHlwZVxuICogQHBhcmFtICB7ZnVuY3Rpb259IGhhbmRsZXJcbiAqIEByZXR1cm4ge2FueX0gICAgICBpbml0IHZhbHVlIG9mIGNhbGNcbiAqL1xuZnVuY3Rpb24gd2F0Y2hCbG9jayAodm0sIGZyYWdCbG9jaywgY2FsYywgdHlwZSwgaGFuZGxlcikge1xuICBjb25zdCBkaWZmZXIgPSB2bSAmJiB2bS5fYXBwICYmIHZtLl9hcHAuZGlmZmVyXG4gIGNvbnN0IGNvbmZpZyA9IHt9XG4gIGNvbnN0IGRlcHRoID0gKGZyYWdCbG9jay5lbGVtZW50LmRlcHRoIHx8IDApICsgMVxuXG4gIHJldHVybiB3YXRjaCh2bSwgY2FsYywgKHZhbHVlKSA9PiB7XG4gICAgY29uZmlnLmxhdGVzdFZhbHVlID0gdmFsdWVcbiAgICBpZiAoZGlmZmVyICYmICFjb25maWcucmVjb3JkZWQpIHtcbiAgICAgIGRpZmZlci5hcHBlbmQodHlwZSwgZGVwdGgsIGZyYWdCbG9jay5ibG9ja0lkLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhdGVzdFZhbHVlID0gY29uZmlnLmxhdGVzdFZhbHVlXG4gICAgICAgIGhhbmRsZXIobGF0ZXN0VmFsdWUpXG4gICAgICAgIGNvbmZpZy5yZWNvcmRlZCA9IGZhbHNlXG4gICAgICAgIGNvbmZpZy5sYXRlc3RWYWx1ZSA9IHVuZGVmaW5lZFxuICAgICAgfSlcbiAgICB9XG4gICAgY29uZmlnLnJlY29yZGVkID0gdHJ1ZVxuICB9KVxufVxuXG4vKipcbiAqIENsb25lIGEgY29udGV4dCBhbmQgbWVyZ2UgY2VydGFpbiBkYXRhLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gbWVyZ2VkRGF0YVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtZXJnZUNvbnRleHQgKGNvbnRleHQsIG1lcmdlZERhdGEpIHtcbiAgY29uc3QgbmV3Q29udGV4dCA9IE9iamVjdC5jcmVhdGUoY29udGV4dClcbiAgbmV3Q29udGV4dC5fZGF0YSA9IG1lcmdlZERhdGFcbiAgaW5pdERhdGEobmV3Q29udGV4dClcbiAgaW5pdENvbXB1dGVkKG5ld0NvbnRleHQpXG4gIG5ld0NvbnRleHQuX3JlYWxQYXJlbnQgPSBjb250ZXh0XG4gIHJldHVybiBuZXdDb250ZXh0XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvdm0vY29tcGlsZXIuanNcbiAqKi8iLCIvKipcbiAqIEBmaWxlT3ZlcnZpZXdcbiAqIERpcmVjdGl2ZSBQYXJzZXJcbiAqL1xuXG5pbXBvcnQgeyBiaW5kLCB0eXBvZiB9IGZyb20gJy4uL3V0aWwnXG5cbmltcG9ydCBXYXRjaGVyIGZyb20gJy4uL2NvcmUvd2F0Y2hlcidcbmltcG9ydCBjb25maWcgZnJvbSAnLi4vY29uZmlnJ1xuXG5jb25zdCB7IG5hdGl2ZUNvbXBvbmVudE1hcCB9ID0gY29uZmlnXG5cbmNvbnN0IFNFVFRFUlMgPSB7XG4gIGF0dHI6ICdzZXRBdHRyJyxcbiAgc3R5bGU6ICdzZXRTdHlsZScsXG4gIGV2ZW50OiAnYWRkRXZlbnQnXG59XG5cbi8qKlxuICogYXBwbHkgdGhlIG5hdGl2ZSBjb21wb25lbnQncyBvcHRpb25zKHNwZWNpZmllZCBieSB0ZW1wbGF0ZS50eXBlKVxuICogdG8gdGhlIHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseU5haXR2ZUNvbXBvbmVudE9wdGlvbnMgKHRlbXBsYXRlKSB7XG4gIGNvbnN0IHsgdHlwZSB9ID0gdGVtcGxhdGVcbiAgY29uc3Qgb3B0aW9ucyA9IG5hdGl2ZUNvbXBvbmVudE1hcFt0eXBlXVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAodGVtcGxhdGVba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHRlbXBsYXRlW2tleV0gPSBvcHRpb25zW2tleV1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cG9mKHRlbXBsYXRlW2tleV0pID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBvZihvcHRpb25zW2tleV0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YmtleSBpbiBvcHRpb25zW2tleV0pIHtcbiAgICAgICAgICBpZiAodGVtcGxhdGVba2V5XVtzdWJrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlW2tleV1bc3Via2V5XSA9IG9wdGlvbnNba2V5XVtzdWJrZXldXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogYmluZCBhbGwgaWQsIGF0dHIsIGNsYXNzbmFtZXMsIHN0eWxlLCBldmVudHMgdG8gYW4gZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZEVsZW1lbnQgKHZtLCBlbCwgdGVtcGxhdGUpIHtcbiAgc2V0SWQodm0sIGVsLCB0ZW1wbGF0ZS5pZCwgdm0pXG4gIHNldEF0dHIodm0sIGVsLCB0ZW1wbGF0ZS5hdHRyKVxuICBzZXRDbGFzcyh2bSwgZWwsIHRlbXBsYXRlLmNsYXNzTGlzdClcbiAgc2V0U3R5bGUodm0sIGVsLCB0ZW1wbGF0ZS5zdHlsZSlcbiAgYmluZEV2ZW50cyh2bSwgZWwsIHRlbXBsYXRlLmV2ZW50cylcbn1cblxuLyoqXG4gKiBiaW5kIGFsbCBwcm9wcyB0byBzdWIgdm0gYW5kIGJpbmQgYWxsIHN0eWxlLCBldmVudHMgdG8gdGhlIHJvb3QgZWxlbWVudFxuICogb2YgdGhlIHN1YiB2bSBpZiBpdCBkb2Vzbid0IGhhdmUgYSByZXBsYWNlZCBtdWx0aS1ub2RlIGZyYWdtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kU3ViVm0gKHZtLCBzdWJWbSwgdGVtcGxhdGUsIHJlcGVhdEl0ZW0pIHtcbiAgc3ViVm0gPSBzdWJWbSB8fCB7fVxuICB0ZW1wbGF0ZSA9IHRlbXBsYXRlIHx8IHt9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHN1YlZtLl9vcHRpb25zIHx8IHt9XG5cbiAgLy8gYmluZCBwcm9wc1xuICBsZXQgcHJvcHMgPSBvcHRpb25zLnByb3BzXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgcHJvcHMgPSBwcm9wcy5yZWR1Y2UoKHJlc3VsdCwgdmFsdWUpID0+IHtcbiAgICAgIHJlc3VsdFt2YWx1ZV0gPSB0cnVlXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSwge30pXG4gIH1cblxuICBtZXJnZVByb3BzKHJlcGVhdEl0ZW0sIHByb3BzLCB2bSwgc3ViVm0pXG4gIG1lcmdlUHJvcHModGVtcGxhdGUuYXR0ciwgcHJvcHMsIHZtLCBzdWJWbSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpbmRTdWJWbUFmdGVySW5pdGlhbGl6ZWQgKHZtLCBzdWJWbSwgdGVtcGxhdGUpIHtcbiAgbWVyZ2VDbGFzc1N0eWxlKHRlbXBsYXRlLmNsYXNzTGlzdCwgdm0sIHN1YlZtKVxuICBtZXJnZVN0eWxlKHRlbXBsYXRlLnN0eWxlLCB2bSwgc3ViVm0pXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRhcmdldCwgcHJvcHMsIHZtLCBzdWJWbSkge1xuICBpZiAoIXRhcmdldCkge1xuICAgIHJldHVyblxuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHRhcmdldCkge1xuICAgIGlmICghcHJvcHMgfHwgcHJvcHNba2V5XSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0YXJnZXRba2V5XVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IHdhdGNoKHZtLCB2YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBzdWJWbVtrZXldID0gdlxuICAgICAgICB9KVxuICAgICAgICBzdWJWbVtrZXldID0gcmV0dXJuVmFsdWVcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdWJWbVtrZXldID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VTdHlsZSAodGFyZ2V0LCB2bSwgc3ViVm0pIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgY29uc3QgdmFsdWUgPSB0YXJnZXRba2V5XVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gd2F0Y2godm0sIHZhbHVlLCBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAoc3ViVm0uX3Jvb3RFbCkge1xuICAgICAgICAgIHN1YlZtLl9yb290RWwuc2V0U3R5bGUoa2V5LCB2KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgc3ViVm0uX3Jvb3RFbC5zZXRTdHlsZShrZXksIHJldHVyblZhbHVlKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChzdWJWbS5fcm9vdEVsKSB7XG4gICAgICAgIHN1YlZtLl9yb290RWwuc2V0U3R5bGUoa2V5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc1N0eWxlICh0YXJnZXQsIHZtLCBzdWJWbSkge1xuICBjb25zdCBjc3MgPSB2bS5fb3B0aW9ucyAmJiB2bS5fb3B0aW9ucy5zdHlsZSB8fCB7fVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIXN1YlZtLl9yb290RWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgdmFsdWUgPSB3YXRjaCh2bSwgdGFyZ2V0LCB2ID0+IHtcbiAgICAgIHNldENsYXNzU3R5bGUoc3ViVm0uX3Jvb3RFbCwgY3NzLCB2KVxuICAgIH0pXG4gICAgc2V0Q2xhc3NTdHlsZShzdWJWbS5fcm9vdEVsLCBjc3MsIHZhbHVlKVxuICB9XG4gIGVsc2UgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgc2V0Q2xhc3NTdHlsZShzdWJWbS5fcm9vdEVsLCBjc3MsIHRhcmdldClcbiAgfVxufVxuXG4vKipcbiAqIGJpbmQgaWQgdG8gYW4gZWxlbWVudFxuICogZWFjaCBpZCBpcyB1bmlxdWUgaW4gYSB3aG9sZSB2bVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0SWQgKHZtLCBlbCwgaWQsIHRhcmdldCkge1xuICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobWFwLCB7XG4gICAgdm06IHtcbiAgICAgIHZhbHVlOiB0YXJnZXQsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfSxcbiAgICBlbDoge1xuICAgICAgZ2V0OiAoKSA9PiBlbCB8fCB0YXJnZXQuX3Jvb3RFbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9XG4gIH0pXG5cbiAgaWYgKHR5cGVvZiBpZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBpZFxuICAgIGlkID0gaGFuZGxlci5jYWxsKHZtKVxuICAgIGlmIChpZCkge1xuICAgICAgdm0uX2lkc1tpZF0gPSBtYXBcbiAgICB9XG4gICAgd2F0Y2godm0sIGhhbmRsZXIsIChuZXdJZCkgPT4ge1xuICAgICAgaWYgKG5ld0lkKSB7XG4gICAgICAgIHZtLl9pZHNbbmV3SWRdID0gbWFwXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBlbHNlIGlmIChpZCAmJiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgdm0uX2lkc1tpZF0gPSBtYXBcbiAgfVxufVxuXG4vKipcbiAqIGJpbmQgYXR0ciB0byBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHIgKHZtLCBlbCwgYXR0cikge1xuICBiaW5kRGlyKHZtLCBlbCwgJ2F0dHInLCBhdHRyKVxufVxuXG5mdW5jdGlvbiBzZXRDbGFzc1N0eWxlIChlbCwgY3NzLCBjbGFzc0xpc3QpIHtcbiAgY29uc3QgY2xhc3NTdHlsZSA9IHt9XG4gIGNvbnN0IGxlbmd0aCA9IGNsYXNzTGlzdC5sZW5ndGhcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBjc3NbY2xhc3NMaXN0W2ldXVxuICAgIGlmIChzdHlsZSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGUpIHtcbiAgICAgICAgY2xhc3NTdHlsZVtrZXldID0gc3R5bGVba2V5XVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbC5zZXRDbGFzc1N0eWxlKGNsYXNzU3R5bGUpXG59XG5cbi8qKlxuICogYmluZCBjbGFzc25hbWVzIHRvIGFuIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0Q2xhc3MgKHZtLCBlbCwgY2xhc3NMaXN0KSB7XG4gIGlmICh0eXBlb2YgY2xhc3NMaXN0ICE9PSAnZnVuY3Rpb24nICYmICFBcnJheS5pc0FycmF5KGNsYXNzTGlzdCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShjbGFzc0xpc3QpICYmICFjbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgZWwuc2V0Q2xhc3NTdHlsZSh7fSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHN0eWxlID0gdm0uX29wdGlvbnMgJiYgdm0uX29wdGlvbnMuc3R5bGUgfHwge31cbiAgaWYgKHR5cGVvZiBjbGFzc0xpc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHdhdGNoKHZtLCBjbGFzc0xpc3QsIHYgPT4ge1xuICAgICAgc2V0Q2xhc3NTdHlsZShlbCwgc3R5bGUsIHYpXG4gICAgfSlcbiAgICBzZXRDbGFzc1N0eWxlKGVsLCBzdHlsZSwgdmFsdWUpXG4gIH1cbiAgZWxzZSB7XG4gICAgc2V0Q2xhc3NTdHlsZShlbCwgc3R5bGUsIGNsYXNzTGlzdClcbiAgfVxufVxuXG4vKipcbiAqIGJpbmQgc3R5bGUgdG8gYW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRTdHlsZSAodm0sIGVsLCBzdHlsZSkge1xuICBiaW5kRGlyKHZtLCBlbCwgJ3N0eWxlJywgc3R5bGUpXG59XG5cbi8qKlxuICogYWRkIGFuIGV2ZW50IHR5cGUgYW5kIGhhbmRsZXIgdG8gYW4gZWxlbWVudCBhbmQgZ2VuZXJhdGUgYSBkb20gdXBkYXRlXG4gKi9cbmZ1bmN0aW9uIHNldEV2ZW50ICh2bSwgZWwsIHR5cGUsIGhhbmRsZXIpIHtcbiAgZWwuYWRkRXZlbnQodHlwZSwgYmluZChoYW5kbGVyLCB2bSkpXG59XG5cbi8qKlxuICogYWRkIGFsbCBldmVudHMgb2YgYW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBiaW5kRXZlbnRzICh2bSwgZWwsIGV2ZW50cykge1xuICBpZiAoIWV2ZW50cykge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpXG4gIGxldCBpID0ga2V5cy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICBsZXQgaGFuZGxlciA9IGV2ZW50c1trZXldXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICBjb25zb2xlLmRlYnVnKGBbSlMgRnJhbWV3b3JrXSBUaGUgbWV0aG9kIFwiJHtoYW5kbGVyfVwiIGlzIG5vdCBkZWZpbmVkLmApXG4gICAgICB9XG4gICAgfVxuICAgIHNldEV2ZW50KHZtLCBlbCwga2V5LCBoYW5kbGVyKVxuICB9XG59XG5cbi8qKlxuICogc2V0IGEgc2VyaWVzIG9mIG1lbWJlcnMgYXMgYSBraW5kIG9mIGFuIGVsZW1lbnRcbiAqIGZvciBleGFtcGxlOiBzdHlsZSwgYXR0ciwgLi4uXG4gKiBpZiB0aGUgdmFsdWUgaXMgYSBmdW5jdGlvbiB0aGVuIGJpbmQgdGhlIGRhdGEgY2hhbmdlc1xuICovXG5mdW5jdGlvbiBiaW5kRGlyICh2bSwgZWwsIG5hbWUsIGRhdGEpIHtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpXG4gIGxldCBpID0ga2V5cy5sZW5ndGhcbiAgd2hpbGUgKGktLSkge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICBjb25zdCB2YWx1ZSA9IGRhdGFba2V5XVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJpbmRLZXkodm0sIGVsLCBuYW1lLCBrZXksIHZhbHVlKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGVsW1NFVFRFUlNbbmFtZV1dKGtleSwgdmFsdWUpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogYmluZCBkYXRhIGNoYW5nZXMgdG8gYSBjZXJ0YWluIGtleSB0byBhIG5hbWUgc2VyaWVzIGluIGFuIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gYmluZEtleSAodm0sIGVsLCBuYW1lLCBrZXksIGNhbGMpIHtcbiAgY29uc3QgbWV0aG9kTmFtZSA9IFNFVFRFUlNbbmFtZV1cbiAgLy8gd2F0Y2ggdGhlIGNhbGMsIGFuZCByZXR1cm5zIGEgdmFsdWUgYnkgY2FsYy5jYWxsKClcbiAgY29uc3QgdmFsdWUgPSB3YXRjaCh2bSwgY2FsYywgKHZhbHVlKSA9PiB7XG4gICAgZnVuY3Rpb24gaGFuZGxlciAoKSB7XG4gICAgICBlbFttZXRob2ROYW1lXShrZXksIHZhbHVlKVxuICAgIH1cbiAgICBjb25zdCBkaWZmZXIgPSB2bSAmJiB2bS5fYXBwICYmIHZtLl9hcHAuZGlmZmVyXG4gICAgaWYgKGRpZmZlcikge1xuICAgICAgZGlmZmVyLmFwcGVuZCgnZWxlbWVudCcsIGVsLmRlcHRoLCBlbC5yZWYsIGhhbmRsZXIpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGFuZGxlcigpXG4gICAgfVxuICB9KVxuXG4gIGVsW21ldGhvZE5hbWVdKGtleSwgdmFsdWUpXG59XG5cbi8qKlxuICogd2F0Y2ggYSBjYWxjIGZ1bmN0aW9uIGFuZCBjYWxsYmFjayBpZiB0aGUgY2FsYyB2YWx1ZSBjaGFuZ2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3YXRjaCAodm0sIGNhbGMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgY2FsYywgZnVuY3Rpb24gKHZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnICYmIHZhbHVlID09PSBvbGRWYWx1ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxiYWNrKHZhbHVlKVxuICB9KVxuXG4gIHJldHVybiB3YXRjaGVyLnZhbHVlXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvdm0vZGlyZWN0aXZlLmpzXG4gKiovIiwiZXhwb3J0IGRlZmF1bHQge1xuICBuYXRpdmVDb21wb25lbnRNYXA6IHtcbiAgICB0ZXh0OiB0cnVlLFxuICAgIGltYWdlOiB0cnVlLFxuICAgIGNvbnRhaW5lcjogdHJ1ZSxcbiAgICBzbGlkZXI6IHtcbiAgICAgIHR5cGU6ICdzbGlkZXInLFxuICAgICAgYXBwZW5kOiAndHJlZSdcbiAgICB9LFxuICAgIGNlbGw6IHtcbiAgICAgIHR5cGU6ICdjZWxsJyxcbiAgICAgIGFwcGVuZDogJ3RyZWUnXG4gICAgfVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvY29uZmlnLmpzXG4gKiovIiwiLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IERvY3VtZW50ICYgRWxlbWVudCBIZWxwZXJzLlxuICpcbiAqIHJlcXVpcmVkOlxuICogRG9jdW1lbnQjOiBjcmVhdGVFbGVtZW50LCBjcmVhdGVDb21tZW50LCBnZXRSZWZcbiAqIEVsZW1lbnQjOiBhcHBlbmRDaGlsZCwgaW5zZXJ0QmVmb3JlLCByZW1vdmVDaGlsZCwgbmV4dFNpYmxpbmdcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIGJvZHkgYnkgdHlwZVxuICogVXNpbmcgdGhpcy5fYXBwLmRvY1xuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQm9keSAodm0sIHR5cGUpIHtcbiAgY29uc3QgZG9jID0gdm0uX2FwcC5kb2NcbiAgcmV0dXJuIGRvYy5jcmVhdGVCb2R5KHR5cGUpXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGVsZW1lbnQgYnkgdHlwZVxuICogVXNpbmcgdGhpcy5fYXBwLmRvY1xuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAodm0sIHR5cGUpIHtcbiAgY29uc3QgZG9jID0gdm0uX2FwcC5kb2NcbiAgcmV0dXJuIGRvYy5jcmVhdGVFbGVtZW50KHR5cGUpXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBmcmFnIGJsb2NrIGZvciBhbiBlbGVtZW50LlxuICogVGhlIGZyYWcgYmxvY2sgaGFzIGEgc3RhcnRlciwgZW5kZXIgYW5kIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IGVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJsb2NrICh2bSwgZWxlbWVudCkge1xuICBjb25zdCBzdGFydCA9IGNyZWF0ZUJsb2NrU3RhcnQodm0pXG4gIGNvbnN0IGVuZCA9IGNyZWF0ZUJsb2NrRW5kKHZtKVxuICBjb25zdCBibG9ja0lkID0gbGFzdGVzdEJsb2NrSWQrK1xuICBpZiAoZWxlbWVudC5lbGVtZW50KSB7XG4gICAgbGV0IHVwZGF0ZU1hcmsgPSBlbGVtZW50LnVwZGF0ZU1hcmtcbiAgICBpZiAodXBkYXRlTWFyaykge1xuICAgICAgaWYgKHVwZGF0ZU1hcmsuZWxlbWVudCkge1xuICAgICAgICB1cGRhdGVNYXJrID0gdXBkYXRlTWFyay5lbmRcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuZWxlbWVudC5pbnNlcnRBZnRlcihlbmQsIHVwZGF0ZU1hcmspXG4gICAgICBlbGVtZW50LmVsZW1lbnQuaW5zZXJ0QWZ0ZXIoc3RhcnQsIHVwZGF0ZU1hcmspXG4gICAgICBlbGVtZW50LnVwZGF0ZU1hcmsgPSBlbmRcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlbGVtZW50LmVsZW1lbnQuaW5zZXJ0QmVmb3JlKHN0YXJ0LCBlbGVtZW50LmVuZClcbiAgICAgIGVsZW1lbnQuZWxlbWVudC5pbnNlcnRCZWZvcmUoZW5kLCBlbGVtZW50LmVuZClcbiAgICB9XG4gICAgZWxlbWVudCA9IGVsZW1lbnQuZWxlbWVudFxuICB9XG4gIGVsc2Uge1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoc3RhcnQpXG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbmQpXG4gIH1cbiAgcmV0dXJuIHsgc3RhcnQsIGVuZCwgZWxlbWVudCwgYmxvY2tJZCB9XG59XG5cbmxldCBsYXN0ZXN0QmxvY2tJZCA9IDFcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIGJsb2NrIHN0YXJ0ZXIuXG4gKiBVc2luZyB0aGlzLl9hcHAuZG9jXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrU3RhcnQgKHZtKSB7XG4gIGNvbnN0IGRvYyA9IHZtLl9hcHAuZG9jXG4gIGNvbnN0IGFuY2hvciA9IGRvYy5jcmVhdGVDb21tZW50KCdzdGFydCcpXG4gIHJldHVybiBhbmNob3Jcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIGJsb2NrIGVuZGVyLlxuICogVXNpbmcgdGhpcy5fYXBwLmRvY1xuICovXG5mdW5jdGlvbiBjcmVhdGVCbG9ja0VuZCAodm0pIHtcbiAgY29uc3QgZG9jID0gdm0uX2FwcC5kb2NcbiAgY29uc3QgYW5jaG9yID0gZG9jLmNyZWF0ZUNvbW1lbnQoJ2VuZCcpXG4gIHJldHVybiBhbmNob3Jcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGFyZ2V0IHRvIGEgY2VydGFpbiBkZXN0IHVzaW5nIGFwcGVuZENoaWxkIGJ5IGRlZmF1bHQuXG4gKiBJZiB0aGUgZGVzdCBpcyBhIGZyYWcgYmxvY2sgdGhlbiBpbnNlcnQgYmVmb3JlIHRoZSBlbmRlci5cbiAqIElmIHRoZSB0YXJnZXQgaXMgYSBmcmFnIGJsb2NrIHRoZW4gYXR0YWNoIHRoZSBzdGFydGVyIGFuZCBlbmRlciBpbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IHRhcmdldFxuICogQHBhcmFtICB7b2JqZWN0fSBkZXN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRhY2hUYXJnZXQgKHZtLCB0YXJnZXQsIGRlc3QpIHtcbiAgaWYgKGRlc3QuZWxlbWVudCkge1xuICAgIGNvbnN0IGJlZm9yZSA9IGRlc3QuZW5kXG4gICAgY29uc3QgYWZ0ZXIgPSBkZXN0LnVwZGF0ZU1hcmtcbiAgICAvLyBwdXNoIG5ldyB0YXJnZXQgZm9yIHdhdGNoIGxpc3QgdXBkYXRlIGxhdGVyXG4gICAgaWYgKGRlc3QuY2hpbGRyZW4pIHtcbiAgICAgIGRlc3QuY2hpbGRyZW4ucHVzaCh0YXJnZXQpXG4gICAgfVxuICAgIC8vIGZvciBjaGVjayByZXBlYXQgY2FzZVxuICAgIGlmIChhZnRlcikge1xuICAgICAgY29uc3Qgc2lnbmFsID0gbW92ZVRhcmdldCh2bSwgdGFyZ2V0LCBhZnRlcilcbiAgICAgIGRlc3QudXBkYXRlTWFyayA9IHRhcmdldC5lbGVtZW50ID8gdGFyZ2V0LmVuZCA6IHRhcmdldFxuICAgICAgcmV0dXJuIHNpZ25hbFxuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXQuZWxlbWVudCkge1xuICAgICAgZGVzdC5lbGVtZW50Lmluc2VydEJlZm9yZSh0YXJnZXQuc3RhcnQsIGJlZm9yZSlcbiAgICAgIGRlc3QuZWxlbWVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LmVuZCwgYmVmb3JlKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBkZXN0LmVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRhcmdldCwgYmVmb3JlKVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBpZiAodGFyZ2V0LmVsZW1lbnQpIHtcbiAgICAgIGRlc3QuYXBwZW5kQ2hpbGQodGFyZ2V0LnN0YXJ0KVxuICAgICAgZGVzdC5hcHBlbmRDaGlsZCh0YXJnZXQuZW5kKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBkZXN0LmFwcGVuZENoaWxkKHRhcmdldClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNb3ZlIHRhcmdldCBiZWZvcmUgYSBjZXJ0YWluIGVsZW1lbnQuIFRoZSB0YXJnZXQgbWF5YmUgYmxvY2sgb3IgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IHRhcmdldFxuICogQHBhcmFtICB7b2JqZWN0fSBiZWZvcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdmVUYXJnZXQgKHZtLCB0YXJnZXQsIGFmdGVyKSB7XG4gIGlmICh0YXJnZXQuZWxlbWVudCkge1xuICAgIHJldHVybiBtb3ZlQmxvY2sodGFyZ2V0LCBhZnRlcilcbiAgfVxuICByZXR1cm4gbW92ZUVsZW1lbnQodGFyZ2V0LCBhZnRlcilcbn1cblxuLyoqXG4gKiBNb3ZlIGVsZW1lbnQgYmVmb3JlIGEgY2VydGFpbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gZWxlbWVudFxuICogQHBhcmFtICB7b2JqZWN0fSBiZWZvcmVcbiAqL1xuZnVuY3Rpb24gbW92ZUVsZW1lbnQgKGVsZW1lbnQsIGFmdGVyKSB7XG4gIGNvbnN0IHBhcmVudCA9IGFmdGVyLnBhcmVudE5vZGVcbiAgaWYgKHBhcmVudCkge1xuICAgIHJldHVybiBwYXJlbnQuaW5zZXJ0QWZ0ZXIoZWxlbWVudCwgYWZ0ZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBNb3ZlIGFsbCBlbGVtZW50cyBvZiB0aGUgYmxvY2sgYmVmb3JlIGEgY2VydGFpbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gZnJhZ0Jsb2NrXG4gKiBAcGFyYW0gIHtvYmplY3R9IGJlZm9yZVxuICovXG5mdW5jdGlvbiBtb3ZlQmxvY2sgKGZyYWdCbG9jaywgYWZ0ZXIpIHtcbiAgY29uc3QgcGFyZW50ID0gYWZ0ZXIucGFyZW50Tm9kZVxuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBsZXQgZWwgPSBmcmFnQmxvY2suc3RhcnRcbiAgICBsZXQgc2lnbmFsXG4gICAgY29uc3QgZ3JvdXAgPSBbZWxdXG5cbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGZyYWdCbG9jay5lbmQpIHtcbiAgICAgIGVsID0gZWwubmV4dFNpYmxpbmdcbiAgICAgIGdyb3VwLnB1c2goZWwpXG4gICAgfVxuXG4gICAgbGV0IHRlbXAgPSBhZnRlclxuICAgIGdyb3VwLmV2ZXJ5KChlbCkgPT4ge1xuICAgICAgc2lnbmFsID0gcGFyZW50Lmluc2VydEFmdGVyKGVsLCB0ZW1wKVxuICAgICAgdGVtcCA9IGVsXG4gICAgICByZXR1cm4gc2lnbmFsICE9PSAtMVxuICAgIH0pXG5cbiAgICByZXR1cm4gc2lnbmFsXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgdGFyZ2V0IGZyb20gRE9NIHRyZWUuXG4gKiBJZiB0aGUgdGFyZ2V0IGlzIGEgZnJhZyBibG9jayB0aGVuIGNhbGwgX3JlbW92ZUJsb2NrXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSB0YXJnZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVRhcmdldCAodm0sIHRhcmdldCwgcHJlc2VydmVCbG9jayA9IGZhbHNlKSB7XG4gIGlmICh0YXJnZXQuZWxlbWVudCkge1xuICAgIHJlbW92ZUJsb2NrKHRhcmdldCwgcHJlc2VydmVCbG9jaylcbiAgfVxuICBlbHNlIHtcbiAgICByZW1vdmVFbGVtZW50KHRhcmdldClcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNlcnRhaW4gZWxlbWVudC5cbiAqIFVzaW5nIHRoaXMuX2FwcC5kb2NcbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IHRhcmdldFxuICovXG5mdW5jdGlvbiByZW1vdmVFbGVtZW50ICh0YXJnZXQpIHtcbiAgY29uc3QgcGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGVcblxuICBpZiAocGFyZW50KSB7XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKHRhcmdldClcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBhIGZyYWcgYmxvY2suXG4gKiBUaGUgc2Vjb25kIHBhcmFtIGRlY2lkZXMgd2hldGhlciB0aGUgYmxvY2sgc2VsZiBzaG91bGQgYmUgcmVtb3ZlZCB0b28uXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSAgZnJhZ0Jsb2NrXG4gKiBAcGFyYW0gIHtCb29sZWFufSBwcmVzZXJ2ZUJsb2NrPWZhbHNlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUJsb2NrIChmcmFnQmxvY2ssIHByZXNlcnZlQmxvY2sgPSBmYWxzZSkge1xuICBjb25zdCByZXN1bHQgPSBbXVxuICBsZXQgZWwgPSBmcmFnQmxvY2suc3RhcnQubmV4dFNpYmxpbmdcblxuICB3aGlsZSAoZWwgJiYgZWwgIT09IGZyYWdCbG9jay5lbmQpIHtcbiAgICByZXN1bHQucHVzaChlbClcbiAgICBlbCA9IGVsLm5leHRTaWJsaW5nXG4gIH1cblxuICBpZiAoIXByZXNlcnZlQmxvY2spIHtcbiAgICByZW1vdmVFbGVtZW50KGZyYWdCbG9jay5zdGFydClcbiAgfVxuICByZXN1bHQuZm9yRWFjaCgoZWwpID0+IHtcbiAgICByZW1vdmVFbGVtZW50KGVsKVxuICB9KVxuICBpZiAoIXByZXNlcnZlQmxvY2spIHtcbiAgICByZW1vdmVFbGVtZW50KGZyYWdCbG9jay5lbmQpXG4gIH1cbn1cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9kZWZhdWx0L3ZtL2RvbS1oZWxwZXIuanNcbiAqKi8iLCJmdW5jdGlvbiBFdnQgKHR5cGUsIGRldGFpbCkge1xuICBpZiAoZGV0YWlsIGluc3RhbmNlb2YgRXZ0KSB7XG4gICAgcmV0dXJuIGRldGFpbFxuICB9XG5cbiAgdGhpcy50aW1lc3RhbXAgPSBEYXRlLm5vdygpXG4gIHRoaXMuZGV0YWlsID0gZGV0YWlsXG4gIHRoaXMudHlwZSA9IHR5cGVcblxuICBsZXQgc2hvdWxkU3RvcCA9IGZhbHNlXG4gIHRoaXMuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBzaG91bGRTdG9wID0gdHJ1ZVxuICB9XG4gIHRoaXMuaGFzU3RvcHBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2hvdWxkU3RvcFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAkZW1pdCAodHlwZSwgZGV0YWlsKSB7XG4gIGNvbnN0IGV2ZW50cyA9IHRoaXMuX3ZtRXZlbnRzXG4gIGNvbnN0IGhhbmRsZXJMaXN0ID0gZXZlbnRzW3R5cGVdXG4gIGlmIChoYW5kbGVyTGlzdCkge1xuICAgIGNvbnN0IGV2dCA9IG5ldyBFdnQodHlwZSwgZGV0YWlsKVxuICAgIGhhbmRsZXJMaXN0LmZvckVhY2goKGhhbmRsZXIpID0+IHtcbiAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBldnQpXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gJGRpc3BhdGNoICh0eXBlLCBkZXRhaWwpIHtcbiAgY29uc3QgZXZ0ID0gbmV3IEV2dCh0eXBlLCBkZXRhaWwpXG4gIHRoaXMuJGVtaXQodHlwZSwgZXZ0KVxuXG4gIGlmICghZXZ0Lmhhc1N0b3BwZWQoKSAmJiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5fcGFyZW50LiRkaXNwYXRjaCkge1xuICAgIHRoaXMuX3BhcmVudC4kZGlzcGF0Y2godHlwZSwgZXZ0KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAkYnJvYWRjYXN0ICh0eXBlLCBkZXRhaWwpIHtcbiAgY29uc3QgZXZ0ID0gbmV3IEV2dCh0eXBlLCBkZXRhaWwpXG4gIHRoaXMuJGVtaXQodHlwZSwgZXZ0KVxuXG4gIGlmICghZXZ0Lmhhc1N0b3BwZWQoKSAmJiB0aGlzLl9jaGlsZHJlblZtcykge1xuICAgIHRoaXMuX2NoaWxkcmVuVm1zLmZvckVhY2goKHN1YlZtKSA9PiB7XG4gICAgICBzdWJWbS4kYnJvYWRjYXN0KHR5cGUsIGV2dClcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAkb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgaWYgKCF0eXBlIHx8IHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgZXZlbnRzID0gdGhpcy5fdm1FdmVudHNcbiAgY29uc3QgaGFuZGxlckxpc3QgPSBldmVudHNbdHlwZV0gfHwgW11cbiAgaGFuZGxlckxpc3QucHVzaChoYW5kbGVyKVxuICBldmVudHNbdHlwZV0gPSBoYW5kbGVyTGlzdFxuXG4gIC8vIGZpeGVkIG9sZCB2ZXJzaW9uIGxpZmVjeWNsZSBkZXNpZ25cbiAgaWYgKHR5cGUgPT09ICdob29rOnJlYWR5JyAmJiB0aGlzLl9yZWFkeSkge1xuICAgIHRoaXMuJGVtaXQoJ2hvb2s6cmVhZHknKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAkb2ZmICh0eXBlLCBoYW5kbGVyKSB7XG4gIGlmICghdHlwZSkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGV2ZW50cyA9IHRoaXMuX3ZtRXZlbnRzXG4gIGlmICghaGFuZGxlcikge1xuICAgIGRlbGV0ZSBldmVudHNbdHlwZV1cbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBoYW5kbGVyTGlzdCA9IGV2ZW50c1t0eXBlXVxuICBpZiAoIWhhbmRsZXJMaXN0KSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaGFuZGxlckxpc3QuJHJlbW92ZShoYW5kbGVyKVxufVxuXG5jb25zdCBMSUZFX0NZQ0xFX1RZUEVTID0gWydpbml0JywgJ2NyZWF0ZWQnLCAncmVhZHknXVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0sIGV4dGVybmFsRXZlbnRzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB2bS5fb3B0aW9ucyB8fCB7fVxuICBjb25zdCBldmVudHMgPSBvcHRpb25zLmV2ZW50cyB8fCB7fVxuICBmb3IgKGNvbnN0IHR5cGUxIGluIGV2ZW50cykge1xuICAgIHZtLiRvbih0eXBlMSwgZXZlbnRzW3R5cGUxXSlcbiAgfVxuICBmb3IgKGNvbnN0IHR5cGUyIGluIGV4dGVybmFsRXZlbnRzKSB7XG4gICAgdm0uJG9uKHR5cGUyLCBleHRlcm5hbEV2ZW50c1t0eXBlMl0pXG4gIH1cbiAgTElGRV9DWUNMRV9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgdm0uJG9uKGBob29rOiR7dHlwZX1gLCBvcHRpb25zW3R5cGVdKVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWl4aW5FdmVudHMgKHZtKSB7XG4gIHZtLiRlbWl0ID0gJGVtaXRcbiAgdm0uJGRpc3BhdGNoID0gJGRpc3BhdGNoXG4gIHZtLiRicm9hZGNhc3QgPSAkYnJvYWRjYXN0XG4gIHZtLiRvbiA9ICRvblxuICB2bS4kb2ZmID0gJG9mZlxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9kZWZhdWx0L3ZtL2V2ZW50cy5qc1xuICoqLyIsImxldCBuYXRpdmVNb2R1bGVzID0ge31cblxuZnVuY3Rpb24gYXNzaWduTW9kdWxlcyAobW9kdWxlcywgaWZSZXBsYWNlKSB7XG4gIGZvciAoY29uc3QgbW9kdWxlTmFtZSBpbiBtb2R1bGVzKSB7XG4gICAgLy8gaW5pdCBgbW9kdWxlc1ttb2R1bGVOYW1lXVtdYFxuICAgIGxldCBtZXRob2RzID0gbmF0aXZlTW9kdWxlc1ttb2R1bGVOYW1lXVxuICAgIGlmICghbWV0aG9kcykge1xuICAgICAgbWV0aG9kcyA9IHt9XG4gICAgICBuYXRpdmVNb2R1bGVzW21vZHVsZU5hbWVdID0gbWV0aG9kc1xuICAgIH1cblxuICAgIC8vIHB1c2ggZWFjaCBub24tZXhpc3RlZCBuZXcgbWV0aG9kXG4gICAgbW9kdWxlc1ttb2R1bGVOYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnc3RyaW5nJykge1xuICAgICAgICBtZXRob2QgPSB7XG4gICAgICAgICAgbmFtZTogbWV0aG9kXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFtZXRob2RzW21ldGhvZC5uYW1lXSB8fCBpZlJlcGxhY2UpIHtcbiAgICAgICAgbWV0aG9kc1ttZXRob2QubmFtZV0gPSBtZXRob2RcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkFwaXMgKEN0b3IsIGFwaXMpIHtcbiAgY29uc3QgcCA9IEN0b3IucHJvdG90eXBlXG5cbiAgZm9yIChjb25zdCBhcGlOYW1lIGluIGFwaXMpIHtcbiAgICBpZiAoIXAuaGFzT3duUHJvcGVydHkoYXBpTmFtZSkpIHtcbiAgICAgIHBbYXBpTmFtZV0gPSBhcGlzW2FwaU5hbWVdXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhck1vZHVsZXMgKCkge1xuICBuYXRpdmVNb2R1bGVzID0ge31cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1vZHVsZSAobW9kdWxlTmFtZSkge1xuICByZXR1cm4gbmF0aXZlTW9kdWxlc1ttb2R1bGVOYW1lXVxufVxuXG4vKipcbiAqIEBjb250ZXh0IGEgaW5zdGFuY2Ugb2YgQXBwSW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcXVpcmVNb2R1bGUgKG1vZHVsZU5hbWUpIHtcbiAgY29uc3QgbWV0aG9kcyA9IG5hdGl2ZU1vZHVsZXNbbW9kdWxlTmFtZV1cbiAgY29uc3QgdGFyZ2V0ID0ge31cblxuICBmb3IgKGNvbnN0IG1ldGhvZE5hbWUgaW4gbWV0aG9kcykge1xuICAgIHRhcmdldFttZXRob2ROYW1lXSA9ICguLi5hcmdzKSA9PiB0aGlzLmNhbGxUYXNrcyh7XG4gICAgICBtb2R1bGU6IG1vZHVsZU5hbWUsXG4gICAgICBtZXRob2Q6IG1ldGhvZE5hbWUsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRcbn1cblxuLyoqXG4gKiBAY29udGV4dCBWbVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJNb2R1bGVzIChtb2R1bGVzLCBpZlJlcGxhY2UpIHtcbiAgYXNzaWduTW9kdWxlcyhtb2R1bGVzLCBpZlJlcGxhY2UpXG59XG5cbi8qKlxuICogQGNvbnRleHQgVm1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyTWV0aG9kcyAoYXBpcykge1xuICBhc3NpZ25BcGlzKHRoaXMsIGFwaXMpXG59XG5cbi8qKlxuICogQGNvbnRleHQgYSBpbnN0YW5jZSBvZiBBcHBJbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZUNvbXBvbmVudCAobmFtZSkge1xuICBjb25zdCB7IGN1c3RvbUNvbXBvbmVudE1hcCB9ID0gdGhpc1xuICByZXR1cm4gY3VzdG9tQ29tcG9uZW50TWFwW25hbWVdXG59XG5cbi8qKlxuICogQGNvbnRleHQgYSBpbnN0YW5jZSBvZiBBcHBJbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJDb21wb25lbnQgKG5hbWUsIGRlZikge1xuICBjb25zdCB7IGN1c3RvbUNvbXBvbmVudE1hcCB9ID0gdGhpc1xuXG4gIGlmIChjdXN0b21Db21wb25lbnRNYXBbbmFtZV0pIHtcbiAgICBjb25zb2xlLmVycm9yKGBbSlMgRnJhbWV3b3JrXSBkZWZpbmUgYSBjb21wb25lbnQoJHtuYW1lfSkgdGhhdCBhbHJlYWR5IGV4aXN0c2ApXG4gICAgcmV0dXJuXG4gIH1cblxuICBjdXN0b21Db21wb25lbnRNYXBbbmFtZV0gPSBkZWZcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvZGVmYXVsdC9hcHAvcmVnaXN0ZXIuanNcbiAqKi8iLCJjb25zdCBXRUVYX0NPTVBPTkVOVF9SRUcgPSAvXkB3ZWV4LWNvbXBvbmVudFxcLy9cbmNvbnN0IFdFRVhfTU9EVUxFX1JFRyA9IC9eQHdlZXgtbW9kdWxlXFwvL1xuY29uc3QgTk9STUFMX01PRFVMRV9SRUcgPSAvXlxcLnsxLDJ9XFwvL1xuY29uc3QgSlNfU1VSRklYX1JFRyA9IC9cXC5qcyQvXG5cbmV4cG9ydCBjb25zdCBpc1dlZXhDb21wb25lbnQgPSBuYW1lID0+ICEhbmFtZS5tYXRjaChXRUVYX0NPTVBPTkVOVF9SRUcpXG5leHBvcnQgY29uc3QgaXNXZWV4TW9kdWxlID0gbmFtZSA9PiAhIW5hbWUubWF0Y2goV0VFWF9NT0RVTEVfUkVHKVxuZXhwb3J0IGNvbnN0IGlzTm9ybWFsTW9kdWxlID0gbmFtZSA9PiAhIW5hbWUubWF0Y2goTk9STUFMX01PRFVMRV9SRUcpXG5leHBvcnQgY29uc3QgaXNOcG1Nb2R1bGUgPSBuYW1lID0+ICFpc1dlZXhDb21wb25lbnQobmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc1dlZXhNb2R1bGUobmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc05vcm1hbE1vZHVsZShuYW1lKVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlV2VleFByZWZpeCAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShXRUVYX0NPTVBPTkVOVF9SRUcsICcnKVxuICAgICAgICAgIC5yZXBsYWNlKFdFRVhfTU9EVUxFX1JFRywgJycpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVKU1N1cmZpeCAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShKU19TVVJGSVhfUkVHLCAnJylcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvZGVmYXVsdC9hcHAvYnVuZGxlL21pc2MuanNcbiAqKi8iLCJpbXBvcnQgeyB0eXBvZiB9IGZyb20gJy4uLy4uL3V0aWwnXG5pbXBvcnQgVm0gZnJvbSAnLi4vLi4vdm0nXG5pbXBvcnQge1xuICBpc1dlZXhDb21wb25lbnQsXG4gIGlzV2VleE1vZHVsZSxcbiAgaXNOb3JtYWxNb2R1bGUsXG4gIGlzTnBtTW9kdWxlLFxuICByZW1vdmVXZWV4UHJlZml4LFxuICByZW1vdmVKU1N1cmZpeFxufSBmcm9tICcuL21pc2MnXG5cbmxldCBjb21tb25Nb2R1bGVzID0ge31cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQ29tbW9uTW9kdWxlcyAoKSB7XG4gIGNvbW1vbk1vZHVsZXMgPSB7fVxufVxuXG4vLyBkZWZpbmUobmFtZSwgZmFjdG9yeSkgZm9yIHByaW1hcnkgdXNhZ2Vcbi8vIG9yXG4vLyBkZWZpbmUobmFtZSwgZGVwcywgZmFjdG9yeSkgZm9yIGNvbXBhdGliaWxpdHlcbi8vIE5vdGljZTogRE8gTk9UIHVzZSBmdW5jdGlvbiBkZWZpbmUoKSB7fSxcbi8vIGl0IHdpbGwgY2F1c2UgZXJyb3IgYWZ0ZXIgYnVpbGRlZCBieSB3ZWJwYWNrXG5leHBvcnQgY29uc3QgZGVmaW5lID0gZnVuY3Rpb24gKG5hbWUsIGRlcHMsIGZhY3RvcnkpIHtcbiAgY29uc29sZS5kZWJ1ZyhgW0pTIEZyYW1ld29ya10gZGVmaW5lIGEgY29tcG9uZW50ICR7bmFtZX1gKVxuXG4gIGlmICh0eXBvZihkZXBzKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZhY3RvcnkgPSBkZXBzXG4gICAgZGVwcyA9IFtdXG4gIH1cblxuICBjb25zdCBfcmVxdWlyZSA9IChuYW1lKSA9PiB7XG4gICAgbGV0IGNsZWFuTmFtZVxuXG4gICAgaWYgKGlzV2VleENvbXBvbmVudChuYW1lKSkge1xuICAgICAgY2xlYW5OYW1lID0gcmVtb3ZlV2VleFByZWZpeChuYW1lKVxuICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZUNvbXBvbmVudChjbGVhbk5hbWUpXG4gICAgfVxuICAgIGlmIChpc1dlZXhNb2R1bGUobmFtZSkpIHtcbiAgICAgIGNsZWFuTmFtZSA9IHJlbW92ZVdlZXhQcmVmaXgobmFtZSlcbiAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVNb2R1bGUoY2xlYW5OYW1lKVxuICAgIH1cbiAgICBpZiAoaXNOb3JtYWxNb2R1bGUobmFtZSkpIHtcbiAgICAgIGNsZWFuTmFtZSA9IHJlbW92ZUpTU3VyZml4KG5hbWUpXG4gICAgICByZXR1cm4gY29tbW9uTW9kdWxlc1tuYW1lXVxuICAgIH1cbiAgICBpZiAoaXNOcG1Nb2R1bGUobmFtZSkpIHtcbiAgICAgIGNsZWFuTmFtZSA9IHJlbW92ZUpTU3VyZml4KG5hbWUpXG4gICAgICByZXR1cm4gY29tbW9uTW9kdWxlc1tuYW1lXVxuICAgIH1cbiAgfVxuICBjb25zdCBfbW9kdWxlID0geyBleHBvcnRzOiB7fX1cblxuICBsZXQgY2xlYW5OYW1lXG4gIGlmIChpc1dlZXhDb21wb25lbnQobmFtZSkpIHtcbiAgICBjbGVhbk5hbWUgPSByZW1vdmVXZWV4UHJlZml4KG5hbWUpXG5cbiAgICBmYWN0b3J5KF9yZXF1aXJlLCBfbW9kdWxlLmV4cG9ydHMsIF9tb2R1bGUpXG5cbiAgICB0aGlzLnJlZ2lzdGVyQ29tcG9uZW50KGNsZWFuTmFtZSwgX21vZHVsZS5leHBvcnRzKVxuICB9XG4gIGVsc2UgaWYgKGlzV2VleE1vZHVsZShuYW1lKSkge1xuICAgIGNsZWFuTmFtZSA9IHJlbW92ZVdlZXhQcmVmaXgobmFtZSlcblxuICAgIGZhY3RvcnkoX3JlcXVpcmUsIF9tb2R1bGUuZXhwb3J0cywgX21vZHVsZSlcblxuICAgIFZtLnJlZ2lzdGVyTW9kdWxlcyh7XG4gICAgICBbY2xlYW5OYW1lXTogX21vZHVsZS5leHBvcnRzXG4gICAgfSlcbiAgfVxuICBlbHNlIGlmIChpc05vcm1hbE1vZHVsZShuYW1lKSkge1xuICAgIGNsZWFuTmFtZSA9IHJlbW92ZUpTU3VyZml4KG5hbWUpXG5cbiAgICBmYWN0b3J5KF9yZXF1aXJlLCBfbW9kdWxlLmV4cG9ydHMsIF9tb2R1bGUpXG5cbiAgICBjb21tb25Nb2R1bGVzW2NsZWFuTmFtZV0gPSBfbW9kdWxlLmV4cG9ydHNcbiAgfVxuICBlbHNlIGlmIChpc05wbU1vZHVsZShuYW1lKSkge1xuICAgIGNsZWFuTmFtZSA9IHJlbW92ZUpTU3VyZml4KG5hbWUpXG5cbiAgICBmYWN0b3J5KF9yZXF1aXJlLCBfbW9kdWxlLmV4cG9ydHMsIF9tb2R1bGUpXG5cbiAgICBjb25zdCBleHBvcnRzID0gX21vZHVsZS5leHBvcnRzXG4gICAgaWYgKGV4cG9ydHMudGVtcGxhdGUgfHxcbiAgICAgICAgZXhwb3J0cy5zdHlsZSB8fFxuICAgICAgICBleHBvcnRzLm1ldGhvZHMpIHtcbiAgICAgIC8vIGRvd25ncmFkZSB0byBvbGQgZGVmaW5lIG1ldGhvZCAoZGVmaW5lKCdjb21wb25lbnROYW1lJywgZmFjdG9yeSkpXG4gICAgICAvLyB0aGUgZXhwb3J0cyBjb250YWluIG9uZSBrZXkgb2YgdGVtcGxhdGUsIHN0eWxlIG9yIG1ldGhvZHNcbiAgICAgIC8vIGJ1dCBpdCBoYXMgcmlzayEhIVxuICAgICAgdGhpcy5yZWdpc3RlckNvbXBvbmVudChjbGVhbk5hbWUsIGV4cG9ydHMpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29tbW9uTW9kdWxlc1tjbGVhbk5hbWVdID0gX21vZHVsZS5leHBvcnRzXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyICh0eXBlLCBvcHRpb25zKSB7XG4gIGNvbnNvbGUud2FybignW0pTIEZyYW1ld29ya10gUmVnaXN0ZXIgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIGluc3RhbGwgbGFzdGVzdCB0cmFuc2Zvcm1lci4nKVxuICB0aGlzLnJlZ2lzdGVyQ29tcG9uZW50KHR5cGUsIG9wdGlvbnMpXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvYXBwL2J1bmRsZS9kZWZpbmUuanNcbiAqKi8iLCIvKipcbiAqIEBmaWxlT3ZlcnZpZXdcbiAqIGluc3RhbmNlIGNvbnRyb2xzIGZyb20gbmF0aXZlXG4gKlxuICogLSBmaXJlIGV2ZW50XG4gKiAtIGNhbGxiYWNrXG4gKiAtIGRlc3Ryb3lcbiAqXG4gKiBjb3JyZXNwb25kZWQgd2l0aCB0aGUgQVBJIG9mIGluc3RhbmNlIG1hbmFnZXIgKGZyYW1ld29yay5qcylcbiAqL1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vLi4vdXRpbCdcblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUFjdGlvbnMgKCkge1xuICB0aGlzLmRpZmZlci5mbHVzaCgpXG4gIGNvbnN0IHRhc2tzID0gW11cbiAgaWYgKHRoaXMuZG9jICYmIHRoaXMuZG9jLmxpc3RlbmVyICYmIHRoaXMuZG9jLmxpc3RlbmVyLnVwZGF0ZXMubGVuZ3RoKSB7XG4gICAgdGFza3MucHVzaCguLi50aGlzLmRvYy5saXN0ZW5lci51cGRhdGVzKVxuICAgIHRoaXMuZG9jLmxpc3RlbmVyLnVwZGF0ZXMgPSBbXVxuICB9XG4gIGlmICh0YXNrcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsVGFza3ModGFza3MpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuICBjb25zb2xlLmRlYnVnKGBbSlMgRnJhbWV3b3JrXSBEZXN0b3J5IGFuIGluc3RhbmNlKCR7dGhpcy5pZH0pYClcblxuICB0aGlzLmlkID0gJydcbiAgdGhpcy5vcHRpb25zID0gbnVsbFxuICB0aGlzLmJsb2NrcyA9IG51bGxcbiAgdGhpcy52bSA9IG51bGxcbiAgdGhpcy5kb2MgPSBudWxsXG4gIHRoaXMuY3VzdG9tQ29tcG9uZW50TWFwID0gbnVsbFxuICB0aGlzLmNhbGxiYWNrcyA9IG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvb3RFbGVtZW50ICgpIHtcbiAgY29uc3QgZG9jID0gdGhpcy5kb2MgfHwge31cbiAgY29uc3QgYm9keSA9IGRvYy5ib2R5IHx8IHt9XG4gIHJldHVybiBib2R5LnRvSlNPTiA/IGJvZHkudG9KU09OKCkgOiB7fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlyZUV2ZW50IChyZWYsIHR5cGUsIGUsIGRvbUNoYW5nZXMpIHtcbiAgY29uc29sZS5kZWJ1ZyhgW0pTIEZyYW1ld29ya10gRmlyZSBhIFwiJHt0eXBlfVwiIGV2ZW50IG9uIGFuIGVsZW1lbnQoJHtyZWZ9KSBpbiBpbnN0YW5jZSgke3RoaXMuaWR9KWApXG4gIGlmIChBcnJheS5pc0FycmF5KHJlZikpIHtcbiAgICByZWYuc29tZSgocmVmKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5maXJlRXZlbnQocmVmLCB0eXBlLCBlKSAhPT0gZmFsc2VcbiAgICB9KVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgZWwgPSB0aGlzLmRvYy5nZXRSZWYocmVmKVxuXG4gIGlmIChlbCkge1xuICAgIHRoaXMuZG9jLmNsb3NlKClcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmRvYy5maXJlRXZlbnQoZWwsIHR5cGUsIGUsIGRvbUNoYW5nZXMpXG4gICAgdGhpcy51cGRhdGVBY3Rpb25zKClcbiAgICB0aGlzLmRvYy5saXN0ZW5lci51cGRhdGVGaW5pc2goKVxuICAgIHRoaXMuZG9jLm9wZW4oKVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIHJldHVybiBuZXcgRXJyb3IoYGludmFsaWQgZWxlbWVudCByZWZlcmVuY2UgXCIke3JlZn1cImApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsYmFjayAoY2FsbGJhY2tJZCwgZGF0YSwgaWZLZWVwQWxpdmUpIHtcbiAgY29uc29sZS5kZWJ1ZyhgW0pTIEZyYW1ld29ya10gSW52b2tlIGEgY2FsbGJhY2soJHtjYWxsYmFja0lkfSkgd2l0aGAsIGRhdGEsXG4gICAgICAgICAgICBgaW4gaW5zdGFuY2UoJHt0aGlzLmlkfSlgKVxuXG4gIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5jYWxsYmFja3NbY2FsbGJhY2tJZF1cblxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5kb2MuY2xvc2UoKVxuICAgIGNhbGxiYWNrKGRhdGEpIC8vIGRhdGEgaXMgYWxyZWFkeSBhIG9iamVjdCwgQHNlZTogbGliL3J1bnRpbWUvaW5kZXguanNcblxuICAgIGlmICh0eXBlb2YgaWZLZWVwQWxpdmUgPT09ICd1bmRlZmluZWQnIHx8IGlmS2VlcEFsaXZlID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5jYWxsYmFja3NbY2FsbGJhY2tJZF0gPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUFjdGlvbnMoKVxuICAgIHRoaXMuZG9jLmxpc3RlbmVyLnVwZGF0ZUZpbmlzaCgpXG4gICAgdGhpcy5kb2Mub3BlbigpXG4gICAgcmV0dXJuXG4gIH1cblxuICByZXR1cm4gbmV3IEVycm9yKGBpbnZhbGlkIGNhbGxiYWNrIGlkIFwiJHtjYWxsYmFja0lkfVwiYClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZnJlc2hEYXRhIChkYXRhKSB7XG4gIGNvbnNvbGUuZGVidWcoYFtKUyBGcmFtZXdvcmtdIFJlZnJlc2ggd2l0aGAsIGRhdGEsXG4gICAgICAgICAgICBgaW4gaW5zdGFuY2VbJHt0aGlzLmlkfV1gKVxuXG4gIGNvbnN0IHZtID0gdGhpcy52bVxuXG4gIGlmICh2bSAmJiBkYXRhKSB7XG4gICAgdGhpcy5kb2MuY2xvc2UoKVxuICAgIGlmICh0eXBlb2Ygdm0ucmVmcmVzaERhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZtLnJlZnJlc2hEYXRhKGRhdGEpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZXh0ZW5kKHZtLCBkYXRhKVxuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUFjdGlvbnMoKVxuICAgIHRoaXMuZG9jLmxpc3RlbmVyLnJlZnJlc2hGaW5pc2goKVxuICAgIHRoaXMuZG9jLm9wZW4oKVxuICAgIHJldHVyblxuICB9XG5cbiAgcmV0dXJuIG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIFwiJHtkYXRhfVwiYClcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvZGVmYXVsdC9hcHAvY3RybC9taXNjLmpzXG4gKiovIiwiaW1wb3J0IHsgZXh0ZW5kLCB0eXBvZiB9IGZyb20gJy4uL3V0aWwnXG5pbXBvcnQgRGlmZmVyIGZyb20gJy4vZGlmZmVyJ1xuaW1wb3J0IHJlbmRlcmVyIGZyb20gJy4uL2NvbmZpZydcbmltcG9ydCB7IHJlZ2lzdGVyQ29tcG9uZW50LCByZXF1aXJlQ29tcG9uZW50LCByZXF1aXJlTW9kdWxlIH0gZnJvbSAnLi9yZWdpc3RlcidcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXBwSW5zdGFuY2UgKGluc3RhbmNlSWQsIG9wdGlvbnMpIHtcbiAgdGhpcy5pZCA9IGluc3RhbmNlSWRcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB0aGlzLnZtID0gbnVsbFxuICB0aGlzLmN1c3RvbUNvbXBvbmVudE1hcCA9IHt9XG4gIHRoaXMuY2FsbGJhY2tzID0ge31cbiAgdGhpcy5kb2MgPSBuZXcgcmVuZGVyZXIuRG9jdW1lbnQoXG4gICAgaW5zdGFuY2VJZCxcbiAgICB0aGlzLm9wdGlvbnMuYnVuZGxlVXJsLFxuICAgIG51bGwsXG4gICAgcmVuZGVyZXIuTGlzdGVuZXJcbiAgKVxuICB0aGlzLmRpZmZlciA9IG5ldyBEaWZmZXIoaW5zdGFuY2VJZClcbiAgdGhpcy51aWQgPSAwXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSAoYXBwLCB2KSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBvZih2KVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnbnVsbCc6XG4gICAgICByZXR1cm4gJydcbiAgICBjYXNlICdyZWdleHAnOlxuICAgICAgcmV0dXJuIHYudG9TdHJpbmcoKVxuICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgcmV0dXJuIHYudG9JU09TdHJpbmcoKVxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdhcnJheSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmICh2IGluc3RhbmNlb2YgcmVuZGVyZXIuRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdi5yZWZcbiAgICAgIH1cbiAgICAgIHJldHVybiB2XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgYXBwLmNhbGxiYWNrc1srK2FwcC51aWRdID0gdlxuICAgICAgcmV0dXJuIGFwcC51aWQudG9TdHJpbmcoKVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodilcbiAgfVxufVxuXG5BcHBJbnN0YW5jZS5wcm90b3R5cGUuY2FsbFRhc2tzID0gZnVuY3Rpb24gKHRhc2tzKSB7XG4gIGlmICh0eXBvZih0YXNrcykgIT09ICdhcnJheScpIHtcbiAgICB0YXNrcyA9IFt0YXNrc11cbiAgfVxuXG4gIHRhc2tzLmZvckVhY2goKHRhc2spID0+IHtcbiAgICB0YXNrLmFyZ3MgPSB0YXNrLmFyZ3MubWFwKGFyZyA9PiBub3JtYWxpemUodGhpcywgYXJnKSlcbiAgfSlcblxuICByZXR1cm4gcmVuZGVyZXIuc2VuZFRhc2tzKHRoaXMuaWQsIHRhc2tzLCAnLTEnKVxufVxuXG5leHRlbmQoQXBwSW5zdGFuY2UucHJvdG90eXBlLCB7XG4gIHJlZ2lzdGVyQ29tcG9uZW50LFxuICByZXF1aXJlQ29tcG9uZW50LFxuICByZXF1aXJlTW9kdWxlXG59KVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9kZWZhdWx0L2FwcC9pbnN0YW5jZS5qc1xuICoqLyIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIERpZmZlciB7XG4gIGNvbnN0cnVjdG9yIChpZCkge1xuICAgIHRoaXMuaWQgPSBpZFxuICAgIHRoaXMubWFwID0gW11cbiAgICB0aGlzLmhvb2tzID0gW11cbiAgfVxuICBpc0VtcHR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAubGVuZ3RoID09PSAwXG4gIH1cbiAgYXBwZW5kICh0eXBlLCBkZXB0aCwgcmVmLCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLmhhc1RpbWVyKSB7XG4gICAgICB0aGlzLmhhc1RpbWVyID0gdHJ1ZVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuaGFzVGltZXIgPSBmYWxzZVxuICAgICAgICB0aGlzLmZsdXNoKHRydWUpXG4gICAgICB9LCAwKVxuICAgIH1cbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcFxuICAgIGlmICghbWFwW2RlcHRoXSkge1xuICAgICAgbWFwW2RlcHRoXSA9IHt9XG4gICAgfVxuICAgIGNvbnN0IGdyb3VwID0gbWFwW2RlcHRoXVxuICAgIGlmICghZ3JvdXBbdHlwZV0pIHtcbiAgICAgIGdyb3VwW3R5cGVdID0ge31cbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgICAgaWYgKCFncm91cFt0eXBlXVtyZWZdKSB7XG4gICAgICAgIGdyb3VwW3R5cGVdW3JlZl0gPSBbXVxuICAgICAgfVxuICAgICAgZ3JvdXBbdHlwZV1bcmVmXS5wdXNoKGhhbmRsZXIpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZ3JvdXBbdHlwZV1bcmVmXSA9IGhhbmRsZXJcbiAgICB9XG4gIH1cbiAgZmx1c2ggKGlzVGltZW91dCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwLnNsaWNlKClcbiAgICB0aGlzLm1hcC5sZW5ndGggPSAwXG4gICAgbWFwLmZvckVhY2goKGdyb3VwKSA9PiB7XG4gICAgICBjYWxsVHlwZU1hcChncm91cCwgJ3JlcGVhdCcpXG4gICAgICBjYWxsVHlwZU1hcChncm91cCwgJ3Nob3duJylcbiAgICAgIGNhbGxUeXBlTGlzdChncm91cCwgJ2VsZW1lbnQnKVxuICAgIH0pXG5cbiAgICBjb25zdCBob29rcyA9IHRoaXMuaG9va3Muc2xpY2UoKVxuICAgIHRoaXMuaG9va3MubGVuZ3RoID0gMFxuICAgIGhvb2tzLmZvckVhY2goKGZuKSA9PiB7XG4gICAgICBmbigpXG4gICAgfSlcblxuICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuZmx1c2goKVxuICAgIH1cbiAgfVxuICB0aGVuIChmbikge1xuICAgIHRoaXMuaG9va3MucHVzaChmbilcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVHlwZU1hcCAoZ3JvdXAsIHR5cGUpIHtcbiAgY29uc3QgbWFwID0gZ3JvdXBbdHlwZV1cbiAgZm9yIChjb25zdCByZWYgaW4gbWFwKSB7XG4gICAgbWFwW3JlZl0oKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxUeXBlTGlzdCAoZ3JvdXAsIHR5cGUpIHtcbiAgY29uc3QgbWFwID0gZ3JvdXBbdHlwZV1cbiAgZm9yIChjb25zdCByZWYgaW4gbWFwKSB7XG4gICAgY29uc3QgbGlzdCA9IG1hcFtyZWZdXG4gICAgbGlzdC5mb3JFYWNoKChoYW5kbGVyKSA9PiB7IGhhbmRsZXIoKSB9KVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvYXBwL2RpZmZlci5qc1xuICoqLyIsImV4cG9ydCBjb25zdCBpbnN0YW5jZU1hcCA9IHt9XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2RlZmF1bHQvc3RhdGljL21hcC5qc1xuICoqLyIsImltcG9ydCBjb25maWcgZnJvbSAnLi4vY29uZmlnJ1xuaW1wb3J0IHsgaW5zdGFuY2VNYXAgfSBmcm9tICcuL21hcCdcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQgKGNmZykge1xuICBjb25maWcuRG9jdW1lbnQgPSBjZmcuRG9jdW1lbnRcbiAgY29uZmlnLkVsZW1lbnQgPSBjZmcuRWxlbWVudFxuICBjb25maWcuQ29tbWVudCA9IGNmZy5Db21tZW50XG4gIGNvbmZpZy5zZW5kVGFza3MgPSBjZmcuc2VuZFRhc2tzXG4gIGNvbmZpZy5MaXN0ZW5lciA9IGNmZy5MaXN0ZW5lclxufVxuXG4vKipcbiAqIHJlZnJlc2ggYSBXZWV4IGluc3RhbmNlXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBpbnN0YW5jZUlkXG4gKiBAcGFyYW0gIHtvYmplY3R9IGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZnJlc2hJbnN0YW5jZSAoaW5zdGFuY2VJZCwgZGF0YSkge1xuICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlTWFwW2luc3RhbmNlSWRdXG4gIGxldCByZXN1bHRcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgcmVzdWx0ID0gaW5zdGFuY2UucmVmcmVzaERhdGEoZGF0YSlcbiAgfVxuICBlbHNlIHtcbiAgICByZXN1bHQgPSBuZXcgRXJyb3IoYGludmFsaWQgaW5zdGFuY2UgaWQgXCIke2luc3RhbmNlSWR9XCJgKVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBkZXN0cm95IGEgV2VleCBpbnN0YW5jZVxuICogQHBhcmFtICB7c3RyaW5nfSBpbnN0YW5jZUlkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95SW5zdGFuY2UgKGluc3RhbmNlSWQpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZU1hcFtpbnN0YW5jZUlkXVxuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihgaW52YWxpZCBpbnN0YW5jZSBpZCBcIiR7aW5zdGFuY2VJZH1cImApXG4gIH1cblxuICBpbnN0YW5jZS5kZXN0cm95KClcbiAgZGVsZXRlIGluc3RhbmNlTWFwW2luc3RhbmNlSWRdXG4gIHJldHVybiBpbnN0YW5jZU1hcFxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9kZWZhdWx0L3N0YXRpYy9saWZlLmpzXG4gKiovIiwiaW1wb3J0IFZtIGZyb20gJy4uL3ZtJ1xuaW1wb3J0IGNvbmZpZyBmcm9tICcuLi9jb25maWcnXG5cbmNvbnN0IHtcbiAgbmF0aXZlQ29tcG9uZW50TWFwXG59ID0gY29uZmlnXG5cbi8qKlxuICogcmVnaXN0ZXIgdGhlIG5hbWUgb2YgZWFjaCBuYXRpdmUgY29tcG9uZW50XG4gKiBAcGFyYW0gIHthcnJheX0gY29tcG9uZW50cyBhcnJheSBvZiBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudHMgKGNvbXBvbmVudHMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29tcG9uZW50cykpIHtcbiAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gcmVnaXN0ZXIgKG5hbWUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYXRpdmVDb21wb25lbnRNYXBbbmFtZV0gPSB0cnVlXG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG5hbWUudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmF0aXZlQ29tcG9uZW50TWFwW25hbWUudHlwZV0gPSBuYW1lXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIHJlZ2lzdGVyIHRoZSBuYW1lIGFuZCBtZXRob2RzIG9mIGVhY2ggbW9kdWxlXG4gKiBAcGFyYW0gIHtvYmplY3R9IG1vZHVsZXMgYSBvYmplY3Qgb2YgbW9kdWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJNb2R1bGVzIChtb2R1bGVzKSB7XG4gIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ29iamVjdCcpIHtcbiAgICBWbS5yZWdpc3Rlck1vZHVsZXMobW9kdWxlcylcbiAgfVxufVxuXG4vKipcbiAqIHJlZ2lzdGVyIHRoZSBuYW1lIGFuZCBtZXRob2RzIG9mIGVhY2ggYXBpXG4gKiBAcGFyYW0gIHtvYmplY3R9IGFwaXMgYSBvYmplY3Qgb2YgYXBpc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJNZXRob2RzIChhcGlzKSB7XG4gIGlmICh0eXBlb2YgYXBpcyA9PT0gJ29iamVjdCcpIHtcbiAgICBWbS5yZWdpc3Rlck1ldGhvZHMoYXBpcylcbiAgfVxufVxuZ2xvYmFsLnJlZ2lzdGVyTWV0aG9kcyA9IHJlZ2lzdGVyTWV0aG9kc1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9kZWZhdWx0L3N0YXRpYy9yZWdpc3Rlci5qc1xuICoqLyIsImltcG9ydCB7IGluc3RhbmNlTWFwIH0gZnJvbSAnLi9tYXAnXG5cbmNvbnN0IGpzSGFuZGxlcnMgPSB7XG4gIGZpcmVFdmVudDogZnVuY3Rpb24gZmlyZUV2ZW50IChpbnN0YW5jZUlkLCByZWYsIHR5cGUsIGRhdGEsIGRvbUNoYW5nZXMpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlTWFwW2luc3RhbmNlSWRdXG4gICAgcmV0dXJuIGluc3RhbmNlLmZpcmVFdmVudChyZWYsIHR5cGUsIGRhdGEsIGRvbUNoYW5nZXMpXG4gIH0sXG5cbiAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrIChpbnN0YW5jZUlkLCBmdW5jSWQsIGRhdGEsIGlmTGFzdCkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VNYXBbaW5zdGFuY2VJZF1cbiAgICByZXR1cm4gaW5zdGFuY2UuY2FsbGJhY2soZnVuY0lkLCBkYXRhLCBpZkxhc3QpXG4gIH1cbn1cblxuLyoqXG4gKiBhY2NlcHQgY2FsbHMgZnJvbSBuYXRpdmUgKGV2ZW50IG9yIGNhbGxiYWNrKVxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gaW5zdGFuY2VJZFxuICogQHBhcmFtICB7YXJyYXl9IHRhc2tzIGxpc3Qgd2l0aCBgbWV0aG9kYCBhbmQgYGFyZ3NgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWNlaXZlVGFza3MgKGluc3RhbmNlSWQsIHRhc2tzKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VNYXBbaW5zdGFuY2VJZF1cbiAgaWYgKGluc3RhbmNlICYmIEFycmF5LmlzQXJyYXkodGFza3MpKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdXG4gICAgdGFza3MuZm9yRWFjaCgodGFzaykgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGpzSGFuZGxlcnNbdGFzay5tZXRob2RdXG4gICAgICBjb25zdCBhcmdzID0gWy4uLnRhc2suYXJnc11cbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBhcmdzLnVuc2hpZnQoaW5zdGFuY2VJZClcbiAgICAgICAgcmVzdWx0cy5wdXNoKGhhbmRsZXIoLi4uYXJncykpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG4gIHJldHVybiBuZXcgRXJyb3IoYGludmFsaWQgaW5zdGFuY2UgaWQgXCIke2luc3RhbmNlSWR9XCIgb3IgdGFza3NgKVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9kZWZhdWx0L3N0YXRpYy9icmlkZ2UuanNcbiAqKi8iLCJpbXBvcnQgeyBpbnN0YW5jZU1hcCB9IGZyb20gJy4vbWFwJ1xuXG4vKipcbiAqIGdldCBhIHdob2xlIGVsZW1lbnQgdHJlZSBvZiBhbiBpbnN0YW5jZVxuICogZm9yIGRlYnVnZ2luZ1xuICogQHBhcmFtICB7c3RyaW5nfSBpbnN0YW5jZUlkXG4gKiBAcmV0dXJuIHtvYmplY3R9IGEgdmlydHVhbCBkb20gdHJlZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um9vdCAoaW5zdGFuY2VJZCkge1xuICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlTWFwW2luc3RhbmNlSWRdXG4gIGxldCByZXN1bHRcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgcmVzdWx0ID0gaW5zdGFuY2UuZ2V0Um9vdEVsZW1lbnQoKVxuICB9XG4gIGVsc2Uge1xuICAgIHJlc3VsdCA9IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0YW5jZSBpZCBcIiR7aW5zdGFuY2VJZH1cImApXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9kZWZhdWx0L3N0YXRpYy9taXNjLmpzXG4gKiovIiwiLyoqXG4gKiBAZmlsZU92ZXJ2aWV3XG4gKiBBIHNpbXBsZSB2aXJ0dWFsIGRvbSBpbXBsZW1lbnRhdGlvblxuICovXG4vLyBpbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuLi9zaGFyZWQnXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMnXG5cbmNvbnN0IERFRkFVTFRfVEFHX05BTUUgPSAnZGl2J1xuXG5leHBvcnQgY29uc3QgaW5zdGFuY2VNYXAgPSB7fVxubGV0IG5leHROb2RlUmVmID0gMVxuXG5leHBvcnQgZnVuY3Rpb24gRG9jdW1lbnQgKGlkLCB1cmwsIGhhbmRsZXIsIExpc3RlbmVyKSB7XG4gIGlkID0gaWQgPyBpZC50b1N0cmluZygpIDogJydcbiAgdGhpcy5pZCA9IGlkXG4gIHRoaXMuVVJMID0gdXJsXG5cbiAgaW5zdGFuY2VNYXBbaWRdID0gdGhpc1xuICB0aGlzLm5vZGVNYXAgPSB7fVxuICBMaXN0ZW5lciAmJiAodGhpcy5saXN0ZW5lciA9IG5ldyBMaXN0ZW5lcihpZCwgaGFuZGxlciB8fCBnZW5DYWxsVGFza3MoaWQpKSlcbiAgdGhpcy5jcmVhdGVEb2N1bWVudEVsZW1lbnQoKVxufVxuXG5mdW5jdGlvbiBnZW5DYWxsVGFza3MgKGlkKSB7XG4gIHJldHVybiAodGFza3MpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFza3MpKSB7XG4gICAgICB0YXNrcyA9IFt0YXNrc11cbiAgICB9XG4gICAgcmV0dXJuIGNhbGxOYXRpdmUoaWQsIHRhc2tzLCAnLTEnKVxuICB9XG59XG5cbkRvY3VtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBkZWxldGUgdGhpcy5saXN0ZW5lclxuICBkZWxldGUgdGhpcy5ub2RlTWFwXG4gIGRlbGV0ZSBpbnN0YW5jZU1hcFt0aGlzLmlkXVxufVxuXG5Eb2N1bWVudC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5saXN0ZW5lci5iYXRjaGVkID0gZmFsc2Vcbn1cblxuRG9jdW1lbnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxpc3RlbmVyLmJhdGNoZWQgPSB0cnVlXG59XG5cbkRvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVEb2N1bWVudEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBjb25zdCBlbCA9IG5ldyBFbGVtZW50KCdkb2N1bWVudCcpXG4gICAgZWwuZG9jSWQgPSB0aGlzLmlkXG4gICAgZWwub3duZXJEb2N1bWVudCA9IHRoaXNcbiAgICBlbC5yb2xlID0gJ2RvY3VtZW50RWxlbWVudCdcbiAgICBlbC5kZXB0aCA9IDBcbiAgICBlbC5yZWYgPSAnX2RvY3VtZW50RWxlbWVudCdcbiAgICB0aGlzLm5vZGVNYXAuX2RvY3VtZW50RWxlbWVudCA9IGVsXG4gICAgdGhpcy5kb2N1bWVudEVsZW1lbnQgPSBlbFxuICAgIGVsLmFwcGVuZENoaWxkID0gKG5vZGUpID0+IHtcbiAgICAgIGFwcGVuZEJvZHkodGhpcywgbm9kZSlcbiAgICB9XG4gICAgZWwuaW5zZXJ0QmVmb3JlID0gKG5vZGUsIGJlZm9yZSkgPT4ge1xuICAgICAgYXBwZW5kQm9keSh0aGlzLCBub2RlLCBiZWZvcmUpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuZG9jdW1lbnRFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFwcGVuZEJvZHkgKGRvYywgbm9kZSwgYmVmb3JlKSB7XG4gIGNvbnN0IHsgZG9jdW1lbnRFbGVtZW50IH0gPSBkb2NcblxuICBpZiAoZG9jdW1lbnRFbGVtZW50LnB1cmVDaGlsZHJlbi5sZW5ndGggPiAwIHx8IG5vZGUucGFyZW50Tm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGNoaWxkcmVuID0gZG9jdW1lbnRFbGVtZW50LmNoaWxkcmVuXG4gIGNvbnN0IGJlZm9yZUluZGV4ID0gY2hpbGRyZW4uaW5kZXhPZihiZWZvcmUpXG4gIGlmIChiZWZvcmVJbmRleCA8IDApIHtcbiAgICBjaGlsZHJlbi5wdXNoKG5vZGUpXG4gIH1cbiAgZWxzZSB7XG4gICAgY2hpbGRyZW4uc3BsaWNlKGJlZm9yZUluZGV4LCAwLCBub2RlKVxuICB9XG5cbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICBpZiAobm9kZS5yb2xlID09PSAnYm9keScpIHtcbiAgICAgIG5vZGUuZG9jSWQgPSBkb2MuaWRcbiAgICAgIG5vZGUub3duZXJEb2N1bWVudCA9IGRvY1xuICAgICAgbm9kZS5wYXJlbnROb2RlID0gZG9jdW1lbnRFbGVtZW50XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgY2hpbGQucGFyZW50Tm9kZSA9IG5vZGVcbiAgICAgIH0pXG4gICAgICBzZXRCb2R5KGRvYywgbm9kZSlcbiAgICAgIG5vZGUuZG9jSWQgPSBkb2MuaWRcbiAgICAgIG5vZGUub3duZXJEb2N1bWVudCA9IGRvY1xuICAgICAgbGlua1BhcmVudChub2RlLCBkb2N1bWVudEVsZW1lbnQpXG4gICAgICBkZWxldGUgZG9jLm5vZGVNYXBbbm9kZS5ub2RlSWRdXG4gICAgfVxuICAgIGRvY3VtZW50RWxlbWVudC5wdXJlQ2hpbGRyZW4ucHVzaChub2RlKVxuICAgIGRvYy5saXN0ZW5lci5jcmVhdGVCb2R5KG5vZGUpXG4gIH1cbiAgZWxzZSB7XG4gICAgbm9kZS5wYXJlbnROb2RlID0gZG9jdW1lbnRFbGVtZW50XG4gICAgZG9jLm5vZGVNYXBbbm9kZS5yZWZdID0gbm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEJvZHkgKGRvYywgZWwpIHtcbiAgZWwucm9sZSA9ICdib2R5J1xuICBlbC5kZXB0aCA9IDFcbiAgZGVsZXRlIGRvYy5ub2RlTWFwW2VsLm5vZGVJZF1cbiAgZWwucmVmID0gJ19yb290J1xuICBkb2Mubm9kZU1hcC5fcm9vdCA9IGVsXG4gIGRvYy5ib2R5ID0gZWxcbn1cblxuRG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZUJvZHkgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgaWYgKCF0aGlzLmJvZHkpIHtcbiAgICBjb25zdCBlbCA9IG5ldyBFbGVtZW50KHR5cGUsIHByb3BzKVxuICAgIHNldEJvZHkodGhpcywgZWwpXG4gIH1cblxuICByZXR1cm4gdGhpcy5ib2R5XG59XG5cbkRvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzKSB7XG4gIHJldHVybiBuZXcgRWxlbWVudCh0YWdOYW1lLCBwcm9wcylcbn1cblxuRG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbW1lbnQgPSBmdW5jdGlvbiAodGV4dCkge1xuICByZXR1cm4gbmV3IENvbW1lbnQodGV4dClcbn1cblxuRG9jdW1lbnQucHJvdG90eXBlLmZpcmVFdmVudCA9IGZ1bmN0aW9uIChlbCwgdHlwZSwgZSwgZG9tQ2hhbmdlcykge1xuICBpZiAoIWVsKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZSA9IGUgfHwge31cbiAgZS50eXBlID0gdHlwZVxuICBlLnRhcmdldCA9IGVsXG4gIGUudGltZXN0YW1wID0gRGF0ZS5ub3coKVxuICBpZiAoZG9tQ2hhbmdlcykge1xuICAgIHVwZGF0ZUVsZW1lbnQoZWwsIGRvbUNoYW5nZXMpXG4gIH1cbiAgcmV0dXJuIGVsLmZpcmVFdmVudCh0eXBlLCBlKVxufVxuXG5Eb2N1bWVudC5wcm90b3R5cGUuZ2V0UmVmID0gZnVuY3Rpb24gKHJlZikge1xuICByZXR1cm4gdGhpcy5ub2RlTWFwW3JlZl1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRWxlbWVudCAoZWwsIGNoYW5nZXMpIHtcbiAgY29uc3QgYXR0cnMgPSBjaGFuZ2VzLmF0dHJzIHx8IHt9XG4gIGZvciAoY29uc3QgbmFtZSBpbiBhdHRycykge1xuICAgIGVsLnNldEF0dHIobmFtZSwgYXR0cnNbbmFtZV0sIHRydWUpXG4gIH1cbiAgY29uc3Qgc3R5bGUgPSBjaGFuZ2VzLnN0eWxlIHx8IHt9XG4gIGZvciAoY29uc3QgbmFtZSBpbiBzdHlsZSkge1xuICAgIGVsLnNldFN0eWxlKG5hbWUsIHN0eWxlW25hbWVdLCB0cnVlKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBOb2RlICgpIHtcbiAgdGhpcy5ub2RlSWQgPSAobmV4dE5vZGVSZWYrKykudG9TdHJpbmcoKVxuICB0aGlzLnJlZiA9IHRoaXMubm9kZUlkXG4gIHRoaXMuY2hpbGRyZW4gPSBbXVxuICB0aGlzLnB1cmVDaGlsZHJlbiA9IFtdXG4gIHRoaXMucGFyZW50Tm9kZSA9IG51bGxcbiAgdGhpcy5uZXh0U2libGluZyA9IG51bGxcbiAgdGhpcy5wcmV2aW91c1NpYmxpbmcgPSBudWxsXG59XG5cbk5vZGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGRvYyA9IGluc3RhbmNlTWFwW3RoaXMuZG9jSWRdXG4gIGlmIChkb2MpIHtcbiAgICBkZWxldGUgdGhpcy5kb2NJZFxuICAgIGRlbGV0ZSBkb2Mubm9kZU1hcFt0aGlzLm5vZGVJZF1cbiAgfVxuICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgIGNoaWxkLmRlc3Ryb3koKVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRWxlbWVudCAodHlwZSA9IERFRkFVTFRfVEFHX05BTUUsIHByb3BzKSB7XG4gIHByb3BzID0gcHJvcHMgfHwge31cbiAgdGhpcy5ub2RlVHlwZSA9IDFcbiAgdGhpcy5ub2RlSWQgPSAobmV4dE5vZGVSZWYrKykudG9TdHJpbmcoKVxuICB0aGlzLnJlZiA9IHRoaXMubm9kZUlkXG4gIHRoaXMudHlwZSA9IHR5cGVcbiAgdGhpcy5hdHRyID0gcHJvcHMuYXR0ciB8fCB7fVxuICB0aGlzLmNsYXNzU3R5bGUgPSBwcm9wcy5jbGFzc1N0eWxlIHx8IHt9XG4gIHRoaXMuc3R5bGUgPSBwcm9wcy5zdHlsZSB8fCB7fVxuICB0aGlzLmV2ZW50ID0ge31cbiAgdGhpcy5jaGlsZHJlbiA9IFtdXG4gIHRoaXMucHVyZUNoaWxkcmVuID0gW11cbn1cblxuRWxlbWVudC5wcm90b3R5cGUgPSBuZXcgTm9kZSgpXG5cbkVsZW1lbnQucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiBub2RlLnBhcmVudE5vZGUgIT09IHRoaXMpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIW5vZGUucGFyZW50Tm9kZSkge1xuICAgIGxpbmtQYXJlbnQobm9kZSwgdGhpcylcbiAgICBpbnNlcnRJbmRleChub2RlLCB0aGlzLmNoaWxkcmVuLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgdHJ1ZSlcbiAgICBpZiAodGhpcy5kb2NJZCkge1xuICAgICAgcmVnaXN0ZXJOb2RlKHRoaXMuZG9jSWQsIG5vZGUpXG4gICAgfVxuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICBpbnNlcnRJbmRleChub2RlLCB0aGlzLnB1cmVDaGlsZHJlbiwgdGhpcy5wdXJlQ2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgaWYgKHRoaXMuZG9jSWQpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBpbnN0YW5jZU1hcFt0aGlzLmRvY0lkXS5saXN0ZW5lclxuICAgICAgICByZXR1cm4gbGlzdGVuZXIuYWRkRWxlbWVudChub2RlLCB0aGlzLnJlZiwgLTEpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIG1vdmVJbmRleChub2RlLCB0aGlzLmNoaWxkcmVuLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgdHJ1ZSlcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgY29uc3QgaW5kZXggPSBtb3ZlSW5kZXgobm9kZSwgdGhpcy5wdXJlQ2hpbGRyZW4sIHRoaXMucHVyZUNoaWxkcmVuLmxlbmd0aClcbiAgICAgIGlmICh0aGlzLmRvY0lkICYmIGluZGV4ID49IDApIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBpbnN0YW5jZU1hcFt0aGlzLmRvY0lkXS5saXN0ZW5lclxuICAgICAgICByZXR1cm4gbGlzdGVuZXIubW92ZUVsZW1lbnQobm9kZS5yZWYsIHRoaXMucmVmLCBpbmRleClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuRWxlbWVudC5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKG5vZGUsIGJlZm9yZSkge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICYmIG5vZGUucGFyZW50Tm9kZSAhPT0gdGhpcykge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChub2RlID09PSBiZWZvcmUgfHwgbm9kZS5uZXh0U2libGluZyA9PT0gYmVmb3JlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFub2RlLnBhcmVudE5vZGUpIHtcbiAgICBsaW5rUGFyZW50KG5vZGUsIHRoaXMpXG4gICAgaW5zZXJ0SW5kZXgobm9kZSwgdGhpcy5jaGlsZHJlbiwgdGhpcy5jaGlsZHJlbi5pbmRleE9mKGJlZm9yZSksIHRydWUpXG4gICAgaWYgKHRoaXMuZG9jSWQpIHtcbiAgICAgIHJlZ2lzdGVyTm9kZSh0aGlzLmRvY0lkLCBub2RlKVxuICAgIH1cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgY29uc3QgcHVyZUJlZm9yZSA9IG5leHRFbGVtZW50KGJlZm9yZSlcbiAgICAgIGNvbnN0IGluZGV4ID0gaW5zZXJ0SW5kZXgoXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHRoaXMucHVyZUNoaWxkcmVuLFxuICAgICAgICBwdXJlQmVmb3JlXG4gICAgICAgICAgPyB0aGlzLnB1cmVDaGlsZHJlbi5pbmRleE9mKHB1cmVCZWZvcmUpXG4gICAgICAgICAgOiB0aGlzLnB1cmVDaGlsZHJlbi5sZW5ndGhcbiAgICAgIClcbiAgICAgIGlmICh0aGlzLmRvY0lkKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gaW5zdGFuY2VNYXBbdGhpcy5kb2NJZF0ubGlzdGVuZXJcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyLmFkZEVsZW1lbnQobm9kZSwgdGhpcy5yZWYsIGluZGV4KVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBtb3ZlSW5kZXgobm9kZSwgdGhpcy5jaGlsZHJlbiwgdGhpcy5jaGlsZHJlbi5pbmRleE9mKGJlZm9yZSksIHRydWUpXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIGNvbnN0IHB1cmVCZWZvcmUgPSBuZXh0RWxlbWVudChiZWZvcmUpXG4gICAgICBjb25zdCBpbmRleCA9IG1vdmVJbmRleChcbiAgICAgICAgbm9kZSxcbiAgICAgICAgdGhpcy5wdXJlQ2hpbGRyZW4sXG4gICAgICAgIHB1cmVCZWZvcmVcbiAgICAgICAgICA/IHRoaXMucHVyZUNoaWxkcmVuLmluZGV4T2YocHVyZUJlZm9yZSlcbiAgICAgICAgICA6IHRoaXMucHVyZUNoaWxkcmVuLmxlbmd0aFxuICAgICAgKVxuICAgICAgaWYgKHRoaXMuZG9jSWQgJiYgaW5kZXggPj0gMCkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGluc3RhbmNlTWFwW3RoaXMuZG9jSWRdLmxpc3RlbmVyXG4gICAgICAgIHJldHVybiBsaXN0ZW5lci5tb3ZlRWxlbWVudChub2RlLnJlZiwgdGhpcy5yZWYsIGluZGV4KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5FbGVtZW50LnByb3RvdHlwZS5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChub2RlLCBhZnRlcikge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICYmIG5vZGUucGFyZW50Tm9kZSAhPT0gdGhpcykge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChub2RlID09PSBhZnRlciB8fCBub2RlLnByZXZpb3VzU2libGluZyA9PT0gYWZ0ZXIpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIW5vZGUucGFyZW50Tm9kZSkge1xuICAgIGxpbmtQYXJlbnQobm9kZSwgdGhpcylcbiAgICBpbnNlcnRJbmRleChub2RlLCB0aGlzLmNoaWxkcmVuLCB0aGlzLmNoaWxkcmVuLmluZGV4T2YoYWZ0ZXIpICsgMSwgdHJ1ZSlcbiAgICBpZiAodGhpcy5kb2NJZCkge1xuICAgICAgcmVnaXN0ZXJOb2RlKHRoaXMuZG9jSWQsIG5vZGUpXG4gICAgfVxuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGluc2VydEluZGV4KFxuICAgICAgICBub2RlLFxuICAgICAgICB0aGlzLnB1cmVDaGlsZHJlbixcbiAgICAgICAgdGhpcy5wdXJlQ2hpbGRyZW4uaW5kZXhPZihwcmV2aW91c0VsZW1lbnQoYWZ0ZXIpKSArIDFcbiAgICAgIClcbiAgICAgIGlmICh0aGlzLmRvY0lkKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gaW5zdGFuY2VNYXBbdGhpcy5kb2NJZF0ubGlzdGVuZXJcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyLmFkZEVsZW1lbnQobm9kZSwgdGhpcy5yZWYsIGluZGV4KVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBtb3ZlSW5kZXgobm9kZSwgdGhpcy5jaGlsZHJlbiwgdGhpcy5jaGlsZHJlbi5pbmRleE9mKGFmdGVyKSArIDEsIHRydWUpXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbW92ZUluZGV4KFxuICAgICAgICBub2RlLFxuICAgICAgICB0aGlzLnB1cmVDaGlsZHJlbixcbiAgICAgICAgdGhpcy5wdXJlQ2hpbGRyZW4uaW5kZXhPZihwcmV2aW91c0VsZW1lbnQoYWZ0ZXIpKSArIDFcbiAgICAgIClcbiAgICAgIGlmICh0aGlzLmRvY0lkICYmIGluZGV4ID49IDApIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBpbnN0YW5jZU1hcFt0aGlzLmRvY0lkXS5saXN0ZW5lclxuICAgICAgICByZXR1cm4gbGlzdGVuZXIubW92ZUVsZW1lbnQobm9kZS5yZWYsIHRoaXMucmVmLCBpbmRleClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAobm9kZSwgcHJlc2VydmVkKSB7XG4gIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICByZW1vdmVJbmRleChub2RlLCB0aGlzLmNoaWxkcmVuLCB0cnVlKVxuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICByZW1vdmVJbmRleChub2RlLCB0aGlzLnB1cmVDaGlsZHJlbilcbiAgICAgIGlmICh0aGlzLmRvY0lkKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gaW5zdGFuY2VNYXBbdGhpcy5kb2NJZF0ubGlzdGVuZXJcbiAgICAgICAgbGlzdGVuZXIucmVtb3ZlRWxlbWVudChub2RlLnJlZilcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFwcmVzZXJ2ZWQpIHtcbiAgICBub2RlLmRlc3Ryb3koKVxuICB9XG59XG5cbkVsZW1lbnQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5kb2NJZCkge1xuICAgIGNvbnN0IGxpc3RlbmVyID0gaW5zdGFuY2VNYXBbdGhpcy5kb2NJZF0ubGlzdGVuZXJcbiAgICB0aGlzLnB1cmVDaGlsZHJlbi5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgbGlzdGVuZXIucmVtb3ZlRWxlbWVudChub2RlLnJlZilcbiAgICB9KVxuICB9XG4gIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChub2RlID0+IHtcbiAgICBub2RlLmRlc3Ryb3koKVxuICB9KVxuICB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IDBcbiAgdGhpcy5wdXJlQ2hpbGRyZW4ubGVuZ3RoID0gMFxufVxuXG5mdW5jdGlvbiBuZXh0RWxlbWVudCAobm9kZSkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gbm9kZVxuICAgIH1cbiAgICBub2RlID0gbm9kZS5uZXh0U2libGluZ1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZXZpb3VzRWxlbWVudCAobm9kZSkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gbm9kZVxuICAgIH1cbiAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmdcbiAgfVxufVxuXG5mdW5jdGlvbiBsaW5rUGFyZW50IChub2RlLCBwYXJlbnQpIHtcbiAgbm9kZS5wYXJlbnROb2RlID0gcGFyZW50XG4gIGlmIChwYXJlbnQuZG9jSWQpIHtcbiAgICBub2RlLmRvY0lkID0gcGFyZW50LmRvY0lkXG4gICAgbm9kZS5vd25lckRvY3VtZW50ID0gcGFyZW50Lm93bmVyRG9jdW1lbnRcbiAgICBub2RlLm93bmVyRG9jdW1lbnQubm9kZU1hcFtub2RlLm5vZGVJZF0gPSBub2RlXG4gICAgbm9kZS5kZXB0aCA9IHBhcmVudC5kZXB0aCArIDFcbiAgfVxuICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgIGxpbmtQYXJlbnQoY2hpbGQsIG5vZGUpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTm9kZSAoZG9jSWQsIG5vZGUpIHtcbiAgY29uc3QgZG9jID0gaW5zdGFuY2VNYXBbZG9jSWRdXG4gIGRvYy5ub2RlTWFwW25vZGUubm9kZUlkXSA9IG5vZGVcbn1cblxuZnVuY3Rpb24gaW5zZXJ0SW5kZXggKHRhcmdldCwgbGlzdCwgbmV3SW5kZXgsIGNoYW5nZVNpYmxpbmcpIHtcbiAgaWYgKG5ld0luZGV4IDwgMCkge1xuICAgIG5ld0luZGV4ID0gMFxuICB9XG4gIGNvbnN0IGJlZm9yZSA9IGxpc3RbbmV3SW5kZXggLSAxXVxuICBjb25zdCBhZnRlciA9IGxpc3RbbmV3SW5kZXhdXG4gIGxpc3Quc3BsaWNlKG5ld0luZGV4LCAwLCB0YXJnZXQpXG4gIGlmIChjaGFuZ2VTaWJsaW5nKSB7XG4gICAgYmVmb3JlICYmIChiZWZvcmUubmV4dFNpYmxpbmcgPSB0YXJnZXQpXG4gICAgdGFyZ2V0LnByZXZpb3VzU2libGluZyA9IGJlZm9yZVxuICAgIHRhcmdldC5uZXh0U2libGluZyA9IGFmdGVyXG4gICAgYWZ0ZXIgJiYgKGFmdGVyLnByZXZpb3VzU2libGluZyA9IHRhcmdldClcbiAgfVxuICByZXR1cm4gbmV3SW5kZXhcbn1cblxuZnVuY3Rpb24gbW92ZUluZGV4ICh0YXJnZXQsIGxpc3QsIG5ld0luZGV4LCBjaGFuZ2VTaWJsaW5nKSB7XG4gIGNvbnN0IGluZGV4ID0gbGlzdC5pbmRleE9mKHRhcmdldClcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChjaGFuZ2VTaWJsaW5nKSB7XG4gICAgY29uc3QgYmVmb3JlID0gbGlzdFtpbmRleCAtIDFdXG4gICAgY29uc3QgYWZ0ZXIgPSBsaXN0W2luZGV4ICsgMV1cbiAgICBiZWZvcmUgJiYgKGJlZm9yZS5uZXh0U2libGluZyA9IGFmdGVyKVxuICAgIGFmdGVyICYmIChhZnRlci5wcmV2aW91c1NpYmxpbmcgPSBiZWZvcmUpXG4gIH1cbiAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpXG4gIGxldCBuZXdJbmRleEFmdGVyID0gbmV3SW5kZXhcbiAgaWYgKGluZGV4IDw9IG5ld0luZGV4KSB7XG4gICAgbmV3SW5kZXhBZnRlciA9IG5ld0luZGV4IC0gMVxuICB9XG4gIGNvbnN0IGJlZm9yZU5ldyA9IGxpc3RbbmV3SW5kZXhBZnRlciAtIDFdXG4gIGNvbnN0IGFmdGVyTmV3ID0gbGlzdFtuZXdJbmRleEFmdGVyXVxuICBsaXN0LnNwbGljZShuZXdJbmRleEFmdGVyLCAwLCB0YXJnZXQpXG4gIGlmIChjaGFuZ2VTaWJsaW5nKSB7XG4gICAgYmVmb3JlTmV3ICYmIChiZWZvcmVOZXcubmV4dFNpYmxpbmcgPSB0YXJnZXQpXG4gICAgdGFyZ2V0LnByZXZpb3VzU2libGluZyA9IGJlZm9yZU5ld1xuICAgIHRhcmdldC5uZXh0U2libGluZyA9IGFmdGVyTmV3XG4gICAgYWZ0ZXJOZXcgJiYgKGFmdGVyTmV3LnByZXZpb3VzU2libGluZyA9IHRhcmdldClcbiAgfVxuICBpZiAoaW5kZXggPT09IG5ld0luZGV4QWZ0ZXIpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICByZXR1cm4gbmV3SW5kZXhcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSW5kZXggKHRhcmdldCwgbGlzdCwgY2hhbmdlU2libGluZykge1xuICBjb25zdCBpbmRleCA9IGxpc3QuaW5kZXhPZih0YXJnZXQpXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoY2hhbmdlU2libGluZykge1xuICAgIGNvbnN0IGJlZm9yZSA9IGxpc3RbaW5kZXggLSAxXVxuICAgIGNvbnN0IGFmdGVyID0gbGlzdFtpbmRleCArIDFdXG4gICAgYmVmb3JlICYmIChiZWZvcmUubmV4dFNpYmxpbmcgPSBhZnRlcilcbiAgICBhZnRlciAmJiAoYWZ0ZXIucHJldmlvdXNTaWJsaW5nID0gYmVmb3JlKVxuICB9XG4gIGxpc3Quc3BsaWNlKGluZGV4LCAxKVxufVxuXG5FbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIHNpbGVudCkge1xuICBpZiAodGhpcy5hdHRyW2tleV0gPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5hdHRyW2tleV0gPSB2YWx1ZVxuICBpZiAoIXNpbGVudCAmJiB0aGlzLmRvY0lkKSB7XG4gICAgY29uc3QgbGlzdGVuZXIgPSBpbnN0YW5jZU1hcFt0aGlzLmRvY0lkXS5saXN0ZW5lclxuICAgIGxpc3RlbmVyLnNldEF0dHIodGhpcy5yZWYsIGtleSwgdmFsdWUpXG4gIH1cbn1cblxuRWxlbWVudC5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgc2lsZW50KSB7XG4gIGlmICh0aGlzLnN0eWxlW2tleV0gPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5zdHlsZVtrZXldID0gdmFsdWVcbiAgaWYgKCFzaWxlbnQgJiYgdGhpcy5kb2NJZCkge1xuICAgIGNvbnN0IGxpc3RlbmVyID0gaW5zdGFuY2VNYXBbdGhpcy5kb2NJZF0ubGlzdGVuZXJcbiAgICBsaXN0ZW5lci5zZXRTdHlsZSh0aGlzLnJlZiwga2V5LCB2YWx1ZSlcbiAgfVxufVxuXG5FbGVtZW50LnByb3RvdHlwZS5zZXRDbGFzc1N0eWxlID0gZnVuY3Rpb24gKGNsYXNzU3R5bGUpIHtcbiAgdGhpcy5jbGFzc1N0eWxlID0gY2xhc3NTdHlsZVxuICBpZiAodGhpcy5kb2NJZCkge1xuICAgIGNvbnN0IGxpc3RlbmVyID0gaW5zdGFuY2VNYXBbdGhpcy5kb2NJZF0ubGlzdGVuZXJcbiAgICBsaXN0ZW5lci5zZXRTdHlsZXModGhpcy5yZWYsIHRoaXMudG9TdHlsZSgpKVxuICB9XG59XG5cbkVsZW1lbnQucHJvdG90eXBlLmFkZEV2ZW50ID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgaWYgKCF0aGlzLmV2ZW50W3R5cGVdKSB7XG4gICAgdGhpcy5ldmVudFt0eXBlXSA9IGhhbmRsZXJcbiAgICBpZiAodGhpcy5kb2NJZCkge1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSBpbnN0YW5jZU1hcFt0aGlzLmRvY0lkXS5saXN0ZW5lclxuICAgICAgbGlzdGVuZXIuYWRkRXZlbnQodGhpcy5yZWYsIHR5cGUpXG4gICAgfVxuICB9XG59XG5cbkVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgaWYgKHRoaXMuZXZlbnRbdHlwZV0pIHtcbiAgICBkZWxldGUgdGhpcy5ldmVudFt0eXBlXVxuICAgIGlmICh0aGlzLmRvY0lkKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGluc3RhbmNlTWFwW3RoaXMuZG9jSWRdLmxpc3RlbmVyXG4gICAgICBsaXN0ZW5lci5yZW1vdmVFdmVudCh0aGlzLnJlZiwgdHlwZSlcbiAgICB9XG4gIH1cbn1cblxuRWxlbWVudC5wcm90b3R5cGUuZmlyZUV2ZW50ID0gZnVuY3Rpb24gKHR5cGUsIGUpIHtcbiAgY29uc3QgaGFuZGxlciA9IHRoaXMuZXZlbnRbdHlwZV1cbiAgaWYgKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpXG4gIH1cbn1cblxuRWxlbWVudC5wcm90b3R5cGUudG9TdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGV4dGVuZCh7fSwgdGhpcy5jbGFzc1N0eWxlLCB0aGlzLnN0eWxlKVxufVxuXG5FbGVtZW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICByZWY6IHRoaXMucmVmLnRvU3RyaW5nKCksXG4gICAgdHlwZTogdGhpcy50eXBlLFxuICAgIGF0dHI6IHRoaXMuYXR0cixcbiAgICBzdHlsZTogdGhpcy50b1N0eWxlKClcbiAgfVxuICBjb25zdCBldmVudCA9IE9iamVjdC5rZXlzKHRoaXMuZXZlbnQpXG4gIGlmIChldmVudC5sZW5ndGgpIHtcbiAgICByZXN1bHQuZXZlbnQgPSBldmVudFxuICB9XG4gIGlmICh0aGlzLnB1cmVDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXN1bHQuY2hpbGRyZW4gPSB0aGlzLnB1cmVDaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC50b0pTT04oKSlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbkVsZW1lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJzwnICsgdGhpcy50eXBlICtcbiAgICAnIGF0dHI9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuYXR0cikgK1xuICAgICcgc3R5bGU9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMudG9TdHlsZSgpKSArICc+JyArXG4gICAgdGhpcy5wdXJlQ2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQudG9TdHJpbmcoKSkuam9pbignJykgK1xuICAgICc8LycgKyB0aGlzLnR5cGUgKyAnPidcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENvbW1lbnQgKHZhbHVlKSB7XG4gIHRoaXMubm9kZVR5cGUgPSA4XG4gIHRoaXMubm9kZUlkID0gKG5leHROb2RlUmVmKyspLnRvU3RyaW5nKClcbiAgdGhpcy5yZWYgPSB0aGlzLm5vZGVJZFxuICB0aGlzLnR5cGUgPSAnY29tbWVudCdcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIHRoaXMuY2hpbGRyZW4gPSBbXVxuICB0aGlzLnB1cmVDaGlsZHJlbiA9IFtdXG59XG5cbkNvbW1lbnQucHJvdG90eXBlID0gbmV3IE5vZGUoKVxuXG5Db21tZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICc8IS0tICcgKyB0aGlzLnZhbHVlICsgJyAtLT4nXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L3Zkb20vaW5kZXguanNcbiAqKi8iLCIvKipcbiAqIEBmaWxlT3ZlcnZpZXcgVGhlIGFwaSBmb3IgaW52b2tpbmcgd2l0aCBcIiRcIiBwcmVmaXhcbiAqL1xuaW1wb3J0IHsgZXh0ZW5kLCB0eXBvZiB9IGZyb20gJy4uL3V0aWwnXG5cbi8qKlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogY29tbW9uXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgJHZtIGluc3RlYWRcbiAqIGZpbmQgdGhlIHZtIGJ5IGlkXG4gKiBOb3RlOiB0aGVyZSBpcyBvbmx5IG9uZSBpZCBpbiB3aG9sZSBjb21wb25lbnRcbiAqIEBwYXJhbSAge3N0cmluZ30gaWRcbiAqIEByZXR1cm4ge1ZtfVxuICovXG5leHBvcnQgZnVuY3Rpb24gJCAoaWQpIHtcbiAgY29uc29sZS53YXJuKCdbSlMgRnJhbWV3b3JrXSBWbSMkIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgVm0jJHZtIGluc3RlYWQnKVxuICBjb25zdCBpbmZvID0gdGhpcy5faWRzW2lkXVxuICBpZiAoaW5mbykge1xuICAgIHJldHVybiBpbmZvLnZtXG4gIH1cbn1cblxuLyoqXG4gKiBmaW5kIHRoZSBlbGVtZW50IGJ5IGlkXG4gKiBOb3RlOiB0aGVyZSBpcyBvbmx5IG9uZSBpZCBpbiB3aG9sZSBjb21wb25lbnRcbiAqIEBwYXJhbSAge3N0cmluZ30gaWRcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAkZWwgKGlkKSB7XG4gIGNvbnN0IGluZm8gPSB0aGlzLl9pZHNbaWRdXG4gIGlmIChpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8uZWxcbiAgfVxufVxuXG4vKipcbiAqIGZpbmQgdGhlIHZtIG9mIHRoZSBjdXN0b20gY29tcG9uZW50IGJ5IGlkXG4gKiBOb3RlOiB0aGVyZSBpcyBvbmx5IG9uZSBpZCBpbiB3aG9sZSBjb21wb25lbnRcbiAqIEBwYXJhbSAge3N0cmluZ30gaWRcbiAqIEByZXR1cm4ge1ZtfVxuICovXG5leHBvcnQgZnVuY3Rpb24gJHZtIChpZCkge1xuICBjb25zdCBpbmZvID0gdGhpcy5faWRzW2lkXVxuICBpZiAoaW5mbykge1xuICAgIHJldHVybiBpbmZvLnZtXG4gIH1cbn1cblxuLyoqXG4gKiBGaXJlIHdoZW4gZGlmZmVyIHJlbmRlcmluZyBmaW5pc2hlZFxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gJHJlbmRlclRoZW4gKGZuKSB7XG4gIGNvbnN0IGFwcCA9IHRoaXMuX2FwcFxuICBjb25zdCBkaWZmZXIgPSBhcHAuZGlmZmVyXG4gIHJldHVybiBkaWZmZXIudGhlbigoKSA9PiB7XG4gICAgZm4oKVxuICB9KVxufVxuXG4vKipcbiAqIHNjcm9sbCBhbiBlbGVtZW50IHNwZWNpZmllZCBieSBpZCBpbnRvIHZpZXcsXG4gKiBtb3Jlb3ZlciBzcGVjaWZ5IGEgbnVtYmVyIG9mIG9mZnNldCBvcHRpb25hbGx5XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGlkXG4gKiBAcGFyYW0gIHtudW1iZXJ9IG9mZnNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gJHNjcm9sbFRvIChpZCwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUud2FybignW0pTIEZyYW1ld29ya10gVm0jJHNjcm9sbFRvIGlzIGRlcHJlY2F0ZWQsICcgK1xuICAgICAgICAgICdwbGVhc2UgdXNlIFwicmVxdWlyZShcXCdAd2VleC1tb2R1bGUvZG9tXFwnKScgK1xuICAgICAgICAgICcuc2Nyb2xsVG8oZWwsIG9wdGlvbnMpXCIgaW5zdGVhZCcpXG4gIGNvbnN0IGVsID0gdGhpcy4kZWwoaWQpXG4gIGlmIChlbCkge1xuICAgIGNvbnN0IGRvbSA9IHRoaXMuX2FwcC5yZXF1aXJlTW9kdWxlKCdkb20nKVxuICAgIGRvbS5zY3JvbGxUb0VsZW1lbnQoZWwucmVmLCB7IG9mZnNldDogb2Zmc2V0IH0pXG4gIH1cbn1cblxuLyoqXG4gKiBwZXJmb3JtIHRyYW5zaXRpb24gYW5pbWF0aW9uIG9uIGFuIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IGlkXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgaWRcbiAqIEBwYXJhbSAge29iamVjdH0gICBvcHRpb25zXG4gKiBAcGFyYW0gIHtvYmplY3R9ICAgb3B0aW9ucy5zdHlsZXNcbiAqIEBwYXJhbSAge29iamVjdH0gICBvcHRpb25zLmR1cmF0aW9uKG1zKVxuICogQHBhcmFtICB7b2JqZWN0fSAgIFtvcHRpb25zLnRpbWluZ0Z1bmN0aW9uXVxuICogQHBhcmFtICB7b2JqZWN0fSAgIFtvcHRpb25zLmRlbGF5PTAobXMpXVxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiAkdHJhbnNpdGlvbiAoaWQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGVsID0gdGhpcy4kZWwoaWQpXG4gIGlmIChlbCAmJiBvcHRpb25zICYmIG9wdGlvbnMuc3R5bGVzKSB7XG4gICAgY29uc3QgYW5pbWF0aW9uID0gdGhpcy5fYXBwLnJlcXVpcmVNb2R1bGUoJ2FuaW1hdGlvbicpXG4gICAgYW5pbWF0aW9uLnRyYW5zaXRpb24oZWwucmVmLCBvcHRpb25zLCAoLi4uYXJncykgPT4ge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWwsIG9wdGlvbnMuc3R5bGVzKVxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soLi4uYXJncylcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogZ2V0IHNvbWUgY29uZmlnXG4gKiBAcmV0dXJuIHtvYmplY3R9IHNvbWUgY29uZmlnIGZvciBhcHAgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBidW5kbGVVcmxcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZGVidWdcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBlbnZcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBlbnYud2VleFZlcnNpb24oZXguIDEuMC4wKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGVudi5hcHBOYW1lKGV4LiBUQi9UTSlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBlbnYuYXBwVmVyc2lvbihleC4gNS4wLjApXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZW52LnBsYXRmb3JtKGV4LiBpT1MvQW5kcm9pZClcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBlbnYub3NWZXJzaW9uKGV4LiA3LjAuMClcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBlbnYuZGV2aWNlTW9kZWwgKipuYXRpdmUgb25seSoqXG4gKiBAcHJvcGVydHkge251bWJlcn0gZW52LltkZXZpY2VXaWR0aD03NTBdXG4gKiBAcHJvcGVydHkge251bWJlcn0gZW52LmRldmljZUhlaWdodFxuICovXG5leHBvcnQgZnVuY3Rpb24gJGdldENvbmZpZyAoY2FsbGJhY2spIHtcbiAgY29uc3QgY29uZmlnID0gZXh0ZW5kKHtcbiAgICBlbnY6IGdsb2JhbC5XWEVudmlyb25tZW50IHx8IHt9XG4gIH0sIHRoaXMuX2FwcC5vcHRpb25zKVxuICBpZiAodHlwb2YoY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS53YXJuKCdbSlMgRnJhbWV3b3JrXSB0aGUgY2FsbGJhY2sgb2YgVm0jJGdldENvbmZpZyhjYWxsYmFjaykgaXMgZGVwcmVjYXRlZCwgJyArXG4gICAgICAndGhpcyBhcGkgbm93IGNhbiBkaXJlY3RseSBSRVRVUk4gY29uZmlnIGluZm8uJylcbiAgICBjYWxsYmFjayhjb25maWcpXG4gIH1cbiAgcmV0dXJuIGNvbmZpZ1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiByZXF1ZXN0IG5ldHdvcmsgdmlhIGh0dHAgcHJvdG9jb2xcbiAqIEBwYXJhbSAge29iamVjdH0gICBwYXJhbXNcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gJHNlbmRIdHRwIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIGNvbnNvbGUud2FybignW0pTIEZyYW1ld29ya10gVm0jJHNlbmRIdHRwIGlzIGRlcHJlY2F0ZWQsICcgK1xuICAgICAgICAgICdwbGVhc2UgdXNlIFwicmVxdWlyZShcXCdAd2VleC1tb2R1bGUvc3RyZWFtXFwnKScgK1xuICAgICAgICAgICcuc2VuZEh0dHAocGFyYW1zLCBjYWxsYmFjaylcIiBpbnN0ZWFkJylcbiAgY29uc3Qgc3RyZWFtID0gdGhpcy5fYXBwLnJlcXVpcmVNb2R1bGUoJ3N0cmVhbScpXG4gIHN0cmVhbS5zZW5kSHR0cChwYXJhbXMsIGNhbGxiYWNrKVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBvcGVuIGEgdXJsXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybFxuICovXG5leHBvcnQgZnVuY3Rpb24gJG9wZW5VUkwgKHVybCkge1xuICBjb25zb2xlLndhcm4oJ1tKUyBGcmFtZXdvcmtdIFZtIyRvcGVuVVJMIGlzIGRlcHJlY2F0ZWQsICcgK1xuICAgICAgICAgICdwbGVhc2UgdXNlIFwicmVxdWlyZShcXCdAd2VleC1tb2R1bGUvZXZlbnRcXCcpJyArXG4gICAgICAgICAgJy5vcGVuVVJMKHVybClcIiBpbnN0ZWFkJylcbiAgY29uc3QgZXZlbnQgPSB0aGlzLl9hcHAucmVxdWlyZU1vZHVsZSgnZXZlbnQnKVxuICBldmVudC5vcGVuVVJMKHVybClcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogc2V0IGEgdGl0bGUgZm9yIHBhZ2VcbiAqIEBwYXJhbSAge3N0cmluZ30gdGl0bGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uICRzZXRUaXRsZSAodGl0bGUpIHtcbiAgY29uc29sZS53YXJuKCdbSlMgRnJhbWV3b3JrXSBWbSMkc2V0VGl0bGUgaXMgZGVwcmVjYXRlZCwgJyArXG4gICAgICAgICAgJ3BsZWFzZSB1c2UgXCJyZXF1aXJlKFxcJ0B3ZWV4LW1vZHVsZS9wYWdlSW5mb1xcJyknICtcbiAgICAgICAgICAnLnNldFRpdGxlKHRpdGxlKVwiIGluc3RlYWQnKVxuICBjb25zdCBwYWdlSW5mbyA9IHRoaXMuX2FwcC5yZXF1aXJlTW9kdWxlKCdwYWdlSW5mbycpXG4gIHBhZ2VJbmZvLnNldFRpdGxlKHRpdGxlKVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBcInJlcXVpcmUoJ0B3ZWV4LW1vZHVsZS9tb2R1bGVOYW1lJykgaW5zdGVhZFwiXG4gKiBpbnZva2UgYSBuYXRpdmUgbWV0aG9kIGJ5IHNwZWNpZmluZyB0aGUgbmFtZSBvZiBtb2R1bGUgYW5kIG1ldGhvZFxuICogQHBhcmFtICB7c3RyaW5nfSBtb2R1bGVOYW1lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG1ldGhvZE5hbWVcbiAqIEBwYXJhbSAgey4uLip9IHRoZSByZXN0IGFyZ3VtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gJGNhbGwgKG1vZHVsZU5hbWUsIG1ldGhvZE5hbWUsIC4uLmFyZ3MpIHtcbiAgY29uc29sZS53YXJuKCdbSlMgRnJhbWV3b3JrXSBWbSMkY2FsbCBpcyBkZXByZWNhdGVkLCAnICtcbiAgICAncGxlYXNlIHVzZSBcInJlcXVpcmUoXFwnQHdlZXgtbW9kdWxlL21vZHVsZU5hbWVcXCcpXCIgaW5zdGVhZCcpXG4gIGNvbnN0IG1vZHVsZSA9IHRoaXMuX2FwcC5yZXF1aXJlTW9kdWxlKG1vZHVsZU5hbWUpXG4gIGlmIChtb2R1bGUgJiYgbW9kdWxlW21ldGhvZE5hbWVdKSB7XG4gICAgbW9kdWxlW21ldGhvZE5hbWVdKC4uLmFyZ3MpXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvZGVmYXVsdC9hcGkvbWV0aG9kcy5qc1xuICoqLyIsIi8qIGdsb2JhbCBFdmVudCAqL1xuXG4ndXNlIHN0cmljdCdcblxuLy8gY29uc3QgRnJhbWVVcGRhdGVyID0gcmVxdWlyZSgnLi9mcmFtZVVwZGF0ZXInKVxuaW1wb3J0IHsgd2F0Y2hJZk5lZWRlZCB9IGZyb20gJy4vYXBwZWFyV2F0Y2hlcidcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuLi91dGlscydcbi8vIGNvbnN0IGxhenlsb2FkID0gcmVxdWlyZSgnLi9sYXp5bG9hZCcpXG4vLyBjb25zdCBhbmltYXRpb24gPSByZXF1aXJlKCcuL2FuaW1hdGlvbicpXG5cbmNvbnN0IFJFTkRFUklOR19JTkRFTlQgPSA4MDBcblxuY29uc3QgX2luc3RhbmNlTWFwID0ge31cbmNvbnN0IHR5cGVNYXAgPSB7fVxuY29uc3Qgc2Nyb2xsYWJsZVR5cGVzID0gW1xuICAnc2Nyb2xsZXInLFxuICAnaHNjcm9sbGVyJyxcbiAgJ3ZzY3JvbGxlcicsXG4gICdsaXN0JyxcbiAgJ2hsaXN0JyxcbiAgJ3ZsaXN0J1xuXVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb21wb25lbnRNYW5hZ2VyIChpZCkge1xuICB0aGlzLmlkID0gaWRcbiAgdGhpcy5iYXRjaGVkID0gZmFsc2VcbiAgdGhpcy51cGRhdGVzID0gW11cbiAgdGhpcy5jb21wb25lbnRNYXAgPSB7fVxuICBfaW5zdGFuY2VNYXBbdGhpcy5pZF0gPSB0aGlzXG59XG5cbkNvbXBvbmVudE1hbmFnZXIuZ2V0SW5zdGFuY2UgPSBpbnN0YW5jZUlkID0+IF9pbnN0YW5jZU1hcFtpbnN0YW5jZUlkXVxuXG5Db21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyQ29tcG9uZW50ID0gKHR5cGUsIGRlZmluaXRpb24pID0+IHtcbiAgdHlwZU1hcFt0eXBlXSA9IGRlZmluaXRpb25cbn1cblxuQ29tcG9uZW50TWFuYWdlci5nZXRTY3JvbGxhYmxlVHlwZXMgPSAoKSA9PiBzY3JvbGxhYmxlVHlwZXNcblxuQ29tcG9uZW50TWFuYWdlci5wcm90b3R5cGUgPSB7XG5cbiAgZ2V0V2VleEluc3RhbmNlICgpIHtcbiAgICBpZiAoIXRoaXMuX3dlZXhJbnN0YW5jZSkge1xuICAgICAgdGhpcy5fd2VleEluc3RhbmNlID0gZ2xvYmFsLndlZXhcbiAgICAgICAgPyBnbG9iYWwud2VleC5nZXRJbnN0YW5jZSh0aGlzLmlkKVxuICAgICAgICA6IG51bGxcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dlZXhJbnN0YW5jZVxuICB9LFxuXG4gIC8vIEZpcmUgYSBldmVudCAncmVuZGVyYmVnaW4nLydyZW5kZXJlbmQnIG9uIGJvZHkgZWxlbWVudC5cbiAgcmVuZGVyaW5nICgpIHtcbiAgICBmdW5jdGlvbiBfcmVuZGVyaW5nRW5kICgpIHtcbiAgICAgIC8vIGdldCB3ZWV4IGluc3RhbmNlIHJvb3RcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgncmVuZGVyZW5kJykpXG4gICAgICB0aGlzLl9yZW5kZXJpbmdUaW1lciA9IG51bGxcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlbmRlcmluZ1RpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVuZGVyaW5nVGltZXIpXG4gICAgICB0aGlzLl9yZW5kZXJpbmdUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICAgIF9yZW5kZXJpbmdFbmQuYmluZCh0aGlzKSxcbiAgICAgICAgUkVOREVSSU5HX0lOREVOVFxuICAgICAgKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgncmVuZGVyYmVnaW4nKSlcbiAgICAgIHRoaXMuX3JlbmRlcmluZ1RpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgX3JlbmRlcmluZ0VuZC5iaW5kKHRoaXMpLFxuICAgICAgICBSRU5ERVJJTkdfSU5ERU5UXG4gICAgICApXG4gICAgfVxuICB9LFxuXG4gIGdldENvbXBvbmVudCAocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50TWFwW3JlZl1cbiAgfSxcblxuICByZW1vdmVDb21wb25lbnQgKHJlZikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgaWYgKCFyZWYgfHwgIXRoaXMuY29tcG9uZW50TWFwW3JlZl0pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZW1vdmUgZnJvbSB0aGlzLmNvbXBvbmVudE1hcCBjdXJzaXZlbHlcbiAgICAoZnVuY3Rpb24gX3JlbW92ZUN1cnNpdmVseSAoX3JlZikge1xuICAgICAgY29uc3QgY2hpbGQgPSBzZWxmLmNvbXBvbmVudE1hcFtfcmVmXVxuICAgICAgY29uc3QgbGlzdGVuZXJzID0gY2hpbGQuX2xpc3RlbmVyc1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjaGlsZC5kYXRhLmNoaWxkcmVuXG4gICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgX3JlbW92ZUN1cnNpdmVseShjaGlsZHJlbltpXS5yZWYpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHJlbW92ZSBldmVudHMgZnJvbSBfcmVmIGNvbXBvbmVudFxuICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgICAgY2hpbGQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1t0eXBlXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVsZXRlIGNoaWxkLl9saXN0ZW5lcnNcbiAgICAgIGRlbGV0ZSBjaGlsZC5ub2RlLl9saXN0ZW5lcnNcbiAgICAgIC8vIHJlbW92ZSBfcmVmIGNvbXBvbmVudFxuICAgICAgZGVsZXRlIHNlbGYuY29tcG9uZW50TWFwW19yZWZdXG4gICAgfSkocmVmKVxuICB9LFxuXG4gIGNyZWF0ZUVsZW1lbnQgKGRhdGEsIG5vZGVUeXBlKSB7XG4gICAgbGV0IENvbXBvbmVudFR5cGUgPSB0eXBlTWFwW2RhdGEudHlwZV1cbiAgICBpZiAoIUNvbXBvbmVudFR5cGUpIHtcbiAgICAgIENvbXBvbmVudFR5cGUgPSB0eXBlTWFwWydkaXYnXVxuICAgIH1cblxuICAgIGRhdGEuaW5zdGFuY2VJZCA9IHRoaXMuaWRcbiAgICBkYXRhLnNjYWxlID0gdGhpcy5nZXRXZWV4SW5zdGFuY2UoKS5zY2FsZVxuICAgIGNvbnN0IGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnRUeXBlKGRhdGEsIG5vZGVUeXBlKVxuICAgIGNvbnN0IHJlZiA9IGRhdGEucmVmXG4gICAgdGhpcy5jb21wb25lbnRNYXBbcmVmXSA9IGNvbXBvbmVudFxuICAgIGNvbXBvbmVudC5ub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1yZWYnLCByZWYpXG5cbiAgICByZXR1cm4gY29tcG9uZW50XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNyZWF0ZUJvZHk6IGdlbmVyYXRlIHJvb3QgY29tcG9uZW50XG4gICAqIEBwYXJhbSAge29iamVjdH0gZWxlbWVudFxuICAgKi9cbiAgY3JlYXRlQm9keSAoZWxlbWVudCkge1xuICAgIGNvbnNvbGUubG9nKCdbaDUtcmVuZGVyXSBjcmVhdGVCb2R5JywgZWxlbWVudClcbiAgICBpZiAodGhpcy5jb21wb25lbnRNYXBbJ19yb290J10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbGVtZW50ID0gZWxlbWVudC50b0pTT04oKVxuXG4gICAgY29uc3Qgbm9kZVR5cGUgPSBlbGVtZW50LnR5cGVcbiAgICBlbGVtZW50LnR5cGUgPSAncm9vdCdcbiAgICBlbGVtZW50LnJvb3RJZCA9IHRoaXMuZ2V0V2VleEluc3RhbmNlKCkucm9vdElkXG4gICAgZWxlbWVudC5yZWYgPSAnX3Jvb3QnXG5cbiAgICBjb25zdCByb290ID0gdGhpcy5jcmVhdGVFbGVtZW50KGVsZW1lbnQsIG5vZGVUeXBlKVxuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIHRoaXMuZ2V0V2VleEluc3RhbmNlKCkucm9vdElkKVxuICAgICAgICAgIHx8IGRvY3VtZW50LmJvZHlcbiAgICBib2R5LmFwcGVuZENoaWxkKHJvb3Qubm9kZSlcbiAgICByb290Ll9hcHBlbmRlZCA9IHRydWVcblxuICAgIHRoaXMuaGFuZGxlQXBwZW5kKHJvb3QpXG4gIH0sXG5cbiAgYXBwZW5kQ2hpbGQgKHBhcmVudFJlZiwgZGF0YSkge1xuICAgIGxldCBwYXJlbnQgPSB0aGlzLmNvbXBvbmVudE1hcFtwYXJlbnRSZWZdXG5cbiAgICBpZiAodGhpcy5jb21wb25lbnRNYXBbZGF0YS5yZWZdIHx8ICFwYXJlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChwYXJlbnRSZWYgPT09ICdfcm9vdCcgJiYgIXBhcmVudCkge1xuICAgICAgcGFyZW50ID0gdGhpcy5jcmVhdGVFbGVtZW50KHtcbiAgICAgICAgdHlwZTogJ3Jvb3QnLFxuICAgICAgICByb290SWQ6IHRoaXMuZ2V0V2VleEluc3RhbmNlKCkucm9vdElkLFxuICAgICAgICByZWY6ICdfcm9vdCdcbiAgICAgIH0pXG4gICAgICBwYXJlbnQuX2FwcGVuZGVkID0gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmFwcGVuZENoaWxkKGRhdGEpXG5cbiAgICAvLyBJbiBzb21lIHBhcmVudCBjb21wb25lbnQgdGhlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZFxuICAgIC8vIGFwcGVuZENoaWxkIGRpZG4ndCByZXR1cm4gdGhlIGNvbXBvbmVudCBhdCBhbGwsIHRoZXJlZm9yXG4gICAgLy8gY2hpbGQgbWF5YmUgYSB1bmRlZmluZWQgb2JqZWN0LlxuICAgIGlmIChjaGlsZCkge1xuICAgICAgY2hpbGQucGFyZW50UmVmID0gcGFyZW50UmVmXG4gICAgfVxuXG4gICAgaWYgKGNoaWxkICYmIHBhcmVudC5fYXBwZW5kZWQpIHtcbiAgICAgIHRoaXMuaGFuZGxlQXBwZW5kKGNoaWxkKVxuICAgIH1cbiAgfSxcblxuICAvLyBhcHBlbmRDaGlsZHJlbiAocmVmLCBlbGVtZW50cykge1xuICAvLyAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgLy8gICAgIHRoaXMuYXBwZW5kQ2hpbGQocmVmLCBlbGVtZW50c1tpXSlcbiAgLy8gICB9XG4gIC8vIH0sXG5cbiAgcmVtb3ZlRWxlbWVudCAocmVmKSB7XG4gICAgaWYgKGlzQXJyYXkocmVmKSkge1xuICAgICAgcmV0dXJuIHJlZi5tYXAociA9PiB0aGlzLnJlbW92ZUVsZW1lbnQocikpXG4gICAgfVxuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50TWFwW3JlZl1cbiAgICAvLyBmaXJlIGV2ZW50IGZvciByZW5kZXJpbmcgZG9tIG9uIGJvZHkgZWxtZW50LlxuICAgIHRoaXMucmVuZGVyaW5nKClcblxuICAgIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LnBhcmVudFJlZikge1xuICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5jb21wb25lbnRNYXBbY29tcG9uZW50LnBhcmVudFJlZl1cbiAgICAgIGNvbXBvbmVudC5vblJlbW92ZSAmJiBjb21wb25lbnQub25SZW1vdmUoKVxuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNvbXBvbmVudClcbiAgICB9XG4gICAgZWxzZSBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgY29uc29sZS5lcnJvcihgW2g1LXJlbmRlcl0gY29tcG9uZW50IG9mIHJlZiAnJHtyZWZ9JyBkb2VzIG5vdCBleGlzdC5gKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtoNS1yZW5kZXJdIHBhcmVudCBjb21wb25lbnQgJyR7Y29tcG9uZW50LnBhcmVudFJlZn0nIGRvZXMgbm90IGV4aXN0LmApXG4gICAgfVxuICB9LFxuXG4gIG1vdmVFbGVtZW50IChyZWYsIHBhcmVudFJlZiwgaW5kZXgpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudE1hcFtyZWZdXG4gICAgY29uc3QgbmV3UGFyZW50ID0gdGhpcy5jb21wb25lbnRNYXBbcGFyZW50UmVmXVxuICAgIGNvbnN0IG9sZFBhcmVudFJlZiA9IGNvbXBvbmVudC5wYXJlbnRSZWZcbiAgICBsZXQgY2hpbGRyZW4sIGJlZm9yZSwgaSwgbFxuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgW2g1LXJlbmRlcl0gY29tcG9uZW50IG9mIHJlZiAnJHtyZWZ9JyBkb2VzIG5vdCBleGlzdC5gKVxuICAgIH1cbiAgICBpZiAoIW5ld1BhcmVudCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBbaDUtcmVuZGVyXSBwYXJlbnQgY29tcG9uZW50ICcke3BhcmVudFJlZn0nIGRvZXMgbm90IGV4aXN0LmApXG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgLTEpIHtcbiAgICAgIGluZGV4ID0gLTFcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSBpbmRleCBjYW5ub3QgYmUgbGVzcyB0aGFuIC0xLicpXG4gICAgfVxuXG4gICAgLy8gZmlyZSBldmVudCBmb3IgcmVuZGVyaW5nLlxuICAgIHRoaXMucmVuZGVyaW5nKClcblxuICAgIGNoaWxkcmVuID0gbmV3UGFyZW50LmRhdGEuY2hpbGRyZW5cbiAgICBpZiAoY2hpbGRyZW5cbiAgICAgICAgJiYgY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgICYmIGluZGV4ICE9PSAtMVxuICAgICAgICAmJiBpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgYmVmb3JlID0gdGhpcy5jb21wb25lbnRNYXBbbmV3UGFyZW50LmRhdGEuY2hpbGRyZW5baW5kZXhdLnJlZl1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgZnJvbSBvbGRQYXJlbnQuZGF0YS5jaGlsZHJlblxuICAgIGlmIChvbGRQYXJlbnRSZWYgJiYgdGhpcy5jb21wb25lbnRNYXBbb2xkUGFyZW50UmVmXSkge1xuICAgICAgY2hpbGRyZW4gPSB0aGlzLmNvbXBvbmVudE1hcFtvbGRQYXJlbnRSZWZdLmRhdGEuY2hpbGRyZW5cbiAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChjaGlsZHJlbltpXS5yZWYgPT09IHJlZikge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGwgPiBpKSB7XG4gICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDEpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXdQYXJlbnQuaW5zZXJ0QmVmb3JlKGNvbXBvbmVudCwgYmVmb3JlKVxuXG4gICAgY29tcG9uZW50Lm9uTW92ZSAmJiBjb21wb25lbnQub25Nb3ZlKHBhcmVudFJlZiwgaW5kZXgpXG4gIH0sXG5cbiAgaW5zZXJ0QmVmb3JlIChyZWYsIGRhdGEpIHtcbiAgICBsZXQgY2hpbGQsIHBhcmVudFxuICAgIGNvbnN0IGJlZm9yZSA9IHRoaXMuY29tcG9uZW50TWFwW3JlZl1cbiAgICBjaGlsZCA9IHRoaXMuY29tcG9uZW50TWFwW2RhdGEucmVmXVxuICAgIGJlZm9yZSAmJiAocGFyZW50ID0gdGhpcy5jb21wb25lbnRNYXBbYmVmb3JlLnBhcmVudFJlZl0pXG4gICAgaWYgKGNoaWxkIHx8ICFwYXJlbnQgfHwgIWJlZm9yZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY2hpbGQgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoZGF0YSlcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNoaWxkLnBhcmVudFJlZiA9IGJlZm9yZS5wYXJlbnRSZWZcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZSlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb21wb25lbnRNYXBbYmVmb3JlLnBhcmVudFJlZl0uX2FwcGVuZGVkKSB7XG4gICAgICB0aGlzLmhhbmRsZUFwcGVuZChjaGlsZClcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGFkZEVsZW1lbnRcbiAgICogSWYgaW5kZXggaXMgbGFyZ2V0IHRoYW4gYW55IGNoaWxkJ3MgaW5kZXgsIHRoZVxuICAgKiBlbGVtZW50IHdpbGwgYmUgYXBwZW5kZWQgYmVoaW5kLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50UmVmXG4gICAqIEBwYXJhbSB7b2JqfSBlbGVtZW50IChkYXRhIG9mIHRoZSBjb21wb25lbnQpXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgYWRkRWxlbWVudCAoZWxlbWVudCwgcGFyZW50UmVmLCBpbmRleCkge1xuICAgIC8vIGZpcmUgZXZlbnQgZm9yIHJlbmRlcmluZyBkb20gb24gYm9keSBlbG1lbnQuXG4gICAgZWxlbWVudCA9IGVsZW1lbnQudG9KU09OKClcbiAgICB0aGlzLnJlbmRlcmluZygpXG5cbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmNvbXBvbmVudE1hcFtwYXJlbnRSZWZdXG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5kYXRhLmNoaWxkcmVuXG4gICAgLy8gLTEgbWVhbnMgYXBwZW5kIGFzIHRoZSBsYXN0LlxuICAgIGlmIChpbmRleCA8IC0xKSB7XG4gICAgICBpbmRleCA9IC0xXG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0gaW5kZXggY2Fubm90IGJlIGxlc3MgdGhhbiAtMS4nKVxuICAgIH1cbiAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgICYmIGNoaWxkcmVuLmxlbmd0aCA+IGluZGV4XG4gICAgICAgICYmIGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoY2hpbGRyZW5baW5kZXhdLnJlZiwgZWxlbWVudClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHBhcmVudFJlZiwgZWxlbWVudClcbiAgICB9XG4gIH0sXG5cbiAgYWRkRXZlbnQgKHJlZiwgdHlwZSkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50TWFwW3JlZl1cbiAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYFtoNS1yZW5kZXJdIGNvbXBvbmVudCBvZiByZWYgJyR7cmVmfScgZG9lcyBub3QgZXhpc3QuYClcbiAgICB9XG4gICAgY29tcG9uZW50LmJpbmRFdmVudHMoW3R5cGVdKVxuICB9LFxuXG4gIHJlbW92ZUV2ZW50IChyZWYsIHR5cGUpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudE1hcFtyZWZdXG4gICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGBbaDUtcmVuZGVyXSBjb21wb25lbnQgb2YgcmVmICcke3JlZn0nIGRvZXMgbm90IGV4aXN0LmApXG4gICAgfVxuICAgIGNvbXBvbmVudC51bmJpbmRFdmVudHMoW3R5cGVdKVxuICB9LFxuXG4gIHNldEF0dHIgKHJlZiwga2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50TWFwW3JlZl1cbiAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYFtoNS1yZW5kZXJdIGNvbXBvbmVudCBvZiByZWYgJyR7cmVmfScgZG9lcyBub3QgZXhpc3QuYClcbiAgICB9XG4gICAgY29tcG9uZW50LnVwZGF0ZUF0dHJzKHsgW2tleV06IHZhbHVlIH0pXG4gICAgLy8gaWYgKGNvbXBvbmVudC5kYXRhLnR5cGUgPT09ICdpbWFnZScgJiYga2V5ID09PSAnc3JjJykge1xuICAgIC8vICBjb21wb25lbnQuZmlyZVxuICAgIC8vICBsYXp5bG9hZC5zdGFydElmTmVlZGVkKGNvbXBvbmVudClcbiAgICAvLyB9XG4gIH0sXG5cbiAgc2V0U3R5bGUgKHJlZiwga2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50TWFwW3JlZl1cbiAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYFtoNS1yZW5kZXJdIGNvbXBvbmVudCBvZiByZWYgJyR7cmVmfScgZG9lcyBub3QgZXhpc3QuYClcbiAgICB9XG4gICAgY29tcG9uZW50LnVwZGF0ZVN0eWxlKHsgW2tleV06IHZhbHVlIH0pXG4gIH0sXG5cbiAgc2V0U3R5bGVzIChyZWYsIHN0eWxlKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRNYXBbcmVmXVxuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgW2g1LXJlbmRlcl0gY29tcG9uZW50IG9mIHJlZiAnJHtyZWZ9JyBkb2VzIG5vdCBleGlzdC5gKVxuICAgIH1cbiAgICBjb21wb25lbnQudXBkYXRlU3R5bGUoc3R5bGUpXG4gIH0sXG5cbiAgaGFuZGxlQXBwZW5kIChjb21wb25lbnQpIHtcbiAgICBjb21wb25lbnQuX2FwcGVuZGVkID0gdHJ1ZVxuICAgIGNvbXBvbmVudC5vbkFwcGVuZCAmJiBjb21wb25lbnQub25BcHBlbmQoKVxuXG4gICAgLy8gaW52b2tlIG9uQXBwZW5kIG9uIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5XG4gICAgY29uc3QgY2hpbGRyZW4gPSBjb21wb25lbnQuZGF0YS5jaGlsZHJlblxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY29tcG9uZW50TWFwW2NoaWxkcmVuW2ldLnJlZl1cbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVBcHBlbmQoY2hpbGQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3YXRjaCBhcHBlYXIvZGlzYXBwZWFyIG9mIHRoZSBjb21wb25lbnQgaWYgbmVlZGVkXG4gICAgd2F0Y2hJZk5lZWRlZChjb21wb25lbnQpXG5cbiAgICAvLyBkbyBsYXp5bG9hZCBpZiBuZWVkZWRcbiAgICBjb21wb25lbnQuZmlyZUxhenlsb2FkKClcbiAgICAvLyBsYXp5bG9hZC5zdGFydElmTmVlZGVkKGNvbXBvbmVudCk7XG4gIH0sXG5cbiAgY3JlYXRlRmluaXNoIChjYWxsYmFjaykge1xuICAgIC8vIFRPRE9cbiAgfSxcblxuICB1cGRhdGVGaW5pc2ggKGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ET1xuICB9LFxuXG4gIHJlZnJlc2hGaW5pc2ggKGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ET1xuICB9XG5cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9kb20vY29tcG9uZW50TWFuYWdlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuLi91dGlscydcblxuY29uc3QgY29tcG9uZW50c0luU2Nyb2xsZXIgPSBbXVxuY29uc3QgY29tcG9uZW50c091dE9mU2Nyb2xsZXIgPSBbXVxubGV0IGxpc3RlbmVkID0gZmFsc2VcbmxldCBkaXJlY3Rpb24gPSAndXAnXG5sZXQgc2Nyb2xsWSA9IDBcblxuZXhwb3J0IGZ1bmN0aW9uIHdhdGNoSWZOZWVkZWQgKGNvbXBvbmVudCkge1xuICBpZiAobmVlZFdhdGNoKGNvbXBvbmVudCkpIHtcbiAgICBpZiAoY29tcG9uZW50LmlzSW5TY3JvbGxhYmxlKCkpIHtcbiAgICAgIGNvbXBvbmVudHNJblNjcm9sbGVyLnB1c2goY29tcG9uZW50KVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbXBvbmVudHNPdXRPZlNjcm9sbGVyLnB1c2goY29tcG9uZW50KVxuICAgIH1cbiAgICBpZiAoIWxpc3RlbmVkKSB7XG4gICAgICBsaXN0ZW5lZCA9IHRydWVcbiAgICAgIC8vIGNvbnN0IGhhbmRsZXIgPSB0aHJvdHRsZShvblNjcm9sbCwgMjUpXG4gICAgICBjb25zdCBoYW5kbGVyID0gdGhyb3R0bGUob25TY3JvbGwsIDEwMClcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVyLCBmYWxzZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbmVlZFdhdGNoIChjb21wb25lbnQpIHtcbiAgY29uc3QgZXZlbnRzID0gY29tcG9uZW50LmRhdGEuZXZlbnRcbiAgaWYgKGV2ZW50c1xuICAgICAgJiYgKGV2ZW50cy5pbmRleE9mKCdhcHBlYXInKSAhPT0gLTFcbiAgICAgICAgfHwgZXZlbnRzLmluZGV4T2YoJ2Rpc2FwcGVhcicpICE9PSAtMSkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBvblNjcm9sbCAoZSkge1xuICAvLyBJZiB0aGUgc2Nyb2xsIGV2ZW50IGlzIGRpc3BhdGNoZWQgZnJvbSBhIHNjcm9sbGFibGUgY29tcG9uZW50XG4gIC8vIGltcGxlbWVudGVkIHRocm91Z2ggc2Nyb2xsZXJqcywgdGhlbiB0aGUgYXBwZWFyL2Rpc2FwcGVhciBldmVudHNcbiAgLy8gc2hvdWxkIGJlIHRyZWF0ZWQgc3BlY2lhbGx5IGJ5IGhhbmRsZVNjcm9sbGVyU2Nyb2xsLlxuICBpZiAoZS5vcmlnaW5hbFR5cGUgPT09ICdzY3JvbGxpbmcnKSB7XG4gICAgaGFuZGxlU2Nyb2xsZXJTY3JvbGwoZSlcbiAgfVxuICBlbHNlIHtcbiAgICBoYW5kbGVXaW5kb3dTY3JvbGwoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVNjcm9sbGVyU2Nyb2xsIChlKSB7XG4gIGNvbnN0IGNtcHMgPSBjb21wb25lbnRzSW5TY3JvbGxlclxuICBjb25zdCBsZW4gPSBjbXBzLmxlbmd0aFxuICBkaXJlY3Rpb24gPSBlLmRpcmVjdGlvblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gY21wc1tpXVxuICAgIGNvbnN0IGFwcGVhciA9IGlzQ29tcG9uZW50SW5TY3JvbGxlckFwcGVhcihjb21wb25lbnQpXG4gICAgaWYgKGFwcGVhciAmJiAhY29tcG9uZW50Ll9hcHBlYXIpIHtcbiAgICAgIGNvbXBvbmVudC5fYXBwZWFyID0gdHJ1ZVxuICAgICAgZmlyZUV2ZW50KGNvbXBvbmVudCwgJ2FwcGVhcicpXG4gICAgfVxuICAgIGVsc2UgaWYgKCFhcHBlYXIgJiYgY29tcG9uZW50Ll9hcHBlYXIpIHtcbiAgICAgIGNvbXBvbmVudC5fYXBwZWFyID0gZmFsc2VcbiAgICAgIGZpcmVFdmVudChjb21wb25lbnQsICdkaXNhcHBlYXInKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVXaW5kb3dTY3JvbGwgKCkge1xuICBjb25zdCB5ID0gd2luZG93LnNjcm9sbFlcbiAgZGlyZWN0aW9uID0geSA+PSBzY3JvbGxZID8gJ3VwJyA6ICdkb3duJ1xuICBzY3JvbGxZID0geVxuXG4gIGNvbnN0IGxlbiA9IGNvbXBvbmVudHNPdXRPZlNjcm9sbGVyLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNPdXRPZlNjcm9sbGVyW2ldXG4gICAgY29uc3QgYXBwZWFyID0gaXNDb21wb25lbnRJbldpbmRvdyhjb21wb25lbnQpXG4gICAgaWYgKGFwcGVhciAmJiAhY29tcG9uZW50Ll9hcHBlYXIpIHtcbiAgICAgIGNvbXBvbmVudC5fYXBwZWFyID0gdHJ1ZVxuICAgICAgZmlyZUV2ZW50KGNvbXBvbmVudCwgJ2FwcGVhcicpXG4gICAgfVxuICAgIGVsc2UgaWYgKCFhcHBlYXIgJiYgY29tcG9uZW50Ll9hcHBlYXIpIHtcbiAgICAgIGNvbXBvbmVudC5fYXBwZWFyID0gZmFsc2VcbiAgICAgIGZpcmVFdmVudChjb21wb25lbnQsICdkaXNhcHBlYXInKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbXBvbmVudEluU2Nyb2xsZXJBcHBlYXIgKGNvbXBvbmVudCkge1xuICBsZXQgcGFyZW50U2Nyb2xsZXIgPSBjb21wb25lbnQuX3BhcmVudFNjcm9sbGVyXG4gIGNvbnN0IGNtcFJlY3QgPSBjb21wb25lbnQubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBpZiAoIWlzQ29tcG9uZW50SW5XaW5kb3coY29tcG9uZW50KSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHdoaWxlIChwYXJlbnRTY3JvbGxlcikge1xuICAgIGNvbnN0IHBhcmVudFJlY3QgPSBwYXJlbnRTY3JvbGxlci5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgaWYgKCEoY21wUmVjdC5yaWdodCA+IHBhcmVudFJlY3QubGVmdFxuICAgICAgICAmJiBjbXBSZWN0LmxlZnQgPCBwYXJlbnRSZWN0LnJpZ2h0XG4gICAgICAgICYmIGNtcFJlY3QuYm90dG9tID4gcGFyZW50UmVjdC50b3BcbiAgICAgICAgJiYgY21wUmVjdC50b3AgPCBwYXJlbnRSZWN0LmJvdHRvbSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBwYXJlbnRTY3JvbGxlciA9IHBhcmVudFNjcm9sbGVyLl9wYXJlbnRTY3JvbGxlclxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzQ29tcG9uZW50SW5XaW5kb3cgKGNvbXBvbmVudCkge1xuICBjb25zdCByZWN0ID0gY29tcG9uZW50Lm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgcmV0dXJuIHJlY3QucmlnaHQgPiAwICYmIHJlY3QubGVmdCA8IHdpbmRvdy5pbm5lcldpZHRoICYmXG4gICAgICAgICByZWN0LmJvdHRvbSA+IDAgJiYgcmVjdC50b3AgPCB3aW5kb3cuaW5uZXJIZWlnaHRcbn1cblxuZnVuY3Rpb24gZmlyZUV2ZW50IChjb21wb25lbnQsIHR5cGUpIHtcbiAgY29uc3QgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKVxuICBjb25zdCBkYXRhID0geyBkaXJlY3Rpb246IGRpcmVjdGlvbiB9XG4gIGV2dC5pbml0RXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlKVxuICBldnQuZGF0YSA9IGRhdGFcbiAgZXh0ZW5kKGV2dCwgZGF0YSlcbiAgY29tcG9uZW50Lm5vZGUuZGlzcGF0Y2hFdmVudChldnQpXG59XG5cbmZ1bmN0aW9uIHRocm90dGxlIChmdW5jLCB3YWl0KSB7XG4gIGxldCBjb250ZXh0LCBhcmdzLCByZXN1bHRcbiAgbGV0IHRpbWVvdXQgPSBudWxsXG4gIGxldCBwcmV2aW91cyA9IDBcbiAgY29uc3QgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJldmlvdXMgPSBEYXRlLm5vdygpXG4gICAgdGltZW91dCA9IG51bGxcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpXG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cylcbiAgICBjb250ZXh0ID0gdGhpc1xuICAgIGFyZ3MgPSBhcmd1bWVudHNcbiAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgICAgdGltZW91dCA9IG51bGxcbiAgICAgIHByZXZpb3VzID0gbm93XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpXG4gICAgfVxuICAgIGVsc2UgaWYgKCF0aW1lb3V0KSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9kb20vYXBwZWFyV2F0Y2hlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb25maWcgPSB7XG4gIHdlZXhWZXJzaW9uOiAnMC41LjAnLFxuICBkZWJ1ZzogZmFsc2UsXG4gIHZhbGlkUm9vdHM6IFsnZGl2JywgJ2xpc3QnLCAndmxpc3QnLCAnc2Nyb2xsZXInXVxufVxuXG5leHBvcnQgZGVmYXVsdCBjb25maWdcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9yZW5kZXIvY29uZmlnLmpzXG4gKiovIiwiLyogZ2xvYmFsIFhNTEh0dHBSZXF1ZXN0ICovXG5cbid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBsb2FkQnlYSFIgKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgaWYgKCFjb25maWcuc291cmNlKSB7XG4gICAgY2FsbGJhY2sobmV3IEVycm9yKCd4aHIgbG9hZGVyOiBtaXNzaW5nIGNvbmZpZy5zb3VyY2UuJykpXG4gIH1cbiAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcbiAgeGhyLm9wZW4oJ0dFVCcsIGNvbmZpZy5zb3VyY2UpXG4gIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgdGhpcy5yZXNwb25zZVRleHQpXG4gIH1cbiAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBjYWxsYmFjayhlcnJvcilcbiAgfVxuICB4aHIuc2VuZCgpXG59XG5cbmZ1bmN0aW9uIGxvYWRCeUpzb25wIChjb25maWcsIGNhbGxiYWNrKSB7XG4gIGlmICghY29uZmlnLnNvdXJjZSkge1xuICAgIGNhbGxiYWNrKG5ldyBFcnJvcignanNvbnAgbG9hZGVyOiBtaXNzaW5nIGNvbmZpZy5zb3VyY2UuJykpXG4gIH1cbiAgY29uc3QgY2FsbGJhY2tOYW1lID0gY29uZmlnLmpzb25wQ2FsbGJhY2sgfHwgJ3dlZXhKc29ucENhbGxiYWNrJ1xuICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgaWYgKGNvZGUpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGNvZGUpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdsb2FkIGJ5IGpzb25wIGVycm9yJykpXG4gICAgfVxuICB9XG4gIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gIHNjcmlwdC5zcmMgPSBkZWNvZGVVUklDb21wb25lbnQoY29uZmlnLnNvdXJjZSlcbiAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0J1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdClcbn1cblxuZnVuY3Rpb24gbG9hZEJ5U291cmNlQ29kZSAoY29uZmlnLCBjYWxsYmFjaykge1xuICAvLyBzcmMgaXMgdGhlIGpzYnVuZGxlLlxuICAvLyBubyBuZWVkIHRvIGZldGNoIGZyb20gYW55d2hlcmUuXG4gIGlmIChjb25maWcuc291cmNlKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgY29uZmlnLnNvdXJjZSlcbiAgfVxuICBlbHNlIHtcbiAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ3NvdXJjZSBjb2RlIGxhb2RlcjogbWlzc2luZyBjb25maWcuc291cmNlLicpKVxuICB9XG59XG5cbmNvbnN0IGNhbGxiYWNrTWFwID0ge1xuICB4aHI6IGxvYWRCeVhIUixcbiAganNvbnA6IGxvYWRCeUpzb25wLFxuICBzb3VyY2U6IGxvYWRCeVNvdXJjZUNvZGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWQgKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGxvYWRGbiA9IGNhbGxiYWNrTWFwW29wdGlvbnMubG9hZGVyXVxuICBsb2FkRm4ob3B0aW9ucywgY2FsbGJhY2spXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckxvYWRlciAobmFtZSwgbG9hZGVyRnVuYykge1xuICBpZiAodHlwZW9mIGxvYWRlckZ1bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFja01hcFtuYW1lXSA9IGxvYWRlckZ1bmNcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL3JlbmRlci9sb2FkZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IHByb3RvY29sIGZyb20gJy4vcHJvdG9jb2wnXG5pbXBvcnQgcmVjZWl2ZXIgZnJvbSAnLi9yZWNlaXZlcidcbmltcG9ydCBTZW5kZXIgZnJvbSAnLi9zZW5kZXInXG5cbmV4cG9ydCB7IHByb3RvY29sLCByZWNlaXZlciwgU2VuZGVyIH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9icmlkZ2UvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0IGRlZmF1bHQge1xuXG4gIC8vIHdlZXggaW5zdGFuY2VzXG4gIF9pbnN0YW5jZXM6IHt9LFxuXG4gIC8vIGFwaSBtZXRhIGluZm9cbiAgX21ldGE6IHt9LFxuXG4gIC8vIFdlZXgucmVnaXN0ZXJBcGlNb2R1bGUgdXNlZCB0aGlzIHRvIHJlZ2lzdGVyIGFuZCBhY2Nlc3MgYXBpTW9kdWxlcy5cbiAgYXBpTW9kdWxlOiB7fSxcblxuICAvLyBnZXQgdGhlIGFwaSBtZXRob2QgbWV0YSBpbmZvIGFycmF5IGZvciB0aGUgbW9kdWxlLlxuICBnZXRBcGlNb2R1bGVNZXRhOiBmdW5jdGlvbiAobW9kdWxlTmFtZSkge1xuICAgIGNvbnN0IG1ldGFPYmogPSB7fVxuICAgIG1ldGFPYmpbbW9kdWxlTmFtZV0gPSB0aGlzLl9tZXRhW21vZHVsZU5hbWVdXG4gICAgcmV0dXJuIG1ldGFPYmpcbiAgfSxcblxuICAvLyBTZXQgbWV0YSBpbmZvIGZvciBhIGFwaSBtb2R1bGUuXG4gIC8vIElmIHRoZXJlIGlzIGEgc2FtZSBuYW1lZCBhcGksIGp1c3QgcmVwbGFjZSBpdC5cbiAgLy8gb3B0czpcbiAgLy8gLSBtZXRhT2JqOiBtZXRhIG9iamVjdCBsaWtlXG4gIC8vIHtcbiAgLy8gICAgZG9tOiBbe1xuICAvLyAgICAgIG5hbWU6ICdhZGRFbGVtZW50JyxcbiAgLy8gICAgICBhcmdzOiBbJ3N0cmluZycsICdvYmplY3QnXVxuICAvLyAgICB9XVxuICAvLyB9XG4gIHNldEFwaU1vZHVsZU1ldGE6IGZ1bmN0aW9uIChtZXRhT2JqKSB7XG4gICAgbGV0IG1vZHVsZU5hbWVcbiAgICBmb3IgKGNvbnN0IGsgaW4gbWV0YU9iaikge1xuICAgICAgaWYgKG1ldGFPYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgbW9kdWxlTmFtZSA9IGtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWV0YUFycmF5ID0gdGhpcy5fbWV0YVttb2R1bGVOYW1lXVxuICAgIGlmICghbWV0YUFycmF5KSB7XG4gICAgICB0aGlzLl9tZXRhW21vZHVsZU5hbWVdID0gbWV0YU9ialttb2R1bGVOYW1lXVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG5hbWVPYmogPSB7fVxuICAgICAgbWV0YU9ialttb2R1bGVOYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChhcGkpIHtcbiAgICAgICAgbmFtZU9ialthcGkubmFtZV0gPSBhcGlcbiAgICAgIH0pXG4gICAgICBtZXRhQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoYXBpLCBpKSB7XG4gICAgICAgIGlmIChuYW1lT2JqW2FwaS5uYW1lXSkge1xuICAgICAgICAgIG1ldGFBcnJheVtpXSA9IG5hbWVPYmpbYXBpLm5hbWVdXG4gICAgICAgICAgZGVsZXRlIG5hbWVPYmpbYXBpLm5hbWVdXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBmb3IgKGNvbnN0IGsgaW4gbWV0YU9iaikge1xuICAgICAgICBpZiAobWV0YU9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgIG1ldGFBcnJheS5wdXNoKG1ldGFPYmpba10pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbWV0YVttb2R1bGVOYW1lXSA9IG1ldGFPYmpbbW9kdWxlTmFtZV1cbiAgfSxcblxuICAvLyBTZXQgbWV0YSBpbmZvIGZvciBhIHNpbmdsZSBhcGkuXG4gIC8vIG9wdHM6XG4gIC8vICAtIG1vZHVsZU5hbWU6IGFwaSBtb2R1bGUgbmFtZS5cbiAgLy8gIC0gbWV0YTogYSBtZXRhIG9iamVjdCBsaWtlOlxuICAvLyAge1xuICAvLyAgICBuYW1lOiAnYWRkRWxlbWVudCcsXG4gIC8vICAgIGFyZ3M6IFsnc3RyaW5nJywgJ29iamVjdCddXG4gIC8vICB9XG4gIHNldEFwaU1ldGE6IGZ1bmN0aW9uIChtb2R1bGVOYW1lLCBtZXRhKSB7XG4gICAgY29uc3QgbWV0YUFycmF5ID0gdGhpcy5fbWV0YVttb2R1bGVOYW1lXVxuICAgIGlmICghbWV0YUFycmF5KSB7XG4gICAgICB0aGlzLl9tZXRhW21vZHVsZU5hbWVdID0gW21ldGFdXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbGV0IG1ldGFJZHggPSAtMVxuICAgICAgbWV0YUFycmF5LmZvckVhY2goZnVuY3Rpb24gKGFwaSwgaSkge1xuICAgICAgICBsZXQgbmFtZSAvLyB0b2RvXG4gICAgICAgIGlmIChtZXRhLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICBtZXRhSWR4ID0gaVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaWYgKG1ldGFJZHggIT09IC0xKSB7XG4gICAgICAgIG1ldGFBcnJheVttZXRhSWR4XSA9IG1ldGFcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtZXRhQXJyYXkucHVzaChtZXRhKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBfcmVnaXN0ZXJNb2R1bGVzKFt7XG4vLyAgIG1vZGFsOiBbe1xuLy8gICAgIG5hbWU6ICd0b2FzdCcsXG4vLyAgICAgYXJnczogWydvYmplY3QnLCAnZnVuY3Rpb24nXVxuLy8gICB9LCB7XG4vLyAgICAgbmFtZTogJ2FsZXJ0Jyxcbi8vICAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbiddXG4vLyAgIH0sIHtcbi8vICAgICBuYW1lOiAnY29uZmlybScsXG4vLyAgICAgYXJnczogWydvYmplY3QnLCAnZnVuY3Rpb24nXVxuLy8gICB9LCB7XG4vLyAgICAgbmFtZTogJ3Byb21wdCcsXG4vLyAgICAgYXJnczogWydvYmplY3QnLCAnZnVuY3Rpb24nXVxuLy8gICB9XVxuLy8gfSwge1xuLy8gICBhbmltYXRpb246IFt7XG4vLyAgICAgbmFtZTogJ3RyYW5zaXRpb24nLFxuLy8gICAgIGFyZ3M6IFsnc3RyaW5nJywgJ29iamVjdCcsICdmdW5jdGlvbiddXG4vLyAgIH1dXG4vLyB9XSlcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9icmlkZ2UvcHJvdG9jb2wuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IGNvbmZpZyBmcm9tICcuLi9yZW5kZXIvY29uZmlnJ1xuaW1wb3J0IHByb3RvY29sIGZyb20gJy4vcHJvdG9jb2wnXG5pbXBvcnQgeyBpc0FycmF5LCBmcmFtZVVwZGF0ZXIgfSBmcm9tICcuLi91dGlscydcbmltcG9ydCBTZW5kZXIgZnJvbSAnLi9zZW5kZXInXG5cbmNvbnN0IGNhbGxRdWV1ZSA9IFtdXG4vLyBOZWVkIGEgdGFzayBjb3VudGVyP1xuLy8gV2hlbiBmcmFtZVVwZGF0ZXIgaXMgbm90IGFjdGl2YXRlZCwgdGFza3Mgd2lsbCBub3QgYmUgcHVzaFxuLy8gaW50byBjYWxsUXVldWUgYW5kIHRoZXJlIHdpbGwgYmUgbm8gdHJhY2UgZm9yIHNpdHVhdGlvbiBvZlxuLy8gZXhlY3V0aW9uIG9mIHRhc2tzLlxuXG4vLyBnaXZlIDEwbXMgZm9yIGNhbGwgaGFuZGxpbmcsIGFuZCByZXN0IDZtcyBmb3Igb3RoZXJzXG5jb25zdCBNQVhfVElNRV9GT1JfRUFDSF9GUkFNRSA9IDEwXG5cbi8vIGNhbGxOYXRpdmU6IGpzRnJhbWV3b3JrIHdpbGwgY2FsbCB0aGlzIG1ldGhvZCB0byB0YWxrIHRvXG4vLyB0aGlzIHJlbmRlcmVyLlxuLy8gcGFyYW1zOlxuLy8gIC0gaW5zdGFuY2VJZDogc3RyaW5nLlxuLy8gIC0gdGFza3M6IGFycmF5IG9mIG9iamVjdC5cbi8vICAtIGNhbGxiYWNrSWQ6IG51bWJlci5cbmZ1bmN0aW9uIGNhbGxOYXRpdmUgKGluc3RhbmNlSWQsIHRhc2tzLCBjYWxsYmFja0lkKSB7XG4gIGxldCBjYWxscyA9IFtdXG4gIGlmICh0eXBlb2YgdGFza3MgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNhbGxzID0gSlNPTi5wYXJzZSh0YXNrcylcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2ludmFsaWQgdGFza3M6JywgdGFza3MpXG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGlzQXJyYXkodGFza3MpKSB7XG4gICAgY2FsbHMgPSB0YXNrc1xuICB9XG4gIGNvbnN0IGxlbiA9IGNhbGxzLmxlbmd0aFxuICBjYWxsc1tsZW4gLSAxXS5jYWxsYmFja0lkID0gKCFjYWxsYmFja0lkICYmIGNhbGxiYWNrSWQgIT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNhbGxiYWNrSWRcbiAgLy8gVG8gc29sdmUgdGhlIHByb2JsZW0gb2YgY2FsbGFwcCwgdGhlIHR3by13YXkgdGltZSBsb29wIHJ1bGUgbXVzdFxuICAvLyBiZSByZXBsYWNlZCBieSBjYWxsaW5nIGRpcmVjdGx5IGV4Y2VwdCB0aGUgc2l0dWF0aW9uIG9mIHBhZ2UgbG9hZGluZy5cbiAgLy8gMjAxNS0xMS0wM1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGZyYW1lVXBkYXRlci5pc0FjdGl2ZSgpKSB7XG4gICAgICBjYWxsUXVldWUucHVzaCh7XG4gICAgICAgIGluc3RhbmNlSWQ6IGluc3RhbmNlSWQsXG4gICAgICAgIGNhbGw6IGNhbGxzW2ldXG4gICAgICB9KVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHByb2Nlc3NDYWxsKGluc3RhbmNlSWQsIGNhbGxzW2ldKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ2FsbFF1ZXVlICgpIHtcbiAgbGV0IGxlbiA9IGNhbGxRdWV1ZS5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKVxuICBsZXQgZWxhcHNlZCA9IDBcblxuICB3aGlsZSAoLS1sZW4gPj0gMCAmJiBlbGFwc2VkIDwgTUFYX1RJTUVfRk9SX0VBQ0hfRlJBTUUpIHtcbiAgICBjb25zdCBjYWxsT2JqID0gY2FsbFF1ZXVlLnNoaWZ0KClcbiAgICBwcm9jZXNzQ2FsbChjYWxsT2JqLmluc3RhbmNlSWQsIGNhbGxPYmouY2FsbClcbiAgICBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIHN0YXJ0XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NhbGwgKGluc3RhbmNlSWQsIGNhbGwpIHtcbiAgY29uc3QgbW9kdWxlTmFtZSA9IGNhbGwubW9kdWxlXG4gIGNvbnN0IG1ldGhvZE5hbWUgPSBjYWxsLm1ldGhvZFxuICBsZXQgbW9kdWxlLCBtZXRob2RcbiAgY29uc3QgYXJncyA9IGNhbGwuYXJncyB8fCBjYWxsLmFyZ3VtZW50cyB8fCBbXVxuXG4gIGlmICghKG1vZHVsZSA9IHByb3RvY29sLmFwaU1vZHVsZVttb2R1bGVOYW1lXSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIShtZXRob2QgPSBtb2R1bGVbbWV0aG9kTmFtZV0pKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBtZXRob2QuYXBwbHkoZ2xvYmFsLndlZXguZ2V0SW5zdGFuY2UoaW5zdGFuY2VJZCksIGFyZ3MpXG5cbiAgY29uc3QgY2FsbGJhY2tJZCA9IGNhbGwuY2FsbGJhY2tJZFxuICBpZiAoKGNhbGxiYWNrSWRcbiAgICB8fCBjYWxsYmFja0lkID09PSAwXG4gICAgfHwgY2FsbGJhY2tJZCA9PT0gJzAnKVxuICAgICYmIGNhbGxiYWNrSWQgIT09ICctMSdcbiAgICAmJiBjYWxsYmFja0lkICE9PSAtMSkge1xuICAgIHBlcmZvcm1OZXh0VGljayhpbnN0YW5jZUlkLCBjYWxsYmFja0lkKVxuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1OZXh0VGljayAoaW5zdGFuY2VJZCwgY2FsbGJhY2tJZCkge1xuICBTZW5kZXIuZ2V0U2VuZGVyKGluc3RhbmNlSWQpLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkKVxufVxuXG5mdW5jdGlvbiBuYXRpdmVMb2cgKCkge1xuICBpZiAoY29uZmlnLmRlYnVnKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXS5tYXRjaCgvXnBlcmYvKSkge1xuICAgICAgY29uc29sZS5pbmZvLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zb2xlLmRlYnVnLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbiAgfVxufVxuXG5mdW5jdGlvbiBleHBvcnRzQnJpZGdlTWV0aG9kc1RvR2xvYmFsICgpIHtcbiAgZ2xvYmFsLmNhbGxOYXRpdmUgPSBjYWxsTmF0aXZlXG4gIGdsb2JhbC5uYXRpdmVMb2cgPSBuYXRpdmVMb2dcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcHJvY2VzcyBjYWxsUXVldWUgZXZlcnkgMTYgbWlsbGlzZWNvbmRzLlxuICAgIGZyYW1lVXBkYXRlci5hZGRVcGRhdGVPYnNlcnZlcihwcm9jZXNzQ2FsbFF1ZXVlKVxuICAgIGZyYW1lVXBkYXRlci5zdGFydCgpXG5cbiAgICAvLyBleHBvcnRzIG1ldGhvZHMgdG8gZ2xvYmFsKHdpbmRvdykuXG4gICAgZXhwb3J0c0JyaWRnZU1ldGhvZHNUb0dsb2JhbCgpXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9icmlkZ2UvcmVjZWl2ZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbHMnXG5cbmNvbnN0IF9zZW5kZXJNYXAgPSB7fVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTZW5kZXIgKGluc3RhbmNlKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTZW5kZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBTZW5kZXIoaW5zdGFuY2UpXG4gIH1cbiAgdGhpcy5pbnN0YW5jZUlkID0gaW5zdGFuY2UuaW5zdGFuY2VJZFxuICB0aGlzLndlZXhJbnN0YW5jZSA9IGluc3RhbmNlXG4gIF9zZW5kZXJNYXBbdGhpcy5pbnN0YW5jZUlkXSA9IHRoaXNcbn1cblxuZnVuY3Rpb24gX3NlbmQgKGluc3RhbmNlSWQsIG1zZykge1xuICBjYWxsSlMoaW5zdGFuY2VJZCwgW21zZ10pXG59XG5cblNlbmRlci5nZXRTZW5kZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2VJZCkge1xuICByZXR1cm4gX3NlbmRlck1hcFtpbnN0YW5jZUlkXVxufVxuXG5TZW5kZXIucHJvdG90eXBlID0ge1xuXG4gIC8vIHBlcmZvcm0gYSBjYWxsYmFjayB0byBqc2ZyYW1ld29yay5cbiAgcGVyZm9ybUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2tJZCwgZGF0YSwga2VlcEFsaXZlKSB7XG4gICAgY29uc3QgYXJncyA9IFtjYWxsYmFja0lkXVxuICAgIGRhdGEgJiYgYXJncy5wdXNoKGRhdGEpXG4gICAga2VlcEFsaXZlICYmIGFyZ3MucHVzaChrZWVwQWxpdmUpXG4gICAgX3NlbmQodGhpcy5pbnN0YW5jZUlkLCB7XG4gICAgICBtZXRob2Q6ICdjYWxsYmFjaycsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSlcbiAgfSxcblxuICBmaXJlRXZlbnQ6IGZ1bmN0aW9uIChyZWYsIHR5cGUsIGZ1bmMsIGV2ZW50KSB7XG4gICAgZnVuYy5leHRyYSAmJiBleHRlbmQoZXZlbnQsIGZ1bmMuZXh0cmEoKSlcbiAgICBfc2VuZCh0aGlzLmluc3RhbmNlSWQsIHtcbiAgICAgIG1ldGhvZDogJ2ZpcmVFdmVudCcsXG4gICAgICBhcmdzOiBbcmVmLCB0eXBlLCBldmVudCwgZnVuYy51cGRhdG9yICYmIGZ1bmMudXBkYXRvcigpXVxuICAgIH0pXG4gIH1cblxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2JyaWRnZS9zZW5kZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vLi4vdXRpbHMnXG5pbXBvcnQgeyBDb21wb25lbnRNYW5hZ2VyIH0gZnJvbSAnLi4vLi4vZG9tJ1xuaW1wb3J0ICogYXMgb3BlcmF0ZSBmcm9tICcuL29wZXJhdGUnXG5pbXBvcnQgKiBhcyBwb3NpdGlvbiBmcm9tICcuL3Bvc2l0aW9uJ1xuaW1wb3J0IGZsZXhib3ggZnJvbSAnLi9mbGV4Ym94J1xuaW1wb3J0IHsgbWFrZUltYWdlTGF6eSwgZmlyZUxhenlsb2FkIH0gZnJvbSAnLi9sYXp5bG9hZCdcblxuZnVuY3Rpb24gaGFzSW50ZXJzZWN0aW9uIChyZWN0LCBjdFJlY3QpIHtcbiAgcmV0dXJuIChyZWN0LmxlZnQgPCBjdFJlY3QucmlnaHQgJiYgcmVjdC5yaWdodCA+IGN0UmVjdC5sZWZ0KVxuICAgICYmIChyZWN0LnRvcCA8IGN0UmVjdC5ib3R0b20gJiYgcmVjdC5ib3R0b20gPiBjdFJlY3QudG9wKVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb21wb25lbnQgKGRhdGEsIG5vZGVUeXBlKSB7XG4gIHRoaXMuZGF0YSA9IGRhdGFcbiAgdGhpcy5ub2RlID0gdGhpcy5jcmVhdGUobm9kZVR5cGUpXG4gIHRoaXMuY3JlYXRlQ2hpbGRyZW4oKVxuICB0aGlzLnVwZGF0ZUF0dHJzKHRoaXMuZGF0YS5hdHRyIHx8IHt9KVxuICAvLyBpc3N1ZTogd2hlbiBhZGQgZWxlbWVudCB0byBhIGxpc3QgaW4gbGlmZXRpbWUgaG9vayAncmVhZHknLCB0aGVcbiAgLy8gc3R5bGVzIGlzIHNldCB0byB0aGUgY2xhc3NTdHlsZSwgbm90IHN0eWxlLiBUaGlzIGlzIGEgaXNzdWVcbiAgLy8gdGhhdCBqc2ZyYW1ld29yayBzaG91bGQgZG8gc29tZXRoaW5nIGFib3V0LlxuICBjb25zdCBjbGFzc1N0eWxlID0gdGhpcy5kYXRhLmNsYXNzU3R5bGVcbiAgY2xhc3NTdHlsZSAmJiB0aGlzLnVwZGF0ZVN0eWxlKHRoaXMuZGF0YS5jbGFzc1N0eWxlKVxuICB0aGlzLnVwZGF0ZVN0eWxlKHRoaXMuZGF0YS5zdHlsZSB8fCB7fSlcbiAgdGhpcy5iaW5kRXZlbnRzKHRoaXMuZGF0YS5ldmVudCB8fCBbXSlcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZSA9IHtcblxuICBnZXRDb21wb25lbnRNYW5hZ2VyICgpIHtcbiAgICByZXR1cm4gQ29tcG9uZW50TWFuYWdlci5nZXRJbnN0YW5jZSh0aGlzLmRhdGEuaW5zdGFuY2VJZClcbiAgfSxcblxuICBnZXRXZWV4SW5zdGFuY2UgKCkge1xuICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKS5nZXRXZWV4SW5zdGFuY2UoKVxuICB9LFxuXG4gIGdldFBhcmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpLmNvbXBvbmVudE1hcFt0aGlzLnBhcmVudFJlZl1cbiAgfSxcblxuICBnZXRQYXJlbnRTY3JvbGxlciAoKSB7XG4gICAgaWYgKHRoaXMuaXNJblNjcm9sbGFibGUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudFNjcm9sbGVyXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH0sXG5cbiAgZ2V0Um9vdFNjcm9sbGVyICgpIHtcbiAgICBpZiAodGhpcy5pc0luU2Nyb2xsYWJsZSgpKSB7XG4gICAgICBsZXQgc2Nyb2xsZXIgPSB0aGlzLl9wYXJlbnRTY3JvbGxlclxuICAgICAgbGV0IHBhcmVudCA9IHNjcm9sbGVyLl9wYXJlbnRTY3JvbGxlclxuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBzY3JvbGxlciA9IHBhcmVudFxuICAgICAgICBwYXJlbnQgPSBzY3JvbGxlci5fcGFyZW50U2Nyb2xsZXJcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY3JvbGxlclxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9LFxuXG4gIGdldFJvb3RDb250YWluZXIgKCkge1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLmdldFdlZXhJbnN0YW5jZSgpLmdldFJvb3QoKVxuICAgICAgfHwgZG9jdW1lbnQuYm9keVxuICAgIHJldHVybiByb290XG4gIH0sXG5cbiAgaXNTY3JvbGxhYmxlICgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5kYXRhLnR5cGVcbiAgICByZXR1cm4gQ29tcG9uZW50TWFuYWdlci5nZXRTY3JvbGxhYmxlVHlwZXMoKS5pbmRleE9mKHQpICE9PSAtMVxuICB9LFxuXG4gIGlzSW5TY3JvbGxhYmxlICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2lzSW5TY3JvbGxhYmxlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc0luU2Nyb2xsYWJsZVxuICAgIH1cbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpXG4gICAgaWYgKHBhcmVudFxuICAgICAgICAmJiAodHlwZW9mIHBhcmVudC5faXNJblNjcm9sbGFibGUgIT09ICdib29sZWFuJylcbiAgICAgICAgJiYgIXBhcmVudC5pc1Njcm9sbGFibGUoKSkge1xuICAgICAgaWYgKHBhcmVudC5kYXRhLnJlZiA9PT0gJ19yb290Jykge1xuICAgICAgICB0aGlzLl9pc0luU2Nyb2xsYWJsZSA9IGZhbHNlXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgdGhpcy5faXNJblNjcm9sbGFibGUgPSBwYXJlbnQuaXNJblNjcm9sbGFibGUoKVxuICAgICAgdGhpcy5fcGFyZW50U2Nyb2xsZXIgPSBwYXJlbnQuX3BhcmVudFNjcm9sbGVyXG4gICAgICByZXR1cm4gdGhpcy5faXNJblNjcm9sbGFibGVcbiAgICB9XG4gICAgaWYgKHBhcmVudCAmJiB0eXBlb2YgcGFyZW50Ll9pc0luU2Nyb2xsYWJsZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzLl9pc0luU2Nyb2xsYWJsZSA9IHBhcmVudC5faXNJblNjcm9sbGFibGVcbiAgICAgIHRoaXMuX3BhcmVudFNjcm9sbGVyID0gcGFyZW50Ll9wYXJlbnRTY3JvbGxlclxuICAgICAgcmV0dXJuIHRoaXMuX2lzSW5TY3JvbGxhYmxlXG4gICAgfVxuICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LmlzU2Nyb2xsYWJsZSgpKSB7XG4gICAgICB0aGlzLl9pc0luU2Nyb2xsYWJsZSA9IHRydWVcbiAgICAgIHRoaXMuX3BhcmVudFNjcm9sbGVyID0gcGFyZW50XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgY29uc29sZSAmJiBjb25zb2xlLndhcm4oJ1toNS1yZW5kZXJdIGlzSW5TY3JvbGxhYmxlIC0gcGFyZW50IG5vdCBleGlzdC4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9LFxuXG4gIC8vIGRpc3BhdGNoIGEgc3BlY2lmaWVkIGV2ZW50IG9uIHRoaXMubm9kZVxuICAvLyAgLSB0eXBlOiBldmVudCB0eXBlXG4gIC8vICAtIGRhdGE6IGV2ZW50IGRhdGFcbiAgLy8gIC0gY29uZmlnOiBldmVudCBjb25maWcgb2JqZWN0XG4gIC8vICAgICAtIGJ1YmJsZXNcbiAgLy8gICAgIC0gY2FuY2VsYWJsZVxuICBkaXNwYXRjaEV2ZW50ICh0eXBlLCBkYXRhLCBjb25maWcpIHtcbiAgICBjb25zdCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJylcbiAgICBjb25maWcgPSBjb25maWcgfHwge31cbiAgICBldmVudC5pbml0RXZlbnQodHlwZSwgY29uZmlnLmJ1YmJsZXMgfHwgZmFsc2UsIGNvbmZpZy5jYW5jZWxhYmxlIHx8IGZhbHNlKVxuICAgICFkYXRhICYmIChkYXRhID0ge30pXG4gICAgZXZlbnQuZGF0YSA9IGV4dGVuZCh7fSwgZGF0YSlcbiAgICBleHRlbmQoZXZlbnQsIGRhdGEpXG4gICAgdGhpcy5ub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gIH0sXG5cbiAgb25BcHBlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRTY3JvbGxlcigpXG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQubm9kZVxuICAgICAgOiB0aGlzLmdldFJvb3RDb250YWluZXIoKVxuICAgIGNvbnN0IGN0UmVjdCA9IHBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBpZiAoaGFzSW50ZXJzZWN0aW9uKHJlY3QsIGN0UmVjdCkpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnYXBwZWFyJywgeyBkaXJlY3Rpb246ICcnIH0pXG4gICAgfVxuICB9LFxuXG4gIGFkZEFwcGVuZEhhbmRsZXIgKGNiKSB7XG4gICAgbGV0IHByZVxuICAgIGlmICh0aGlzLm9uQXBwZW5kKSB7XG4gICAgICBwcmUgPSB0aGlzLm9uQXBwZW5kLmJpbmQodGhpcylcbiAgICB9XG4gICAgdGhpcy5vbkFwcGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByZSAmJiBwcmUuY2FsbCh0aGlzKVxuICAgICAgY2IgJiYgY2IuY2FsbCh0aGlzKVxuICAgIH0uYmluZCh0aGlzKVxuICB9LFxuXG4gIC8vIGNoYW5nZSBzcmMgdG8gaW1nLXNyYyBmb3IgbGliLmltZyB0byBmaXJlIGxhenlsb2FkIGxhdGVyLlxuICBlbmFibGVMYXp5bG9hZCAoc3JjKSB7XG4gICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgbWFrZUltYWdlTGF6eSh0aGlzLm5vZGUsIHNyYylcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSB0aGlzLm5vZGUgZG9lcyBub3QgZXhpc3QuJylcbiAgICB9XG4gIH0sXG5cbiAgLy8gZWxlbWVudCBjYW4gYmUgYm90aCB3ZWV4IGNvbXBvbmVudCBhbmQgZG9tIGVsZW1lbnQuXG4gIGZpcmVMYXp5bG9hZCAoZWxlbWVudCkge1xuICAgICFlbGVtZW50ICYmIChlbGVtZW50ID0gdGhpcylcbiAgICBmaXJlTGF6eWxvYWQoZWxlbWVudClcbiAgfSxcblxuICBhdHRyOiB7fSwgLy8gYXR0ciBzZXR0ZXJzXG5cbiAgc3R5bGU6IHt9LCAvLyBzdHlsZSBzZXR0ZXJzXG5cbiAgLy8gZXZlbnQgZnVuY3NcbiAgLy8gIC0gMS4gJ3VwZGF0b3InIGZvciB1cGRhdGluZyBhdHRycyBvciBzdHlsZXMgd2l0aCBvdXQgdHJpZ2dlcmluZyBtZXNzYWdlcy5cbiAgLy8gIC0gMi4gJ2V4dHJhJyBmb3IgYmluZGluZyBleHRyYSBkYXRhLlxuICAvLyAgLSAzLiAnc2V0dGVyJyBzZXQgYSBzcGVjaWZpZWQgZXZlbnQgaGFuZGxlci5cbiAgLy8gZnVuY3Mgc2hvdWxkIGJlIGZ1bmN0aW9ucyBsaWtlIHRoaXM6ICh0YWtlICdjaGFuZ2UnIGV2ZW50IGFzIGEgZXhhbXBsZSlcbiAgLy8ge1xuICAvLyAgIGNoYW5nZToge1xuICAvLyAgICAgdXBkYXRvciAoKSB7XG4gIC8vICAgICAgIHJldHVybiB7XG4gIC8vICAgICAgICAgYXR0cnM6IHtcbiAgLy8gICAgICAgICAgIGNoZWNrZWQ6IHRoaXMuY2hlY2tlZFxuICAvLyAgICAgICAgIH1cbiAgLy8gICAgICAgfVxuICAvLyAgICAgfSxcbiAgLy8gICAgIGV4dHJhICgpIHtcbiAgLy8gICAgICAgcmV0dXJuIHtcbiAgLy8gICAgICAgICB2YWx1ZTogdGhpcy5jaGVja2VkXG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vIH1cbiAgZXZlbnQ6IHt9LFxuXG4gIGNsZWFyQXR0ciAoKSB7XG4gIH0sXG5cbiAgY2xlYXJTdHlsZSAoKSB7XG4gICAgdGhpcy5ub2RlLmNzc1RleHQgPSAnJ1xuICB9XG59XG5cbi8vIGV4dGVuZCBvcGVyYXRpb25zLlxuZXh0ZW5kKENvbXBvbmVudC5wcm90b3R5cGUsIG9wZXJhdGUpXG5cbi8vIGV4dGVuZCBhdHRyIGFuZCBzdHlsZSBzZXR0ZXJzIGZyb20gJ3Bvc2l0aW9uJyBhbmQgJ2ZsZXhib3gnLlxuZXh0ZW5kKENvbXBvbmVudC5wcm90b3R5cGUsIHBvc2l0aW9uKVxuZXh0ZW5kKENvbXBvbmVudC5wcm90b3R5cGUuc3R5bGUsIGZsZXhib3guc3R5bGUpXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvYmFzZS9jb21wb25lbnQvaW5kZXguanNcbiAqKi8iLCIvKipcbiAqIEBmaWxlT3ZlcnZpZXdcbiAqIEEgc2ltcGxlIHZpcnR1YWwgZG9tIGltcGxlbWVudGF0aW9uXG4gKi9cbmltcG9ydCBDb21wb25lbnRNYW5hZ2VyIGZyb20gJy4vY29tcG9uZW50TWFuYWdlcidcblxuZXhwb3J0IHsgQ29tcG9uZW50TWFuYWdlciB9XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZG9tL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uLy4uL3V0aWxzJ1xuaW1wb3J0IHsgZ2V0RmlsdGVycyB9IGZyb20gJy4vdmFsdWVGaWx0ZXInXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUgKG5vZGVUeXBlKSB7XG4gIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVUeXBlIHx8ICdkaXYnKVxuICByZXR1cm4gbm9kZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKCkge1xuICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICBjb25zdCBwYXJlbnRSZWYgPSB0aGlzLmRhdGEucmVmXG4gIGNvbnN0IGNvbXBvbmVudE1hbmFnZXIgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKVxuICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcbiAgICBsZXQgaXNGbGV4ID0gZmFsc2VcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZHJlbltpXS5pbnN0YW5jZUlkID0gdGhpcy5kYXRhLmluc3RhbmNlSWRcbiAgICAgIGNoaWxkcmVuW2ldLnNjYWxlID0gdGhpcy5kYXRhLnNjYWxlXG4gICAgICBjb25zdCBjaGlsZCA9IGNvbXBvbmVudE1hbmFnZXIuY3JlYXRlRWxlbWVudChjaGlsZHJlbltpXSlcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkLm5vZGUpXG4gICAgICBjaGlsZC5wYXJlbnRSZWYgPSBwYXJlbnRSZWZcbiAgICAgIGlmICghaXNGbGV4XG4gICAgICAgICYmIGNoaWxkLmRhdGEuc3R5bGVcbiAgICAgICAgJiYgY2hpbGQuZGF0YS5zdHlsZS5oYXNPd25Qcm9wZXJ0eSgnZmxleCcpXG4gICAgICApIHtcbiAgICAgICAgaXNGbGV4ID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZENoaWxkIChkYXRhKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5kYXRhLmNoaWxkcmVuXG4gIGNvbnN0IGNvbXBvbmVudE1hbmFnZXIgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKVxuICBjb25zdCBjaGlsZCA9IGNvbXBvbmVudE1hbmFnZXIuY3JlYXRlRWxlbWVudChkYXRhKVxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQubm9kZSlcbiAgLy8gdXBkYXRlIHRoaXMuZGF0YS5jaGlsZHJlblxuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB0aGlzLmRhdGEuY2hpbGRyZW4gPSBbZGF0YV1cbiAgfVxuICBlbHNlIHtcbiAgICBjaGlsZHJlbi5wdXNoKGRhdGEpXG4gIH1cbiAgcmV0dXJuIGNoaWxkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRCZWZvcmUgKGNoaWxkLCBiZWZvcmUpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgbGV0IGkgPSAwXG4gIGxldCBsXG4gIGxldCBpc0FwcGVuZCA9IGZhbHNlXG5cbiAgLy8gdXBkYXRlIHRoaXMuZGF0YS5jaGlsZHJlblxuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgIWJlZm9yZSkge1xuICAgIGlzQXBwZW5kID0gdHJ1ZVxuICB9XG4gIGVsc2Uge1xuICAgIGZvciAobCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGNoaWxkcmVuW2ldLnJlZiA9PT0gYmVmb3JlLmRhdGEucmVmKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSBsKSB7XG4gICAgICBpc0FwcGVuZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBpZiAoaXNBcHBlbmQpIHtcbiAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQubm9kZSlcbiAgICBjaGlsZHJlbi5wdXNoKGNoaWxkLmRhdGEpXG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKGJlZm9yZS5maXhlZFBsYWNlaG9sZGVyKSB7XG4gICAgICB0aGlzLm5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLm5vZGUsIGJlZm9yZS5maXhlZFBsYWNlaG9sZGVyKVxuICAgIH1cbiAgICBlbHNlIGlmIChiZWZvcmUuc3RpY2t5UGxhY2Vob2xkZXIpIHtcbiAgICAgIHRoaXMubm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQubm9kZSwgYmVmb3JlLnN0aWNreVBsYWNlaG9sZGVyKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMubm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQubm9kZSwgYmVmb3JlLm5vZGUpXG4gICAgfVxuICAgIGNoaWxkcmVuLnNwbGljZShpLCAwLCBjaGlsZC5kYXRhKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDaGlsZCAoY2hpbGQpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgLy8gcmVtb3ZlIGZyb20gdGhpcy5kYXRhLmNoaWxkcmVuXG4gIGxldCBpID0gMFxuICBjb25zdCBjb21wb25lbnRNYW5hZ2VyID0gdGhpcy5nZXRDb21wb25lbnRNYW5hZ2VyKClcbiAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGxldCBsXG4gICAgZm9yIChsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0ucmVmID09PSBjaGlsZC5kYXRhLnJlZikge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA8IGwpIHtcbiAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAxKVxuICAgIH1cbiAgfVxuICAvLyByZW1vdmUgZnJvbSBjb21wb25lbnRNYXAgcmVjdXJzaXZlbHlcbiAgY29tcG9uZW50TWFuYWdlci5yZW1vdmVDb21wb25lbnQoY2hpbGQuZGF0YS5yZWYpXG4gIGNoaWxkLnVuc2V0UG9zaXRpb24oKVxuICBjaGlsZC5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQubm9kZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChhdHRycykge1xuICAvLyBOb3Rl77yaYXR0ciBtdXN0IGJlIGluamVjdGVkIGludG8gdGhlIGRvbSBlbGVtZW50IGJlY2F1c2VcbiAgLy8gaXQgd2lsbCBiZSBhY2Nlc3NlZCBmcm9tIHRoZSBvdXRzaWRlIGRldmVsb3BlciBieSBldmVudC50YXJnZXQuYXR0ci5cbiAgaWYgKCF0aGlzLm5vZGUuYXR0cikge1xuICAgIHRoaXMubm9kZS5hdHRyID0ge31cbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgIGNvbnN0IHZhbHVlID0gYXR0cnNba2V5XVxuICAgIGNvbnN0IGF0dHJTZXR0ZXIgPSB0aGlzLmF0dHJba2V5XVxuICAgIGlmICh0eXBlb2YgYXR0clNldHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXR0clNldHRlci5jYWxsKHRoaXMsIHZhbHVlKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLm5vZGVba2V5XSA9IHZhbHVlXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuICAgICAgfVxuICAgICAgdGhpcy5ub2RlLmF0dHJba2V5XSA9IHZhbHVlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVTdHlsZSAoc3R5bGUpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGUpIHtcbiAgICBsZXQgdmFsdWUgPSBzdHlsZVtrZXldXG4gICAgY29uc3Qgc3R5bGVTZXR0ZXIgPSB0aGlzLnN0eWxlW2tleV1cbiAgICBpZiAodHlwZW9mIHN0eWxlU2V0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdHlsZVNldHRlci5jYWxsKHRoaXMsIHZhbHVlKVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgY29uc3QgcGFyc2VyID0gZ2V0RmlsdGVycyhrZXksXG4gICAgICB7IHNjYWxlOiB0aGlzLmRhdGEuc2NhbGUgfSlbdHlwZW9mIHZhbHVlXVxuICAgIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlcih2YWx1ZSlcbiAgICB9XG4gICAgdGhpcy5ub2RlLnN0eWxlW2tleV0gPSB2YWx1ZVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiaW5kRXZlbnRzIChldnRzKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGNvbnN0IHdlZXhJbnN0YW5jZSA9IHRoaXMuZ2V0V2VleEluc3RhbmNlKClcbiAgZXZ0cy5tYXAoZnVuY3Rpb24gKGV2dCkge1xuICAgIGNvbnN0IGZ1bmMgPSBzZWxmLmV2ZW50W2V2dF0gfHwge31cbiAgICBjb25zdCBzZXR0ZXIgPSBmdW5jLnNldHRlclxuICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgIHNlbGYubm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dCwgc2V0dGVyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHNlbmRlciA9IHdlZXhJbnN0YW5jZS5zZW5kZXJcbiAgICBjb25zdCBsaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAvLyBkbyBzdG9wIGJ1YmJsaW5nLlxuICAgICAgLy8gZG8gbm90IHByZXZlbnQgZGVmYXVsdCwgb3RoZXJ3aXNlIHRoZSB0b3VjaHN0YXJ0XG4gICAgICAvLyBldmVudCB3aWxsIG5vIGxvbmdlciB0cmlnZ2VyIGEgY2xpY2sgZXZlbnRcbiAgICAgIGlmIChlLl9hbHJlYWR5VHJpZ2dlcmVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZS5fYWxyZWFkeVRyaWdnZXJlZCA9IHRydWVcbiAgICAgIGNvbnN0IGV2ZW50ID0gZXh0ZW5kKHt9LCBlKVxuICAgICAgZXZlbnQudGFyZ2V0ID0gc2VsZi5kYXRhXG4gICAgICBzZW5kZXIuZmlyZUV2ZW50KHNlbGYuZGF0YS5yZWYsIGV2dCwge1xuICAgICAgICBleHRyYTogZnVuYy5leHRyYSAmJiBmdW5jLmV4dHJhLmJpbmQoc2VsZiksXG4gICAgICAgIHVwZGF0b3I6IGZ1bmMudXBkYXRvciAmJiBmdW5jLnVwZGF0b3IuYmluZChzZWxmKVxuICAgICAgfSwgZXZlbnQpXG4gICAgfVxuICAgIHNlbGYubm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dCwgbGlzdGVuZXIsIGZhbHNlLCBmYWxzZSlcbiAgICBsZXQgbGlzdGVuZXJzID0gc2VsZi5fbGlzdGVuZXJzXG4gICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVycyA9IHNlbGYuX2xpc3RlbmVycyA9IHt9XG4gICAgICBzZWxmLm5vZGUuX2xpc3RlbmVycyA9IHt9XG4gICAgfVxuICAgIGxpc3RlbmVyc1tldnRdID0gbGlzdGVuZXJcbiAgICBzZWxmLm5vZGUuX2xpc3RlbmVyc1tldnRdID0gbGlzdGVuZXJcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuYmluZEV2ZW50cyAoZXZ0cykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBldnRzLm1hcChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgY29uc3QgbGlzdGVuZXIgPSB0aGlzLl9saXN0ZW5lcnNcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIHNlbGYubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgbGlzdGVuZXIpXG4gICAgICBzZWxmLl9saXN0ZW5lcnNbZXZ0XSA9IG51bGxcbiAgICAgIHNlbGYubm9kZS5fbGlzdGVuZXJzW2V2dF0gPSBudWxsXG4gICAgfVxuICB9KVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2Jhc2UvY29tcG9uZW50L29wZXJhdGUuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuY29uc3QgTk9UX1BYX05VTUJFUl9QUk9QRVJUSUVTID0gWydmbGV4JywgJ29wYWNpdHknLCAnekluZGV4JywgJ2ZvbnRXZWlnaHQnXVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyU3R5bGVzIChzdHlsZXMsIGNvbmZpZykge1xuICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1trZXldXG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5nZXRGaWx0ZXJzKGtleSwgY29uZmlnKVt0eXBlb2YgdmFsdWVdXG4gICAgaWYgKHR5cGVvZiBwYXJzZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0eWxlc1trZXldID0gcGFyc2VyKHZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsdGVycyAoa2V5LCBjb25maWcpIHtcbiAgaWYgKE5PVF9QWF9OVU1CRVJfUFJPUEVSVElFUy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBudW1iZXI6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgKiBjb25maWcuc2NhbGUgKyAncHgnXG4gICAgfSxcbiAgICBzdHJpbmc6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIC8vIHN0cmluZyBvZiBhIHB1cmUgbnVtYmVyIG9yIGEgbnVtYmVyIHN1ZmZpeGVkIHdpdGggYSAncHgnIHVuaXRcbiAgICAgIGlmICh2YWwubWF0Y2goL15cXC0/XFxkKlxcLj9cXGQrKD86cHgpPyQvKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWwpICogY29uZmlnLnNjYWxlICsgJ3B4J1xuICAgICAgfVxuICAgICAgaWYgKGtleS5tYXRjaCgvdHJhbnNmb3JtLykgJiYgdmFsLm1hdGNoKC90cmFuc2xhdGUvKSkge1xuICAgICAgICByZXR1cm4gdmFsLnJlcGxhY2UoL1xcZCpcXC4/XFxkK3B4L2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZUludChwYXJzZUZsb2F0KG1hdGNoKSAqIGNvbmZpZy5zY2FsZSkgKyAncHgnXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvYmFzZS9jb21wb25lbnQvdmFsdWVGaWx0ZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IFN0aWNreSBmcm9tICcuL3N0aWNreSdcblxuLy8gU2V0IHBvc2l0b24gdG8gZml4ZWQsIHdpdGggYSBwbGFjZWhvbGRlciBpZiBpdCdzIGluIGFcbi8vIHNjcm9sbGFibGUgY29tcG9uZW50LlxuZXhwb3J0IGZ1bmN0aW9uIHNldEZpeGVkICgpIHtcbiAgLy8gZGVsYXkgcHJvY2Vzc2luZyBpbiBjYXNlIHRoZSBub2RlIGlzIG5vdCBhcHBlbmRlZCB5ZXQuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCdcbiAgICBpZiAoIXRoaXMuaXNJblNjcm9sbGFibGUoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMubm9kZS5wYXJlbnROb2RlXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgLy8gRm9yIHRoZSBlbGVtZW50cyB3aG8gYXJlIGZpeGVkOiB0aGlzIGZpeGVkUGxhY2Vob2xkZXJcbiAgICAgIC8vIHNob3VkIGJlIGluc2VydGVkLCBhbmQgdGhlIGZpeGVkIGVsZW1lbnQgaXRzZWxmIHNob3VsZFxuICAgICAgLy8gYmUgbW92ZWQgdG8gdGhlIHJvb3QgY29udGFpbmVyLlxuICAgICAgdGhpcy5maXhlZFBsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIHRoaXMuZml4ZWRQbGFjZWhvbGRlci5jbGFzc0xpc3QuYWRkKCd3ZWV4LWZpeGVkLXBsYWNlaG9sZGVyJylcbiAgICAgIHRoaXMuZml4ZWRQbGFjZWhvbGRlci5zdHlsZS5jc3NUZXh0ID0gW1xuICAgICAgICAnZGlzcGxheTpub25lOycsXG4gICAgICAgICd3aWR0aDowcHg7JyxcbiAgICAgICAgJ2hlaWdodDowcHg7J1xuICAgICAgXS5qb2luKCcnKVxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLmZpeGVkUGxhY2Vob2xkZXIsIHRoaXMubm9kZSlcbiAgICAgIHRoaXMuZ2V0Um9vdENvbnRhaW5lcigpLmFwcGVuZENoaWxkKHRoaXMubm9kZSlcbiAgICB9XG4gIH0uYmluZCh0aGlzKSwgMClcbn1cblxuLy8gdW5zZXQgYSBmaXhlZCBub2RlIHRvIHRoZSBwZWNpZmllZCAncG9zaXRpb24nIG9yICdyZWxhdGl2ZScgYnkgZGVmYXVsdC5cbmV4cG9ydCBmdW5jdGlvbiB1bnNldEZpeGVkIChwb3NpdGlvbikge1xuICAvLyBGb3IgdGhlIGVsZW1lbnRzIHdobyBhcmUgZml4ZWQgZWxlbWVudHMgYmVmb3JlLCBub3dcbiAgLy8gYXJlIG5vdCBmaXhlZDogdGhlIGZpeGVkUGxhY2Vob2xkZXIgaGFzIHRvIGJlIHJlcGxhY2VkXG4gIC8vIGJ5IHRoaXMgZWxlbWVudC5cbiAgcG9zaXRpb24gPSBwb3NpdGlvbiA/IHBvc2l0aW9uICsgJycgOiAncmVsYXRpdmUnXG4gIGlmICh0aGlzLmZpeGVkUGxhY2Vob2xkZXIpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmZpeGVkUGxhY2Vob2xkZXIucGFyZW50Tm9kZVxuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcy5ub2RlLCB0aGlzLmZpeGVkUGxhY2Vob2xkZXIpXG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuZml4ZWRQbGFjZWhvbGRlcilcbiAgICB0aGlzLmZpeGVkUGxhY2Vob2xkZXIgPSBudWxsXG4gICAgdGhpcy5ub2RlLnN0eWxlLnBvc2l0aW9uID0gcG9zaXRpb25cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0U3RpY2t5ICgpIHtcbiAgdGhpcy5ub2RlLnN0eWxlLnpJbmRleCA9IDEwMFxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN0aWNreSA9IG5ldyBTdGlja3kodGhpcylcbiAgfS5iaW5kKHRoaXMpLCAwKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5zZXRTdGlja3kgKCkge1xuICBpZiAodGhpcy5zdGlja3kpIHtcbiAgICB0aGlzLnN0aWNreS5kZXN0cm95KClcbiAgICB0aGlzLnN0aWNreSA9IG51bGxcbiAgfVxufVxuXG4vLyB1c2FsbHkgdXNlZCB0byB1bnNldCBzdGlja3kgYW5kIGZpeGVkXG5leHBvcnQgZnVuY3Rpb24gdW5zZXRQb3NpdGlvbiAocG9zaXRpb24pIHtcbiAgdGhpcy5zdHlsZS5wb3NpdGlvbi5jYWxsKHRoaXMsIHBvc2l0aW9uKVxufVxuXG5leHBvcnQgY29uc3Qgc3R5bGUgPSB7XG4gIHBvc2l0aW9uICh2YWx1ZSkge1xuICAgIC8vIFRoaXMgaXMgYSBwZWFjZSBvZiBoYWNraW5nIHRvIGZpeCB0aGUgcHJvYmxlbSBhYm91dFxuICAgIC8vIG1peGluZyBmaXhlZCBhbmQgdHJhbnNmb3JtLiBTZWUgJ2h0dHA6Ly9zdGFja292ZXJmbG9cbiAgICAvLyB3LmNvbS9xdWVzdGlvbnMvMTUxOTQzMTMvd2Via2l0LWNzcy10cmFuc2Zvcm0zZC1wb3NpXG4gICAgLy8gdGlvbi1maXhlZC1pc3N1ZScgZm9yIG1vcmUgaW5mby5cbiAgICB2YWx1ZSAhPT0gJ2ZpeGVkJyAmJiB0aGlzLnVuc2V0Rml4ZWQoKVxuICAgIHZhbHVlICE9PSAnc3RpY2t5JyAmJiB0aGlzLnVuc2V0U3RpY2t5KClcbiAgICBpZiAodmFsdWUgPT09ICdmaXhlZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldEZpeGVkKClcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAnc3RpY2t5Jykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0U3RpY2t5KClcbiAgICB9XG4gICAgdGhpcy5ub2RlLnN0eWxlLnBvc2l0aW9uID0gdmFsdWVcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2Jhc2UvY29tcG9uZW50L3Bvc2l0aW9uLmpzXG4gKiovIiwiaW1wb3J0IHsgdGhyb3R0bGUsIGRldGVjdFN0aWNreSB9IGZyb20gJy4uLy4uL3V0aWxzJ1xuXG5jb25zdCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnRcbmNvbnN0IGlzRmlyZWZveCA9ICEhdWEubWF0Y2goL0ZpcmVmb3gvaSlcbmNvbnN0IGlzSUVNb2JpbGUgPSAhIXVhLm1hdGNoKC9JRU1vYmlsZS9pKVxuY29uc3QgY3NzUHJlZml4ID0gaXNGaXJlZm94ID8gJy1tb3otJyA6IGlzSUVNb2JpbGUgPyAnLW1zLScgOiAnLXdlYmtpdC0nXG5jb25zdCBzdHlsZVByZWZpeCA9IGlzRmlyZWZveCA/ICdNb3onIDogaXNJRU1vYmlsZSA/ICdtcycgOiAnd2Via2l0J1xuXG5jb25zdCBzdXBwb3J0U3RpY2t5ID0gZGV0ZWN0U3RpY2t5KClcblxuZnVuY3Rpb24gY3JlYXRlU3RpY2t5TGF5ZXIgKHN0aWNreSkge1xuICBjb25zdCBwYXJlbnQgPSBzdGlja3kucGFyZW50RWxlbWVudFxuICBsZXQgc2wgPSBwYXJlbnQuX3N0aWNreUxheWVyXG4gIGlmIChzbCkge1xuICAgIHJldHVyblxuICB9XG4gIHNsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgc2wuY2xhc3NMaXN0LmFkZCgnd2VleC1zdGlja3ktbGF5ZXInKVxuICBzbC5zdHlsZS5jc3NUZXh0ID0gW1xuICAgICdwb3NpdGlvbjpmaXhlZDsnLFxuICAgIGB0b3A6JHtwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wfXB4O2AsXG4gICAgJ2JveC1zaXppbmc6Ym9yZGVyLWJveDsnLFxuICAgICd3aWR0aDoxMDAlOydcbiAgXS5qb2luKCcnKVxuICBwYXJlbnQuX3N0aWNreUxheWVyID0gc2xcbiAgcGFyZW50LmFwcGVuZENoaWxkKHNsKVxufVxuXG5mdW5jdGlvbiBkZXN0cm95U3RpY2t5TGF5ZXIgKHN0aWNreSkge1xuICBjb25zdCBwYXJlbnQgPSBzdGlja3kucGFyZW50RWxlbWVudFxuICBjb25zdCBzbCA9IHBhcmVudC5fc3RpY2t5TGF5ZXJcbiAgaWYgKCFzbCB8fCBzbC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgc2wgJiYgcGFyZW50LnJlbW92ZUNoaWxkKHNsKVxuICBwYXJlbnQuX3N0aWNreUxheWVyID0gbnVsbFxufVxuXG5mdW5jdGlvbiBiaW5kUGFyZW50IChzdGlja3kpIHtcbiAgaWYgKCFzdGlja3kgaW5zdGFuY2VvZiBTdGlja3kpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBzY3JvbGxlciA9IHN0aWNreS5jb21wb25lbnQuZ2V0UGFyZW50U2Nyb2xsZXIoKVxuICBsZXQgcHRcbiAgaWYgKHNjcm9sbGVyKSB7XG4gICAgcHQgPSBzdGlja3kucGFyZW50ID0gc2Nyb2xsZXJcbiAgICBzdGlja3kucGFyZW50RWxlbWVudCA9IHB0Lm5vZGVcbiAgfVxuICBlbHNlIHtcbiAgICBwdCA9IHN0aWNreS5wYXJlbnQgPSBzdGlja3kuY29tcG9uZW50LmdldFJvb3RDb250YWluZXIoKVxuICAgIHN0aWNreS5wYXJlbnRFbGVtZW50ID0gcHRcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRTdGlja3kgKHN0aWNreSkge1xuICBjb25zdCBjb21wID0gc3RpY2t5LmNvbXBvbmVudFxuICBjb21wLnN0aWNreVBsYWNlaG9sZGVyID0gc3RpY2t5LmVsZW1lbnQuY2xvbmVOb2RlKHRydWUpXG4gIGNvbXAuc3RpY2t5UGxhY2Vob2xkZXIuY2xhc3NMaXN0LmFkZCgnd2VleC1zdGlja3ktcGxhY2Vob2xkZXInKVxuICBzdGlja3kuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCd3ZWV4LXN0aWNreScpXG4gIHN0aWNreS5wcmVNYXJnaW5Ub3AgPSBzdGlja3kuZWxlbWVudC5zdHlsZS5tYXJnaW5Ub3BcbiAgc3RpY2t5LmVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gc3RpY2t5LnRvcCArICdweCdcbiAgc3RpY2t5LmVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoXG4gICAgY29tcC5zdGlja3lQbGFjZWhvbGRlciwgc3RpY2t5LmVsZW1lbnQpXG4gIGNvbnN0IHB0ID0gc3RpY2t5LnBhcmVudEVsZW1lbnRcbiAgIXB0LnN0aWNreXMgJiYgKHB0LnN0aWNreXMgPSBbXSlcbiAgcHQuc3RpY2t5cy5wdXNoKHN0aWNreSlcbiAgY3JlYXRlU3RpY2t5TGF5ZXIoc3RpY2t5KVxuICBwdC5fc3RpY2t5TGF5ZXIuYXBwZW5kQ2hpbGQoc3RpY2t5LmVsZW1lbnQpXG59XG5cbi8qKlxuICogdW5zZXRTdGlja3lcbiAqIEBwYXJhbSAge1N0aWNreX0gc3RpY2t5IDogYSBzdGlja3kgaW5zdGFuY2UuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBvc2l0aW9uIDogcG9zaXRpb24gcmVwbGFjaW5nIHdpdGggKGRlZmF1bHQ6ICdyZWxhdGl2ZScpLlxuICovXG5mdW5jdGlvbiB1bnNldFN0aWNreSAoc3RpY2t5LCBwb3NpdGlvbikge1xuICBjb25zdCBjb21wID0gc3RpY2t5LmNvbXBvbmVudFxuICBjb25zdCBlbGVtZW50ID0gc3RpY2t5LmVsZW1lbnRcbiAgcG9zaXRpb24gPSBwb3NpdGlvbiA/IHBvc2l0aW9uICsgJycgOiBzdGlja3kucHJlUG9zaXRpb25cbiAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IHBvc2l0aW9uXG4gIGVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gc3RpY2t5LnByZU1hcmdpblRvcCB8fCAnJ1xuICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3dlZXgtc3RpY2t5JylcbiAgaWYgKGNvbXAuc3RpY2t5UGxhY2Vob2xkZXIpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBjb21wLnN0aWNreVBsYWNlaG9sZGVyLnBhcmVudE5vZGVcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHN0aWNreS5lbGVtZW50LCBjb21wLnN0aWNreVBsYWNlaG9sZGVyKVxuICAgIHBhcmVudC5yZW1vdmVDaGlsZChjb21wLnN0aWNreVBsYWNlaG9sZGVyKVxuICAgIGNvbXAuc3RpY2t5UGxhY2Vob2xkZXIgPSBudWxsXG4gIH1cbiAgY29uc3Qgc3RrcyA9IHN0aWNreS5wYXJlbnRFbGVtZW50LnN0aWNreXNcbiAgY29uc3QgaWR4ID0gc3Rrcy5pbmRleE9mKHN0aWNreSlcbiAgc3Rrcy5zcGxpY2UoaWR4LCAxKVxuICBkZXN0cm95U3RpY2t5TGF5ZXIoc3RpY2t5KVxufVxuXG4vKipcbiAqIEBjbGFzcyAgU3RpY2t5XG4gKiBAcGFyYW0ge0NvbXBvbmVudH0gY29tcG9uZW50OiBhIHdlZXggY29tcG9uZW50LlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY29uZmlnIG9wdGlvbnMuXG4gKiAgLSBvcHRpb25zLmNvbXBvbmVudCAob3B0aW9uYWwpIGluY2FzZSB0aGUgY29tcG9uZW50IHBhcmFtIGlzIG1pc3NpbmcsIGl0IGNhblxuICogICAgYmUgc3BlY2lmaWVkIGluIHRoaXMgb3B0aW9ucy5cbiAqICAtIG9wdGlvbnMud2l0aGluUGFyZW50PWZhbHNl77yIb3B0aW9uYWzvvIxvbmx5IGZvciBBbmRyb2lk77yJdGhlIHN0aWNreSBlZmZlY3QgaXNcbiAqICAgIGxpbWl0ZWQgd2l0aGluIHRoZSBwYXJlbnQgZWxlbWVudCBvbmx5LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTdGlja3kgKGNvbXBvbmVudCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudFxuICB0aGlzLmVsZW1lbnQgPSBjb21wb25lbnQubm9kZVxuICB0aGlzLnByZVBvc2l0aW9uID0gdGhpcy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uXG4gIHRoaXMud2l0aGluUGFyZW50ID0gb3B0aW9ucy53aXRoaW5QYXJlbnQgfHwgZmFsc2VcbiAgdGhpcy5wYXJlbnQgPSBudWxsXG4gIHRoaXMuaW5pdCgpXG59XG5cblN0aWNreS5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFN0aWNreSxcblxuICBpbml0ICgpIHtcbiAgICBjb25zdCBlbGVtZW50U3R5bGUgPSB0aGlzLmVsZW1lbnQuc3R5bGVcbiAgICBlbGVtZW50U3R5bGVbc3R5bGVQcmVmaXggKyAnVHJhbnNmb3JtJ10gPSAndHJhbnNsYXRlWigwKScgLy8gZml4IGZsaWNrZXJpbmdcbiAgICBlbGVtZW50U3R5bGVbJ3RyYW5zZm9ybSddID0gJ3RyYW5zbGF0ZVooMCknXG4gICAgYmluZFBhcmVudCh0aGlzKVxuICAgIGlmIChzdXBwb3J0U3RpY2t5KSB7XG4gICAgICBlbGVtZW50U3R5bGUucG9zaXRpb24gPSBjc3NQcmVmaXggKyAnc3RpY2t5J1xuICAgICAgZWxlbWVudFN0eWxlLnBvc2l0aW9uID0gJ3N0aWNreSdcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9zaW11bGF0ZVN0aWNreSgpXG4gICAgICB0aGlzLl9iaW5kUmVzaXplKClcbiAgICB9XG4gIH0sXG5cbiAgX2JpbmRSZXNpemUgKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgY29uc3QgaXNBbmRyb2lkID0gKC9hbmRyb2lkL2dpKS50ZXN0KG5hdmlnYXRvci5hcHBWZXJzaW9uKVxuICAgIGNvbnN0IHJlc2l6ZUV2ZW50ID0gc2VsZi5fcmVzaXplRXZlbnQgPSAnb25vcmllbnRhdGlvbmNoYW5nZScgaW4gd2luZG93XG4gICAgICA/ICdvcmllbnRhdGlvbmNoYW5nZSdcbiAgICAgIDogJ3Jlc2l6ZSdcbiAgICBjb25zdCByZXNpemVIYW5kbGVyID0gc2VsZi5fcmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnJlZnJlc2goKVxuICAgICAgfSwgaXNBbmRyb2lkID8gMjAwIDogMClcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIocmVzaXplRXZlbnQsIHJlc2l6ZUhhbmRsZXIsIGZhbHNlKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGEgaW5zdGFuY2UuXG4gICAqIElmIHdpdGhQYXJlbnQgaXMgdHJ1ZSBhbmQgdGhlIHBhcmVudCcgaGVpZ2h0IGFsdGVyZWQsIHRoaXNcbiAgICogbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQuXG4gICAqL1xuICByZWZyZXNoICgpIHtcbiAgICBpZiAoc3VwcG9ydFN0aWNreSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuX2RldGFjaCgpXG4gICAgdGhpcy5fc2ltdWxhdGVTdGlja3koKVxuICB9LFxuXG4gIF9zaW11bGF0ZVN0aWNreSAoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICBjb25zdCBpc0luU2Nyb2xsYWJsZSA9IHRoaXMuaXNJblNjcm9sbGFibGUoKVxuICAgIC8vIHRoZSBpbml0aWFsIHkgb2Zmc2V0LlxuICAgIHRoaXMub2Zmc2V0ID0gKGlzSW5TY3JvbGxhYmxlXG4gICAgICA/IHRoaXMuZ2V0UGFyZW50U2Nyb2xsZXIoKS5vZmZzZXRcbiAgICAgIDogd2luZG93LnBhZ2VZT2Zmc2V0KVxuICAgICAgfHwgMFxuICAgIGNvbnN0IHJlY3RUb3AgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgbGV0IHdyYXBwZXJUb3AgPSAwXG4gICAgaWYgKGlzSW5TY3JvbGxhYmxlKSB7XG4gICAgICB3cmFwcGVyVG9wID0gdGhpcy5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcFxuICAgIH1cbiAgICBjb25zdCB3aXRoaW5QYXJlbnQgPSB0aGlzLndpdGhpblBhcmVudFxuICAgIGNvbnN0IHRocmVzaG9sZEJhc2UgPSByZWN0VG9wIC0gd3JhcHBlclRvcCArIHRoaXMub2Zmc2V0XG4gICAgLyoqXG4gICAgICogY3VyU3RhdGU6XG4gICAgICogICAxIC0gbm9ybWFsXG4gICAgICogICAyIC0gc3RpY2t5XG4gICAgICogICAzIC0gZXhjZWVkIHBhcmVudFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jdXJTdGF0ZSA9IDFcbiAgICBjb25zdCBzY3JvbGxIYW5kbGVyID0gdGhpcy5fc2Nyb2xsSGFuZGxlciA9IHRocm90dGxlKGZ1bmN0aW9uIChlKSB7XG4gICAgICBjb25zdCBzbCA9IHNlbGYucGFyZW50RWxlbWVudC5fc3RpY2t5TGF5ZXJcbiAgICAgIGNvbnN0IGxheWVySGVpZ2h0ID0gc2wgPyBzbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgOiAwXG4gICAgICBjb25zdCBzZWxmSGVpZ2h0ID0gc2VsZi5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuICAgICAgY29uc3Qgc2VsZk9mZnNldCA9IHNlbGYuY3VyU3RhdGUgPT09IDIgPyBzZWxmSGVpZ2h0IDogMFxuICAgICAgY29uc3QgdGhyZXNob2xkVG9wID0gdGhyZXNob2xkQmFzZSAtIGxheWVySGVpZ2h0ICsgc2VsZk9mZnNldFxuICAgICAgY29uc3QgeXBvcyA9IHNlbGYuaXNJblNjcm9sbGFibGUoKSA/IGUub2Zmc2V0IDogd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgICBzZWxmLm9mZnNldCA9IHlwb3NcbiAgICAgIGlmICh5cG9zIDwgdGhyZXNob2xkVG9wKSB7XG4gICAgICAgIGlmIChzZWxmLmN1clN0YXRlICE9PSAxKSB7XG4gICAgICAgICAgdW5zZXRTdGlja3koc2VsZilcbiAgICAgICAgICBzZWxmLmN1clN0YXRlID0gMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgoIXdpdGhpblBhcmVudCAmJiB5cG9zID49IHRocmVzaG9sZFRvcCkgfHxcbiAgICAgICAgKHdpdGhpblBhcmVudCAmJiB5cG9zID49IHRocmVzaG9sZFRvcC8qICYmIHlwb3MgPCB0aHJlc2hvbGRCb3R0b20qLykpIHtcbiAgICAgICAgaWYgKHNlbGYuY3VyU3RhdGUgIT09IDIpIHtcbiAgICAgICAgICBzZXRTdGlja3koc2VsZilcbiAgICAgICAgICBzZWxmLmN1clN0YXRlID0gMlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgMTAwKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxIYW5kbGVyLCBmYWxzZSlcblxuICAgIC8vIHRha2UgZWZmZWN0IG9uY2UgaW5pdGVkIGFmdGVyIGEgZGVzdHJveW1lbnQuXG4gICAgaWYgKHRoaXMub2Zmc2V0ID49IHRocmVzaG9sZEJhc2UpIHtcbiAgICAgIGNvbnN0IGR1bW15RXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpXG4gICAgICBkdW1teUV2ZW50LmluaXRFdmVudCgnc2Nyb2xsJywgdHJ1ZSwgdHJ1ZSlcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGR1bW15RXZlbnQpXG4gICAgfVxuICB9LFxuXG4gIF9kZXRhY2ggKHBvc2l0aW9uKSB7XG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiA/IHBvc2l0aW9uICsgJycgOiAncmVsYXRpdmUnXG4gICAgaWYgKCFzdXBwb3J0U3RpY2t5KSB7XG4gICAgICBpZiAodGhpcy5jdXJTdGF0ZSA9PT0gMikge1xuICAgICAgICB1bnNldFN0aWNreSh0aGlzKVxuICAgICAgfVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX3Njcm9sbEhhbmRsZXIsIGZhbHNlKVxuICAgIH1cbiAgfSxcblxuICBpc0luU2Nyb2xsYWJsZSAoKSB7XG4gICAgaWYgKCF0aGlzLl9pc0luU2Nyb2xsYWJsZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5faXNJblNjcm9sbGFibGUgPSB0aGlzLmNvbXBvbmVudC5pc0luU2Nyb2xsYWJsZSgpXG4gICAgICB9XG4gICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIFRoZSBwYXJlbnRSZWYgaXMgbm90IGluIGNvbXBvbmVudE1hbmFnZXIncyBjb21wb25lbnRNYXAgeWV0LCBzb1xuICAgICAgICAvLyBpdCdzIGludmFsaWQgdG8gZ2V0IHRoZSBwYXJlbnQgYW5kIHRlc3QgaWYgaXQncyBzY3JvbGxhYmxlLlxuICAgICAgICAvLyBUaGlzIGlzIG1vc3QgbGlrZWx5IHRvIGhhcHBlbiBpbiB0aGUgY2FzZSB0aGF0IHRoZSBwYXJlbnRcbiAgICAgICAgLy8gY29tcG9uZW50J3MgJ2FwcGVuZCcgYXR0cmlidXRlIGlzIHNldCB0byAndHJlZScuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2lzSW5TY3JvbGxhYmxlIGlzIG5vdCB5ZXQgYXZhaWxhYmxlIHRvIGNhbGwnLCBlcnIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pc0luU2Nyb2xsYWJsZVxuICB9LFxuXG4gIGdldFBhcmVudFNjcm9sbGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnQuZ2V0UGFyZW50U2Nyb2xsZXIoKVxuICB9LFxuXG4gIGRlc3Ryb3kgKHBvc2l0aW9uKSB7XG4gICAgdGhpcy5fZGV0YWNoKHBvc2l0aW9uKVxuICAgIGNvbnN0IGVsZW1lbnRTdHlsZSA9IHRoaXMuZWxlbWVudC5zdHlsZVxuICAgIGVsZW1lbnRTdHlsZS5yZW1vdmVQcm9wZXJ0eShjc3NQcmVmaXggKyAndHJhbnNmb3JtJylcbiAgICBlbGVtZW50U3R5bGUucmVtb3ZlUHJvcGVydHkoJ3RyYW5zZm9ybScpXG4gICAgaWYgKCFzdXBwb3J0U3RpY2t5KSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl9yZXNpemVFdmVudCwgdGhpcy5fcmVzaXplSGFuZGxlciwgZmFsc2UpXG4gICAgfVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvYmFzZS9jb21wb25lbnQvc3RpY2t5LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJveEFsaWduTWFwID0ge1xuICBzdHJldGNoOiAnc3RyZXRjaCcsXG4gICdmbGV4LXN0YXJ0JzogJ3N0YXJ0JyxcbiAgJ2ZsZXgtZW5kJzogJ2VuZCcsXG4gIGNlbnRlcjogJ2NlbnRlcidcbn1cblxuY29uc3QgYm94T3JpZW50TWFwID0ge1xuICByb3c6ICdob3Jpem9udGFsJyxcbiAgY29sdW1uOiAndmVydGljYWwnXG59XG5cbmNvbnN0IGJveFBhY2tNYXAgPSB7XG4gICdmbGV4LXN0YXJ0JzogJ3N0YXJ0JyxcbiAgJ2ZsZXgtZW5kJzogJ2VuZCcsXG4gIGNlbnRlcjogJ2NlbnRlcicsXG4gICdzcGFjZS1iZXR3ZWVuJzogJ2p1c3RpZnknLFxuICAnc3BhY2UtYXJvdW5kJzogJ2p1c3RpZnknIC8vIEp1c3Qgc2FtZSBhcyBgc3BhY2UtYmV0d2VlbmBcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBzdHlsZToge1xuICAgIGZsZXggKHZhbHVlKSB7XG4gICAgICB0aGlzLm5vZGUuc3R5bGUud2Via2l0Qm94RmxleCA9IHZhbHVlXG4gICAgICB0aGlzLm5vZGUuc3R5bGUud2Via2l0RmxleCA9IHZhbHVlXG4gICAgICB0aGlzLm5vZGUuc3R5bGUuZmxleCA9IHZhbHVlXG4gICAgfSxcblxuICAgIGFsaWduSXRlbXMgKHZhbHVlKSB7XG4gICAgICB0aGlzLm5vZGUuc3R5bGUud2Via2l0Qm94QWxpZ24gPSBib3hBbGlnbk1hcFt2YWx1ZV1cbiAgICAgIHRoaXMubm9kZS5zdHlsZS53ZWJraXRBbGlnbkl0ZW1zID0gdmFsdWVcbiAgICAgIHRoaXMubm9kZS5zdHlsZS5hbGlnbkl0ZW1zID0gdmFsdWVcbiAgICB9LFxuXG4gICAgYWxpZ25TZWxmICh2YWx1ZSkge1xuICAgICAgdGhpcy5ub2RlLnN0eWxlLndlYmtpdEFsaWduU2VsZiA9IHZhbHVlXG4gICAgICB0aGlzLm5vZGUuc3R5bGUuYWxpZ25TZWxmID0gdmFsdWVcbiAgICB9LFxuXG4gICAgZmxleERpcmVjdGlvbiAodmFsdWUpIHtcbiAgICAgIHRoaXMubm9kZS5zdHlsZS53ZWJraXRCb3hPcmllbnQgPSBib3hPcmllbnRNYXBbdmFsdWVdXG4gICAgICB0aGlzLm5vZGUuc3R5bGUud2Via2l0RmxleERpcmVjdGlvbiA9IHZhbHVlXG4gICAgICB0aGlzLm5vZGUuc3R5bGUuZmxleERpcmVjdGlvbiA9IHZhbHVlXG4gICAgfSxcblxuICAgIGp1c3RpZnlDb250ZW50ICh2YWx1ZSkge1xuICAgICAgdGhpcy5ub2RlLnN0eWxlLndlYmtpdEJveFBhY2sgPSBib3hQYWNrTWFwW3ZhbHVlXVxuICAgICAgdGhpcy5ub2RlLnN0eWxlLndlYmtpdEp1c3RpZnlDb250ZW50ID0gdmFsdWVcbiAgICAgIHRoaXMubm9kZS5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IHZhbHVlXG4gICAgfVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvYmFzZS9jb21wb25lbnQvZmxleGJveC5qc1xuICoqLyIsIi8qIGdsb2JhbCBsaWIsIEhUTUxFbGVtZW50ICovXG5cbid1c2Ugc3RyaWN0J1xuXG5yZXF1aXJlKCdsYXp5aW1nJylcblxubGV0IGxhenlsb2FkVGltZXJcblxuLy8gZmlyZSBsYXp5aW1nIG9uIGltYWdlcy5cbmZ1bmN0aW9uIGZpcmUgKCkge1xuICBsaWIuaW1nLmZpcmUoKVxufVxuXG4vLyB3ZSBkb24ndCBrbm93IHdoZW4gYWxsIGltYWdlcyBhcmUgYXBwZW5kZWRcbi8vIGp1c3QgdXNlIHNldFRpbWVvdXQgdG8gZG8gZGVsYXkgbGF6eWxvYWRcbi8vXG4vLyAtLSBhY3R1YWxseSBldmVyeXRpbWUgd2UgYWRkIGEgZWxlbWVudCBvciB1cGRhdGUgc3R5bGVzLFxuLy8gdGhlIGNvbXBvbmVudCBtYW5hZ2VyIHdpbGwgY2FsbCBzdGFydElmTmVlZCB0byBmaXJlXG4vLyBsYXp5bG9hZCBvbmNlIGFnYWluIGluIHRoZSBoYW5kbGVBcHBlbmQgZnVuY3Rpb24uIHNvIHRoZXJlXG4vLyBpcyBubyB3YXkgdGhhdCBhbnkgaW1hZ2UgZWxlbWVudCBjYW4gbWlzcyBpdC4gU2VlIHNvdXJjZVxuLy8gY29kZSBpbiBjb21wb25lbnRNYW5nYWdlci5qcy5cblxuLy8gY29tcG9uZW50IGlzIG5vdCBhIGRvbSBlbGVtZW50IGJ1dCBhIHdlZXggY29tcG9uZW50LlxuZnVuY3Rpb24gc3RhcnRJZk5lZWRlZCAoY29tcG9uZW50KSB7XG4gIGlmIChjb21wb25lbnQuZGF0YS50eXBlID09PSAnaW1hZ2UnKSB7XG4gICAgaWYgKCFsYXp5bG9hZFRpbWVyKSB7XG4gICAgICBsYXp5bG9hZFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZpcmUoKVxuICAgICAgICBjbGVhclRpbWVvdXQobGF6eWxvYWRUaW1lcilcbiAgICAgICAgbGF6eWxvYWRUaW1lciA9IG51bGxcbiAgICAgIH0sIDE2KVxuICAgIH1cbiAgfVxufVxuXG4vLyBlbGVtZW50U2NvcGUgaXMgYSBkb20gZWxlbWVudC5cbmZ1bmN0aW9uIGxvYWRJZk5lZWRlZCAoZWxlbWVudFNjb3BlKSB7XG4gIGNvbnN0IG5vdFByZVByb2Nlc3NlZCA9IGVsZW1lbnRTY29wZS5xdWVyeVNlbGVjdG9yQWxsKCdbaW1nLXNyY10nKVxuICAvLyBpbWFnZSBlbGVtZW50cyB3aGljaCBoYXZlIGF0dHJpYnV0ZSAnaS1sYXp5LXNyYycgd2VyZSBlbGVtZW50c1xuICAvLyB0aGF0IGhhZCBiZWVuIHByZXByb2Nlc3NlZCBieSBsaWItaW1nLWNvcmUsIGJ1dCBub3QgbG9hZGVkIHlldCwgYW5kXG4gIC8vIG11c3QgYmUgbG9hZGVkIHdoZW4gJ2FwcGVhcicgZXZlbnRzIHdlcmUgZmlyZWQuIEl0IHR1cm5zIG91dCB0aGVcbiAgLy8gJ2FwcGVhcicgZXZlbnQgd2FzIG5vdCBmaXJlZCBjb3JyZWN0bHkgaW4gdGhlIGNzcy10cmFuc2xhdGUtdHJhbnNpdGlvblxuICAvLyBzaXR1YXRpb24sIHNvICdpLWxhenktc3JjJyBtdXN0IGJlIGNoZWNrZWQgYW5kIGxhenlsb2FkIG11c3QgYmVcbiAgLy8gZmlyZWQgbWFudWFsbHkuXG4gIGNvbnN0IHByZVByb2Nlc3NlZCA9IGVsZW1lbnRTY29wZS5xdWVyeVNlbGVjdG9yQWxsKCdbaS1sYXp5LXNyY10nKVxuICBpZiAobm90UHJlUHJvY2Vzc2VkLmxlbmd0aCA+IDAgfHwgcHJlUHJvY2Vzc2VkLmxlbmd0aCA+IDApIHtcbiAgICBmaXJlKClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUltYWdlTGF6eSAoaW1hZ2UsIHNyYykge1xuICBpbWFnZS5yZW1vdmVBdHRyaWJ1dGUoJ2ltZy1zcmMnKVxuICBpbWFnZS5yZW1vdmVBdHRyaWJ1dGUoJ2ktbGF6eS1zcmMnKVxuICBpbWFnZS5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpXG4gIGltYWdlLnNldEF0dHJpYnV0ZSgnaW1nLXNyYycsIHNyYylcbiAgZmlyZSgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXJlTGF6eWxvYWQgKGNvbXBvbmVudCkge1xuICBpZiAoY29tcG9uZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICBsb2FkSWZOZWVkZWQoY29tcG9uZW50KVxuICB9XG4gIGVsc2Uge1xuICAgIHN0YXJ0SWZOZWVkZWQoY29tcG9uZW50KVxuICB9XG59XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9iYXNlL2NvbXBvbmVudC9sYXp5bG9hZC5qc1xuICoqLyIsIi8qXG4gICAgbGliLWltZy1hZHB0ZXIgXG4gICAgQXV0aG9yOiBrb25nc2hpLndsQGFsaWJhYmEtaW5jLmNvbSBcbiAgICBEYXRlOiAgIERlYywyMDE1XG4qL1xuO1xuXG4oZnVuY3Rpb24gKHdpbiwgbGliKSB7XG4gICAgcmVxdWlyZSgnYXBwZWFyanMnKTtcblxuICAgIHZhciBhZGFwdGVyID0ge307XG4gICAgdmFyIGFwcGVhckluc3RhbmNlO1xuICAgIHZhciBydW50aW1lRmxhZ3MgPSB7fTtcblxuICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICdkYXRhU3JjJzogJ2ltZy1zcmMnLCAvL+aMh+WumuWbvueJh+WcsOWdgOeahGF0dHJpYnV0ZeWQjSwg5YW85YGabGF6eS1jbGFzc+eahOS9nOeUqFxuICAgICAgICAnbGF6eUhlaWdodCc6IDAsIC8v5Lul5q2k6auY5bqm5o+Q5YmN6Kem5Y+R5oeS5Yqg6L29XG4gICAgICAgICdsYXp5V2lkdGgnOiAwIC8v5Lul5q2k5a695bqm5o+Q5YmN6Kem5Y+R5oeS5Yqg6L29XG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kU3RyaWN0KG1haW4sIHN1Yikge1xuICAgICAgICB2YXIgcmV0ID0ge307XG4gICAgICAgIGZvciAodmFyIGsgaW4gbWFpbikge1xuICAgICAgICAgICAgaWYgKG1haW4uaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICByZXRba10gPSBzdWIuaGFzT3duUHJvcGVydHkoaykgPyBzdWJba10gOiBtYWluW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlTcmMoaXRlbSwgcHJvY2Vzc2VkU3JjKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkU3JjKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0ubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSAnSU1HJykge1xuICAgICAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHByb2Nlc3NlZFNyYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoXCInICsgcHJvY2Vzc2VkU3JjICsgJ1wiKSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICBhcHBlYXJJbnN0YW5jZSA9IGxpYi5hcHBlYXIuaW5pdCh7XG4gICAgICAgICAgICBjbHM6ICdpbWd0bXAnLCAvL+WPr+mAie+8jOmcgOimgemBjeWOhueahOWFg+e0oFxuICAgICAgICAgICAgb25jZTogdHJ1ZSwgLy/lj6/pgInvvIzmmK/lkKblj6rop6blj5HkuIDmrKFcbiAgICAgICAgICAgIHg6IGNvbmZpZy5sYXp5V2lkdGgsIC8v5Y+v6YCJ77yM5a655Zmo5Y+z6L656Led56a7eOS7peWGheeahOWFg+e0oOWKoOi9ve+8jOm7mOiupOS4ujBcbiAgICAgICAgICAgIHk6IGNvbmZpZy5sYXp5SGVpZ2h0LCAvL+WPr+mAie+8jOWuueWZqOW6lemDqOi3neemu3nku6XlhoXnmoTlhYPntKDliqDovb3vvIzpu5jorqTkuLowXG4gICAgICAgICAgICBvbkFwcGVhcjogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcztcbiAgICAgICAgICAgICAgICBhcHBseVNyYyhpdGVtLCBpdGVtLmdldEF0dHJpYnV0ZSgnaS1sYXp5LXNyYycpKTtcbiAgICAgICAgICAgICAgICBpdGVtLnJlbW92ZUF0dHJpYnV0ZSgnaS1sYXp5LXNyYycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIGFkYXB0ZXIubG9nQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmxvZygnbGliLWltZyBDb25maWdcXG4nLCBjb25maWcpO1xuICAgIH1cblxuXG4gICAgYWRhcHRlci5maXJlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIGlmICghYXBwZWFySW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGluaXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYWJlbCA9ICdpXycgKyBEYXRlLm5vdygpICUgMTAwMDAwO1xuICAgICAgICB2YXIgZG9tTGlzdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1snICsgY29uZmlnLmRhdGFTcmMgKyAnXScpO1xuXG4gICAgICAgIFtdLmZvckVhY2guY2FsbChkb21MaXN0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uZGF0YXNldC5sYXp5ID09ICdmYWxzZScgJiYgaXRlbS5kYXRhc2V0LmxhenkgIT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlTcmMoaXRlbSwgcHJvY2Vzc1NyYyhpdGVtLCBpdGVtLmdldEF0dHJpYnV0ZShjb25maWcuZGF0YVNyYykpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKGxhYmVsKTtcbiAgICAgICAgICAgICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnaS1sYXp5LXNyYycsIGl0ZW0uZ2V0QXR0cmlidXRlKGNvbmZpZy5kYXRhU3JjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLnJlbW92ZUF0dHJpYnV0ZShjb25maWcuZGF0YVNyYyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFwcGVhckluc3RhbmNlLmJpbmQoJy4nICsgbGFiZWwpO1xuICAgICAgICBhcHBlYXJJbnN0YW5jZS5maXJlKCk7XG4gICAgfVxuXG5cblxuICAgIGFkYXB0ZXIuZGVmYXVsdFNyYyA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUJDQVlBQUFBZkZjU0pBQUFBRFVsRVFWUUltV05nWUdCZ0FBQUFCUUFCaDZGTzFBQUFBQUJKUlU1RXJrSmdnZz09JztcblxuXG5cbiAgICBsaWIuaW1nID0gYWRhcHRlcjtcbiAgICBcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGFkYXB0ZXI7XG5cbn0pKHdpbmRvdywgd2luZG93WydsaWInXSB8fCAod2luZG93WydsaWInXSA9IHt9KSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9sYXp5aW1nL3NyYy9hZGFwdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI7XG4oZnVuY3Rpb24gKHdpbiwgbGliKSB7XG4gIHZhciBkb2MgPSBkb2N1bWVudDtcbiAgdmFyIGFwcGVhckV2dDtcbiAgdmFyIGRpc2FwcGVhckV2dDtcblxuICBmdW5jdGlvbiBjcmVhdGVFdmVudCgpIHtcbiAgICBhcHBlYXJFdnQgPSBkb2MuY3JlYXRlRXZlbnQoXCJIVE1MRXZlbnRzXCIpOy8v5Yib5bu66Ieq5a6a5LmJ5pi+56S65LqL5Lu2ICBcbiAgICBkaXNhcHBlYXJFdnQgPSBkb2MuY3JlYXRlRXZlbnQoXCJIVE1MRXZlbnRzXCIpOy8v5Yib5bu66Ieq5a6a5LmJ5raI5aSx5LqL5Lu2ICBcbiAgICBhcHBlYXJFdnQuaW5pdEV2ZW50KCdfYXBwZWFyJywgZmFsc2UsIHRydWUpOyAgICAgIFxuICAgIGRpc2FwcGVhckV2dC5pbml0RXZlbnQoJ19kaXNhcHBlYXInLCBmYWxzZSwgdHJ1ZSk7ICAgICAgXG4gIH1cblxuICAvKipcbiAgICogW3Rocm90dGxlIOiKgua1geWHveaVsF1cbiAgICogQHBhcmFtICB7W2Z1bmN0aW9uXX0gZnVuYyBb5omn6KGM5Ye95pWwXVxuICAgKiBAcGFyYW0gIHtbaW50XX0gd2FpdCBb562J5b6F5pe26ZW/XVxuICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCkge1xuICAgIHZhciBsYXRlc3QgPSBEYXRlLm5vdygpLFxuICAgICAgcHJldmlvdXMgPSAwLC8v5LiK5qyh5omn6KGM55qE5pe26Ze0XG4gICAgICB0aW1lb3V0ID0gbnVsbCwvL3NldFRpbW91dOS7u+WKoVxuICAgICAgY29udGV4dCwvL+S4iuS4i+aWh1xuICAgICAgYXJncywvL+WPguaVsFxuICAgICAgcmVzdWx0Oy8v57uT5p6cXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJldmlvdXMgPSBEYXRlLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7Ly/muIXnqbrorqHml7blmahcbiAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+PSB3YWl0KSB7XG4gICAgICAgIC8v5aaC5p6c5rKh5pyJ5Ymp5L2Z5pe26Ze077yM5oiW6ICF5a2Y5Zyo5L+u5pS56L+H57O757uf5pe26Ze05a+86Ie05Ymp5L2Z5pe26Ze05aKe5aSn55qE5oOF5Ya177yM5YiZ5omn6KGMXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICB9IGVsc2UgaWYgKHRpbWVvdXQgPT0gbnVsbCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFtnZXRPZmZzZXQg6I635Y+W6L656Led5bC65a+4XVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IGVsICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IHBhcmFtIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBmdW5jdGlvbiBnZXRPZmZzZXQoZWwsIHBhcmFtKSB7XG4gICAgdmFyIGVsLCBsLCAgciwgYiwgdDtcbiAgICBpZiAoIWVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcGFyYW0pIHtcbiAgICAgIHBhcmFtID0ge3g6IDAsIHk6IDB9O1xuICAgIH1cblxuICAgIGlmIChlbCAhPSB3aW5kb3cpIHtcbiAgICAgIGVsID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBsID0gZWwubGVmdDtcbiAgICAgIHQgPSBlbC50b3A7XG4gICAgICByID0gZWwucmlnaHQ7XG4gICAgICBiID0gZWwuYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gMDtcbiAgICAgIHQgPSAwO1xuICAgICAgciA9IGwgKyBlbC5pbm5lcldpZHRoO1xuICAgICAgYiA9IHQgKyBlbC5pbm5lckhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICdsZWZ0JzogbCxcbiAgICAgICd0b3AnOiB0LFxuICAgICAgJ3JpZ2h0JzogciArIHBhcmFtLngsXG4gICAgICAnYm90dG9tJzogYiArIHBhcmFtLnlcbiAgICB9O1xuICB9XG4gIC8v5YWD57Sg5L2N572u5q+U6L6DXG4gIGZ1bmN0aW9uIGNvbXBhcmVPZmZzZXQoZDEsIGQyKSB7XG4gICAgdmFyIGxlZnQgPSBkMi5yaWdodCA+IGQxLmxlZnQgJiYgZDIubGVmdCA8IGQxLnJpZ2h0O1xuICAgIHZhciB0b3AgPSBkMi5ib3R0b20gPiBkMS50b3AgJiYgZDIudG9wIDwgZDEuYm90dG9tO1xuICAgIHJldHVybiBsZWZ0ICYmIHRvcDtcbiAgfVxuICAvL+iOt+WPluenu+WKqOaWueWQkVxuICBmdW5jdGlvbiBnZXREaXJlY3Rpb24oYmVmb3JlT2Zmc2V0LCBub3dPZmZzZXQpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gJ25vbmUnO1xuICAgIHZhciBob3JpemVudGFsID0gYmVmb3JlT2Zmc2V0LmxlZnQgLSBub3dPZmZzZXQubGVmdDtcbiAgICB2YXIgdmVydGljYWwgPSBiZWZvcmVPZmZzZXQudG9wIC0gbm93T2Zmc2V0LnRvcDtcbiAgICBpZiAodmVydGljYWwgPT0gMCkge1xuICAgICAgaWYgKGhvcml6ZW50YWwgIT0gMCkge1xuICAgICAgICBkaXJlY3Rpb24gPSBob3JpemVudGFsID4gMCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXJlY3Rpb24gPSAnbm9uZSdcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhvcml6ZW50YWwgPT0gMCkge1xuICAgICAgaWYgKHZlcnRpY2FsICE9IDApIHtcbiAgICAgICAgZGlyZWN0aW9uID0gdmVydGljYWwgPiAwID8gJ3VwJyA6ICdkb3duJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcmVjdGlvbiA9ICdub25lJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIGVsKSB7XG4gICAgZm9yICh2YXIgayBpbiBlbCkge1xuICAgICAgaWYgKGVsLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgIHRhcmdldFtrXSA9IGVsW2tdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFtfX2JpbmRFdmVudCDnu5Hlrprkuovku7bvvIzljIXmi6zmu5rliqjjgIF0b3VjaG1vdmXjgIF0cmFuc2Zvcm3jgIFyZXNpemXnrYldXG4gICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBmdW5jdGlvbiBfX2JpbmRFdmVudCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGhhbmRsZSA9IHRocm90dGxlKGZ1bmN0aW9uICgpIHtcbiAgICAgIF9fZmlyZS5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH0sIHRoaXMub3B0aW9ucy53YWl0KTtcbiAgICBpZiAodGhpcy5fX2hhbmRsZSkge1xuICAgICAgLy/pgb/lhY3ph43lpI3nu5HlrppcbiAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX19oYW5kbGUpO1xuICAgICAgdGhpcy5fX2hhbmRsZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX19oYW5kbGUgPSBoYW5kbGU7XG4gICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlLCBmYWxzZSk7XG4gICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgIF9fZmlyZS5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH0sIGZhbHNlKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdhbmltYXRpb25FbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgIF9fZmlyZS5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH0sIGZhbHNlKTtcbiAgICAvLyBhbmRyb2lkNC4w5Lul5LiLXG4gICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0QW5pbWF0aW9uRW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICBfX2ZpcmUuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgX19maXJlLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG5cbiAgLy/ojrflj5blrrnlmajlhoXmiYDmnInnmoTliqDovb3lhYPntKBcbiAgZnVuY3Rpb24gX19nZXRFbGVtZW50cyhzZWxlY3Rvcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvL+iOt+WPluWuueWZqFxuICAgIHZhciBjb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgIGlmICh0eXBlb2YgY29udGFpbmVyID09ICdzdHJpbmcnKSB7XG4gICAgICAvL+WmguaenOaYr+Wtl+espuS4su+8jOWImemAieaLqeWZqFxuICAgICAgdGhpcy5jb250YWluZXIgPSBkb2MucXVlcnlTZWxlY3Rvcihjb250YWluZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL+WvueixoeS8oOWAvFxuICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIC8v6I635Y+W5a655Zmo5YaF55qE5omA5pyJ55uu5qCH5YWD57SgXG4gICAgaWYgKHRoaXMuY29udGFpbmVyID09IHdpbmRvdykge1xuICAgICAgdmFyIGFwcGVhcldhdGNoRWxlbWVudHMgPSBkb2MucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7ICAgICAgICAgICAgXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcHBlYXJXYXRjaEVsZW1lbnRzID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgfVxuICAgIHZhciBhcHBlYXJXYXRjaEVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChhcHBlYXJXYXRjaEVsZW1lbnRzLCBudWxsKTtcblxuICAgIGFwcGVhcldhdGNoRWxlbWVudHMgPSBhcHBlYXJXYXRjaEVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbihlbGUpIHtcbiAgICAgIC8vIOWmguaenOW3sue7j+e7keWumui/h++8jOa4hemZpGFwcGVhcueKtuaAge+8jOS4jeWGjeWKoOWFpeWIsOaVsOe7hOmHjFxuICAgICAgaWYgKGVsZS5kYXRhc2V0WydiaW5kJ10gPT0gJzEnKSB7XG4gICAgICAgIGRlbGV0ZSBlbGUuX2hhc0FwcGVhcjtcbiAgICAgICAgZGVsZXRlIGVsZS5faGFzRGlzQXBwZWFyO1xuICAgICAgICBkZWxldGUgZWxlLl9hcHBlYXI7ICAgICAgXG4gICAgICAgIGVsZS5jbGFzc0xpc3QucmVtb3ZlKHNlbGYub3B0aW9ucy5jbHMpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhcHBlYXJXYXRjaEVsZW1lbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gX19pbml0Qm91bmRpbmdSZWN0KGVsZW1lbnRzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChlbGVtZW50cyAmJiBlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBbXS5mb3JFYWNoLmNhbGwoZWxlbWVudHMsIGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgZWxlLl9lbGVPZmZzZXQgPSBnZXRPZmZzZXQoZWxlKTsgXG4gICAgICAgIC8v56e76Zmk57G75ZCNXG4gICAgICAgIGVsZS5jbGFzc0xpc3QucmVtb3ZlKHNlbGYub3B0aW9ucy5jbHMpO1xuICAgICAgICAvLyDmoIflv5flt7Lnu4/nu5HlrppcbiAgICAgICAgZWxlLmRhdGFzZXRbJ2JpbmQnXSA9IDE7XG4gICAgICB9KTtcbiAgICB9ICAgICAgICBcbiAgfVxuXG4gIC8vIOinpuWPkeWKoOi9vVxuICBmdW5jdGlvbiBfX2ZpcmUoKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLFxuICAgICAgZWxlbWVudHMgPSB0aGlzLmFwcGVhcldhdGNoRWxlbWVudHMsXG4gICAgICBhcHBlYXJDYWxsYmFjayA9IHRoaXMub3B0aW9ucy5vbkFwcGVhciwvL2FwcGVhcueahOaJp+ihjOWHveaVsFxuICAgICAgZGlzYXBwZWFyQ2FsbGJhY2sgPSB0aGlzLm9wdGlvbnMub25EaXNhcHBlYXIsLy9kaXNhcHBlYXLnmoTmiafooYzlh73mlbBcbiAgICAgIGNvbnRhaW5lck9mZnNldCA9IGdldE9mZnNldChjb250YWluZXIsIHtcbiAgICAgICAgeDogdGhpcy5vcHRpb25zLngsXG4gICAgICAgIHk6IHRoaXMub3B0aW9ucy55XG4gICAgICB9KSxcbiAgICAgIGlzT25jZSA9IHRoaXMub3B0aW9ucy5vbmNlLC8v5piv5ZCm5Y+q5omn6KGM5LiA5qyhXG4gICAgICBldiA9IGFyZ3VtZW50c1swXSB8fCB7fTtcbiAgICBpZiAoZWxlbWVudHMgJiYgZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgW10uZm9yRWFjaC5jYWxsKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlLCBpKSB7XG4gICAgICAgIC8v6I635Y+W5bem5Y+z6Led56a7XG4gICAgICAgIHZhciBlbGVPZmZzZXQgPSBnZXRPZmZzZXQoZWxlKTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihlbGUuX2VsZU9mZnNldCwgZWxlT2Zmc2V0KTtcbiAgICAgICAgLy/kv53lrZjkuIrkuKrml7bmrrXnmoTkvY3nva7kv6Hmga9cbiAgICAgICAgZWxlLl9lbGVPZmZzZXQgPSBlbGVPZmZzZXQ7XG4gICAgICAgIC8v5p+l55yL5piv5ZCm5Zyo5Y+v6KeG5Yy65Z+f6IyD5Zu05YaFXG4gICAgICAgIHZhciBpc0luVmlldyA9IGNvbXBhcmVPZmZzZXQoY29udGFpbmVyT2Zmc2V0LCBlbGVPZmZzZXQpO1xuICAgICAgICB2YXIgYXBwZWFyID0gZWxlLl9hcHBlYXI7XG4gICAgICAgIHZhciBfaGFzQXBwZWFyID0gZWxlLl9oYXNBcHBlYXI7XG4gICAgICAgIHZhciBfaGFzRGlzQXBwZWFyID0gZWxlLl9oYXNEaXNBcHBlYXI7XG4gICAgICAgIGFwcGVhckV2dC5kYXRhID0ge1xuICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICAgIH1cbiAgICAgICAgZGlzYXBwZWFyRXZ0LmRhdGEgPSB7XG4gICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJblZpZXcgJiYgIWFwcGVhcikge1xuICAgICAgICAgIGlmICgoaXNPbmNlICYmICFfaGFzQXBwZWFyKSB8fCAhaXNPbmNlKSB7XG4gICAgICAgICAgICAvL+WmguaenOWPquinpuWPkeS4gOasoeW5tuS4lOayoeacieinpuWPkei/h+aIluiAheWFgeiuuOinpuWPkeWkmuasoVxuICAgICAgICAgICAgLy/lpoLmnpzlnKjlj6/op4bljLrln5/lhoXvvIzlubbkuJTmmK/ku45kaXNwcGVhcui/m+WFpWFwcGVhcu+8jOWImeaJp+ihjOWbnuiwg1xuICAgICAgICAgICAgYXBwZWFyQ2FsbGJhY2sgJiYgYXBwZWFyQ2FsbGJhY2suY2FsbChlbGUsIGV2KTtcbiAgICAgICAgICAgIC8v6Kem5Y+R6Ieq5a6a5LmJ5LqL5Lu2XG4gICAgICAgICAgICBlbGUuZGlzcGF0Y2hFdmVudChhcHBlYXJFdnQpO1xuICAgICAgICAgICAgZWxlLl9oYXNBcHBlYXIgPSB0cnVlO1xuICAgICAgICAgICAgZWxlLl9hcHBlYXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNJblZpZXcgJiYgYXBwZWFyKSB7XG4gICAgICAgICAgaWYgKChpc09uY2UgJiYgIV9oYXNEaXNBcHBlYXIpIHx8ICFpc09uY2UpIHtcbiAgICAgICAgICAgIC8v5aaC5p6c5LiN5Zyo5Y+v6KeG5Yy65Z+f5YaF77yM5bm25LiU5piv5LuOYXBwZWFy6L+b5YWlZGlzYXBwZWFy77yM5omn6KGMZGlzYXBwZWFy5Zue6LCDXG4gICAgICAgICAgICBkaXNhcHBlYXJDYWxsYmFjayAmJiBkaXNhcHBlYXJDYWxsYmFjay5jYWxsKGVsZSwgZXYpO1xuICAgICAgICAgICAgLy/op6blj5Hoh6rlrprkuYnkuovku7ZcbiAgICAgICAgICAgIGVsZS5kaXNwYXRjaEV2ZW50KGRpc2FwcGVhckV2dCk7XG4gICAgICAgICAgICBlbGUuX2hhc0Rpc0FwcGVhciA9IHRydWU7XG4gICAgICAgICAgICBlbGUuX2FwcGVhciA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJvdG8gPSBleHRlbmQocHJvdG8sIGxpc3RlbmVyKTtcblxuICBmdW5jdGlvbiBfX2luaXQob3B0cykge1xuICAgIC8v5omp5bGV5Y+C5pWwXG4gICAgZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0cyB8fCAob3B0cyA9IHt9KSk7XG4gICAgLy/ojrflj5bnm67moIflhYPntKBcbiAgICB0aGlzLmFwcGVhcldhdGNoRWxlbWVudHMgPSB0aGlzLmFwcGVhcldhdGNoRWxlbWVudHMgfHwgX19nZXRFbGVtZW50cy5jYWxsKHRoaXMsICcuJyArIHRoaXMub3B0aW9ucy5jbHMpO1xuICAgIC8v5Yid5aeL5YyW5L2N572u5L+h5oGvXG4gICAgX19pbml0Qm91bmRpbmdSZWN0LmNhbGwodGhpcywgdGhpcy5hcHBlYXJXYXRjaEVsZW1lbnRzKTtcbiAgICAvL+e7keWumuS6i+S7tlxuICAgIF9fYmluZEV2ZW50LmNhbGwodGhpcyk7XG4gIH1cbiAgXG4gIHZhciBBcHBlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgX19pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuXG4gIHZhciBhcHBlYXIgPSB7XG4gICAgaW5zdGFuY2VzOiBbXSxcbiAgICBpbml0OiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgdmFyIHByb3RvID0ge1xuICAgICAgICAvL+m7mOiupOWPguaVsFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgY29udGFpbmVyOiB3aW5kb3csXG4gICAgICAgICAgd2FpdDogMTAwLFxuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICBjbHM6ICdsaWItYXBwZWFyJyxcbiAgICAgICAgICBvbmNlOiBmYWxzZSxcbiAgICAgICAgICBvblJlc2V0OiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICBvbkFwcGVhcjogZnVuY3Rpb24gKCkge30sXG4gICAgICAgICAgb25EaXNhcHBlYXI6IGZ1bmN0aW9uICgpIHt9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICAgICAgYXBwZWFyV2F0Y2hFbGVtZW50czogbnVsbCxcbiAgICAgICAgYmluZDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB2YXIgY2xzID0gdGhpcy5vcHRpb25zLmNscztcbiAgICAgICAgICAvLyDmt7vliqDpnIDopoHnu5HlrprnmoRhcHBlYXLlhYPntKBcbiAgICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IF9fZ2V0RWxlbWVudHMuY2FsbCh0aGlzLCBub2RlKTtcbiAgICAgICAgICAgIFtdLmZvckVhY2guY2FsbChlbGVtZW50cywgZnVuY3Rpb24gKGVsZSwgaSkge1xuICAgICAgICAgICAgICBpZiAoIWVsZS5jbGFzc0xpc3QuY29udGFpbnMoY2xzKSkge1xuICAgICAgICAgICAgICAgIGVsZS5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgdGhpcy5jb250YWluZXIuY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgICAgIC8v5aaC5p6c5Lyg5YWl55qE5piv5YWD57Sg5bm25LiU5Zyo5YyF5ZCr5Zyo5a655Zmo5Lit77yM55u05o6l5re75Yqg57G75ZCNXG4gICAgICAgICAgICBpZiAoIW5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKGNscykpIHtcbiAgICAgICAgICAgICAgLy/mt7vliqDnsbvlkI1cbiAgICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL+aWsOWinueahOWtkOWFg+e0oFxuICAgICAgICAgIHZhciBuZXdFbGVtZW50cyA9IF9fZ2V0RWxlbWVudHMuY2FsbCh0aGlzLCAnLicgKyB0aGlzLm9wdGlvbnMuY2xzKTtcbiAgICAgICAgICAvL+Wvuee8k+WtmOeahOWtkOWFg+e0oOWBmuWinumHj1xuICAgICAgICAgIHRoaXMuYXBwZWFyV2F0Y2hFbGVtZW50cyA9IHRoaXMuYXBwZWFyV2F0Y2hFbGVtZW50cy5jb25jYXQobmV3RWxlbWVudHMpO1xuICAgICAgICAgIC8v5Yid5aeL5YyW5paw5a2Q5YWD57Sg55qE5L2N572u5L+h5oGvXG4gICAgICAgICAgX19pbml0Qm91bmRpbmdSZWN0LmNhbGwodGhpcywgbmV3RWxlbWVudHMpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyDph43nva7lh73mlbBcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgX19pbml0LmNhbGwodGhpcywgb3B0cyk7XG4gICAgICAgICAgdGhpcy5hcHBlYXJXYXRjaEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlKSB7XG4gICAgICAgICAgICBkZWxldGUgZWxlLl9oYXNBcHBlYXI7XG4gICAgICAgICAgICBkZWxldGUgZWxlLl9oYXNEaXNBcHBlYXI7XG4gICAgICAgICAgICBkZWxldGUgZWxlLl9hcHBlYXI7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGZpcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuYXBwZWFyV2F0Y2hFbGVtZW50cykge1xuICAgICAgICAgICAgdGhpcy5hcHBlYXJXYXRjaEVsZW1lbnRzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuZXdFbGVtZW50cyA9IF9fZ2V0RWxlbWVudHMuY2FsbCh0aGlzLCAnLicgKyB0aGlzLm9wdGlvbnMuY2xzKTtcbiAgICAgICAgICB0aGlzLmFwcGVhcldhdGNoRWxlbWVudHMgPSB0aGlzLmFwcGVhcldhdGNoRWxlbWVudHMuY29uY2F0KG5ld0VsZW1lbnRzKTtcbiAgICAgICAgICAvL+WIneWni+WMluS9jee9ruS/oeaBr1xuICAgICAgICAgIF9faW5pdEJvdW5kaW5nUmVjdC5jYWxsKHRoaXMsIG5ld0VsZW1lbnRzKTtcbiAgICAgICAgICBfX2ZpcmUuY2FsbCh0aGlzKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgQXBwZWFyLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IEFwcGVhcihvcHRzKTtcbiAgICAgIHRoaXMuaW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH0sXG4gICAgZmlyZUFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGluc3RhbmNlcyA9IHRoaXMuaW5zdGFuY2VzO1xuICAgICAgaW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlLmZpcmUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvL+azqOWGjOS6i+S7tlxuICBjcmVhdGVFdmVudCgpO1xuXG4gIGxpYi5hcHBlYXIgPSBhcHBlYXI7XG5cbn0pKHdpbmRvdywgd2luZG93LmxpYiB8fCAod2luZG93LmxpYiA9IHt9KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbGF6eWltZy9+L2FwcGVhcmpzL3NyYy9hcHBlYXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vY29tcG9uZW50J1xuXG4vLyBDb21wb25lbnQgd2hpY2ggY2FuIGhhdmUgbm8gc3ViY29tcG9uZW50cy5cbi8vIFRoaXMgY29tcG9uZW50IHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LCBzaW5jZVxuLy8gaXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBhcyBhIGJhc2UgY2xhc3MgdG8gZXh0ZW5kIGZyb20uXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBdG9taWMgKGRhdGEpIHtcbiAgQ29tcG9uZW50LmNhbGwodGhpcywgZGF0YSlcbn1cblxuQXRvbWljLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tcG9uZW50LnByb3RvdHlwZSlcblxuQXRvbWljLnByb3RvdHlwZS5jcmVhdGVDaGlsZHJlbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIC8vIGRvIG5vbnRoaW5nXG4gIHJldHVyblxufVxuXG5BdG9taWMucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgLy8gZG8gbm90aGluZ1xuICByZXR1cm5cbn1cblxuQXRvbWljLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAoY2hpbGQsIGJlZm9yZSkge1xuICAvLyBkbyBub3RoaW5nXG4gIHJldHVyblxufVxuXG5BdG9taWMucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gIC8vIGRvIG5vdGhpbmdcbiAgcmV0dXJuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvYmFzZS9hdG9taWMuanNcbiAqKi8iLCJpbXBvcnQgQ29tcG9uZW50TWFuYWdlciBmcm9tICcuLi9kb20vY29tcG9uZW50TWFuYWdlcidcbmltcG9ydCB7IHJlZ2lzdGVyTG9hZGVyIH0gZnJvbSAnLi9sb2FkZXInXG5pbXBvcnQgeyBwcm90b2NvbCB9IGZyb20gJy4uL2JyaWRnZSdcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL3V0aWxzJ1xuXG5jb25zdCBtZXRob2RzID0ge1xuICAvLyBSZWdpc3RlciBhIG5ldyBjb21wb25lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gIHJlZ2lzdGVyQ29tcG9uZW50IChuYW1lLCBjb21wKSB7XG4gICAgQ29tcG9uZW50TWFuYWdlci5yZWdpc3RlckNvbXBvbmVudChuYW1lLCBjb21wKVxuICB9LFxuXG4gIC8vIFJlZ2lzdGVyIGEgbmV3IGFwaSBtb2R1bGUuXG4gIC8vIElmIHRoZSBtb2R1bGUgYWxyZWFkeSBleGlzdHMsIGp1c3QgYWRkIG1ldGhvZHMgZnJvbSB0aGVcbiAgLy8gbmV3IG1vZHVsZSB0byB0aGUgb2xkIG9uZS5cbiAgcmVnaXN0ZXJBcGlNb2R1bGUgKG5hbWUsIG1vZHVsZSwgbWV0YSkge1xuICAgIGlmICghcHJvdG9jb2wuYXBpTW9kdWxlW25hbWVdKSB7XG4gICAgICBwcm90b2NvbC5hcGlNb2R1bGVbbmFtZV0gPSBtb2R1bGVcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBtb2R1bGUpIHtcbiAgICAgICAgaWYgKG1vZHVsZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgcHJvdG9jb2wuYXBpTW9kdWxlW25hbWVdW2tleV0gPSBtb2R1bGVba2V5XVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJlZ2lzdGVyIEFQSSBtb2R1bGUncyBtZXRhIGluZm8gdG8ganNmcmFtZXdvcmtcbiAgICBpZiAobWV0YSkge1xuICAgICAgcHJvdG9jb2wuc2V0QXBpTW9kdWxlTWV0YShtZXRhKVxuICAgICAgZ2xvYmFsLnJlZ2lzdGVyTW9kdWxlcyhwcm90b2NvbC5nZXRBcGlNb2R1bGVNZXRhKG5hbWUpLCB0cnVlKVxuICAgIH1cbiAgfSxcblxuICAvLyBSZWdpc3RlciBhIG5ldyBhcGkgbWV0aG9kIGZvciB0aGUgc3BlY2lmaWVkIG1vZHVsZS5cbiAgLy8gb3B0czpcbiAgLy8gIC0gYXJnczogdHlwZSBvZiBhcmd1bWVudHMgdGhlIEFQSSBtZXRob2QgdGFrZXMgc3VjaFxuICAvLyAgICBhcyBbJ3N0cmluZycsICdmdW5jdGlvbiddXG4gIHJlZ2lzdGVyQXBpIChtb2R1bGVOYW1lLCBuYW1lLCBtZXRob2QsIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghcHJvdG9jb2wuYXBpTW9kdWxlW21vZHVsZU5hbWVdKSB7XG4gICAgICBwcm90b2NvbC5hcGlNb2R1bGVbbW9kdWxlTmFtZV0gPSB7fVxuICAgICAgcHJvdG9jb2wuX21ldGFbbW9kdWxlTmFtZV0gPSBbXVxuICAgIH1cbiAgICBwcm90b2NvbC5hcGlNb2R1bGVbbW9kdWxlTmFtZV1bbmFtZV0gPSBtZXRob2RcbiAgICBpZiAoIWFyZ3MpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWdpc3RlciBBUEkgbWV0YSBpbmZvIHRvIGpzZnJhbWV3b3JrXG4gICAgcHJvdG9jb2wuc2V0QXBpTWV0YShtb2R1bGVOYW1lLCB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pXG4gICAgZ2xvYmFsLnJlZ2lzdGVyTW9kdWxlcyhwcm90b2NvbC5nZXRBcGlNb2R1bGVNZXRhKG1vZHVsZU5hbWUpLCB0cnVlKVxuICB9LFxuXG4gIC8vIFJlZ2lzdGVyIGEgbmV3IHdlZXgtYnVuZGxlLWxvYWRlci5cbiAgcmVnaXN0ZXJMb2FkZXIgKG5hbWUsIGxvYWRlckZ1bmMpIHtcbiAgICByZWdpc3RlckxvYWRlcihuYW1lLCBsb2FkZXJGdW5jKVxuICB9XG5cbn1cblxuLy8gVG8gaW5zdGFsbCBjb21wb25lbnRzIGFuZCBwbHVnaW5zLlxuZnVuY3Rpb24gaW5zdGFsbCAobW9kKSB7XG4gIG1vZC5pbml0KHRoaXMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiaW5kIChXZWV4KSB7XG4gIFdlZXguaW5zdGFsbCA9IGluc3RhbGwuYmluZChXZWV4KVxuICBleHRlbmQoV2VleCwgbWV0aG9kcylcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9yZW5kZXIvcmVnaXN0ZXIuanNcbiAqKi8iLCIodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpICYmICh3aW5kb3cgPSB7Y3RybDoge30sIGxpYjoge319KTshd2luZG93LmN0cmwgJiYgKHdpbmRvdy5jdHJsID0ge30pOyF3aW5kb3cubGliICYmICh3aW5kb3cubGliID0ge30pOyFmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJ2YWxcIix7dmFsdWU6YS50b1N0cmluZygpLGVudW1lcmFibGU6ITB9KSx0aGlzLmd0PWZ1bmN0aW9uKGEpe3JldHVybiBjLmNvbXBhcmUodGhpcyxhKT4wfSx0aGlzLmd0ZT1mdW5jdGlvbihhKXtyZXR1cm4gYy5jb21wYXJlKHRoaXMsYSk+PTB9LHRoaXMubHQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGMuY29tcGFyZSh0aGlzLGEpPDB9LHRoaXMubHRlPWZ1bmN0aW9uKGEpe3JldHVybiBjLmNvbXBhcmUodGhpcyxhKTw9MH0sdGhpcy5lcT1mdW5jdGlvbihhKXtyZXR1cm4gMD09PWMuY29tcGFyZSh0aGlzLGEpfX1iLmVudj1iLmVudnx8e30sYy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx9LGMucHJvdG90eXBlLnZhbHVlT2Y9ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy52YWwuc3BsaXQoXCIuXCIpLGI9W10sYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD1wYXJzZUludChhW2NdLDEwKTtpc05hTihkKSYmKGQ9MCk7dmFyIGU9ZC50b1N0cmluZygpO2UubGVuZ3RoPDUmJihlPUFycmF5KDYtZS5sZW5ndGgpLmpvaW4oXCIwXCIpK2UpLGIucHVzaChlKSwxPT09Yi5sZW5ndGgmJmIucHVzaChcIi5cIil9cmV0dXJuIHBhcnNlRmxvYXQoYi5qb2luKFwiXCIpKX0sYy5jb21wYXJlPWZ1bmN0aW9uKGEsYil7YT1hLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpLGI9Yi50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RofHxjPGIubGVuZ3RoO2MrKyl7dmFyIGQ9cGFyc2VJbnQoYVtjXSwxMCksZT1wYXJzZUludChiW2NdLDEwKTtpZih3aW5kb3cuaXNOYU4oZCkmJihkPTApLHdpbmRvdy5pc05hTihlKSYmKGU9MCksZT5kKXJldHVybi0xO2lmKGQ+ZSlyZXR1cm4gMX1yZXR1cm4gMH0sYi52ZXJzaW9uPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYyhhKX19KHdpbmRvdyx3aW5kb3cubGlifHwod2luZG93LmxpYj17fSkpLGZ1bmN0aW9uKGEsYil7Yi5lbnY9Yi5lbnZ8fHt9O3ZhciBjPWEubG9jYXRpb24uc2VhcmNoLnJlcGxhY2UoL15cXD8vLFwiXCIpO2lmKGIuZW52LnBhcmFtcz17fSxjKWZvcih2YXIgZD1jLnNwbGl0KFwiJlwiKSxlPTA7ZTxkLmxlbmd0aDtlKyspe2RbZV09ZFtlXS5zcGxpdChcIj1cIik7dHJ5e2IuZW52LnBhcmFtc1tkW2VdWzBdXT1kZWNvZGVVUklDb21wb25lbnQoZFtlXVsxXSl9Y2F0Y2goZil7Yi5lbnYucGFyYW1zW2RbZV1bMF1dPWRbZV1bMV19fX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSksZnVuY3Rpb24oYSxiKXtiLmVudj1iLmVudnx8e307dmFyIGMsZD1hLm5hdmlnYXRvci51c2VyQWdlbnQ7aWYoYz1kLm1hdGNoKC9XaW5kb3dzXFxzUGhvbmVcXHMoPzpPU1xccyk/KFtcXGRcXC5dKykvKSliLmVudi5vcz17bmFtZTpcIldpbmRvd3MgUGhvbmVcIixpc1dpbmRvd3NQaG9uZTohMCx2ZXJzaW9uOmNbMV19O2Vsc2UgaWYoZC5tYXRjaCgvU2FmYXJpLykmJihjPWQubWF0Y2goL0FuZHJvaWRbXFxzXFwvXShbXFxkXFwuXSspLykpKWIuZW52Lm9zPXt2ZXJzaW9uOmNbMV19LGQubWF0Y2goL01vYmlsZVxccytTYWZhcmkvKT8oYi5lbnYub3MubmFtZT1cIkFuZHJvaWRcIixiLmVudi5vcy5pc0FuZHJvaWQ9ITApOihiLmVudi5vcy5uYW1lPVwiQW5kcm9pZFBhZFwiLGIuZW52Lm9zLmlzQW5kcm9pZFBhZD0hMCk7ZWxzZSBpZihjPWQubWF0Y2goLyhpUGhvbmV8aVBhZHxpUG9kKS8pKXt2YXIgZT1jWzFdO2M9ZC5tYXRjaCgvT1MgKFtcXGRfXFwuXSspIGxpa2UgTWFjIE9TIFgvKSxiLmVudi5vcz17bmFtZTplLGlzSVBob25lOlwiaVBob25lXCI9PT1lfHxcImlQb2RcIj09PWUsaXNJUGFkOlwiaVBhZFwiPT09ZSxpc0lPUzohMCx2ZXJzaW9uOmNbMV0uc3BsaXQoXCJfXCIpLmpvaW4oXCIuXCIpfX1lbHNlIGIuZW52Lm9zPXtuYW1lOlwidW5rbm93blwiLHZlcnNpb246XCIwLjAuMFwifTtiLnZlcnNpb24mJihiLmVudi5vcy52ZXJzaW9uPWIudmVyc2lvbihiLmVudi5vcy52ZXJzaW9uKSl9KHdpbmRvdyx3aW5kb3cubGlifHwod2luZG93LmxpYj17fSkpLGZ1bmN0aW9uKGEsYil7Yi5lbnY9Yi5lbnZ8fHt9O3ZhciBjLGQ9YS5uYXZpZ2F0b3IudXNlckFnZW50OyhjPWQubWF0Y2goLyg/OlVDV0VCfFVDQnJvd3NlclxcLykoW1xcZFxcLl0rKS8pKT9iLmVudi5icm93c2VyPXtuYW1lOlwiVUNcIixpc1VDOiEwLHZlcnNpb246Y1sxXX06KGM9ZC5tYXRjaCgvTVFRQnJvd3NlclxcLyhbXFxkXFwuXSspLykpP2IuZW52LmJyb3dzZXI9e25hbWU6XCJRUVwiLGlzUVE6ITAsdmVyc2lvbjpjWzFdfTooYz1kLm1hdGNoKC9GaXJlZm94XFwvKFtcXGRcXC5dKykvKSk/Yi5lbnYuYnJvd3Nlcj17bmFtZTpcIkZpcmVmb3hcIixpc0ZpcmVmb3g6ITAsdmVyc2lvbjpjWzFdfTooYz1kLm1hdGNoKC9NU0lFXFxzKFtcXGRcXC5dKykvKSl8fChjPWQubWF0Y2goL0lFTW9iaWxlXFwvKFtcXGRcXC5dKykvKSk/KGIuZW52LmJyb3dzZXI9e3ZlcnNpb246Y1sxXX0sZC5tYXRjaCgvSUVNb2JpbGUvKT8oYi5lbnYuYnJvd3Nlci5uYW1lPVwiSUVNb2JpbGVcIixiLmVudi5icm93c2VyLmlzSUVNb2JpbGU9ITApOihiLmVudi5icm93c2VyLm5hbWU9XCJJRVwiLGIuZW52LmJyb3dzZXIuaXNJRT0hMCksZC5tYXRjaCgvQW5kcm9pZHxpUGhvbmUvKSYmKGIuZW52LmJyb3dzZXIuaXNJRUxpa2VXZWJraXQ9ITApKTooYz1kLm1hdGNoKC8oPzpDaHJvbWV8Q3JpT1MpXFwvKFtcXGRcXC5dKykvKSk/KGIuZW52LmJyb3dzZXI9e25hbWU6XCJDaHJvbWVcIixpc0Nocm9tZTohMCx2ZXJzaW9uOmNbMV19LGQubWF0Y2goL1ZlcnNpb25cXC9bXFxkK1xcLl0rXFxzKkNocm9tZS8pJiYoYi5lbnYuYnJvd3Nlci5uYW1lPVwiQ2hyb21lIFdlYnZpZXdcIixiLmVudi5icm93c2VyLmlzV2Vidmlldz0hMCkpOmQubWF0Y2goL1NhZmFyaS8pJiYoYz1kLm1hdGNoKC9BbmRyb2lkW1xcc1xcL10oW1xcZFxcLl0rKS8pKT9iLmVudi5icm93c2VyPXtuYW1lOlwiQW5kcm9pZFwiLGlzQW5kcm9pZDohMCx2ZXJzaW9uOmNbMV19OmQubWF0Y2goL2lQaG9uZXxpUGFkfGlQb2QvKT9kLm1hdGNoKC9TYWZhcmkvKT8oYz1kLm1hdGNoKC9WZXJzaW9uXFwvKFtcXGRcXC5dKykvKSxiLmVudi5icm93c2VyPXtuYW1lOlwiU2FmYXJpXCIsaXNTYWZhcmk6ITAsdmVyc2lvbjpjWzFdfSk6KGM9ZC5tYXRjaCgvT1MgKFtcXGRfXFwuXSspIGxpa2UgTWFjIE9TIFgvKSxiLmVudi5icm93c2VyPXtuYW1lOlwiaU9TIFdlYnZpZXdcIixpc1dlYnZpZXc6ITAsdmVyc2lvbjpjWzFdLnJlcGxhY2UoL1xcXy9nLFwiLlwiKX0pOmIuZW52LmJyb3dzZXI9e25hbWU6XCJ1bmtub3duXCIsdmVyc2lvbjpcIjAuMC4wXCJ9LGIudmVyc2lvbiYmKGIuZW52LmJyb3dzZXIudmVyc2lvbj1iLnZlcnNpb24oYi5lbnYuYnJvd3Nlci52ZXJzaW9uKSl9KHdpbmRvdyx3aW5kb3cubGlifHwod2luZG93LmxpYj17fSkpLGZ1bmN0aW9uKGEsYil7Yi5lbnY9Yi5lbnZ8fHt9O3ZhciBjPWEubmF2aWdhdG9yLnVzZXJBZ2VudDtjLm1hdGNoKC9XZWliby9pKT9iLmVudi50aGlyZGFwcD17YXBwbmFtZTpcIldlaWJvXCIsaXNXZWlibzohMH06Yy5tYXRjaCgvTWljcm9NZXNzZW5nZXIvaSk/Yi5lbnYudGhpcmRhcHA9e2FwcG5hbWU6XCJXZWl4aW5cIixpc1dlaXhpbjohMH06Yi5lbnYudGhpcmRhcHA9ITF9KHdpbmRvdyx3aW5kb3cubGlifHwod2luZG93LmxpYj17fSkpLGZ1bmN0aW9uKGEsYil7Yi5lbnY9Yi5lbnZ8fHt9O3ZhciBjLGQsZT1hLm5hdmlnYXRvci51c2VyQWdlbnQ7KGQ9ZS5tYXRjaCgvV2luZFZhbmVbXFwvXFxzXShbXFxkXFwuXFxfXSspLykpJiYoYz1kWzFdKTt2YXIgZj0hMSxnPVwiXCIsaD1cIlwiLGk9XCJcIjsoZD1lLm1hdGNoKC9BbGlBcHBcXCgoW0EtWlxcLV0rKVxcLyhbXFxkXFwuXSspXFwpL2kpKSYmKGY9ITAsZz1kWzFdLGk9ZFsyXSxoPWcuaW5kZXhPZihcIi1QRFwiKT4wP2IuZW52Lm9zLmlzSU9TP1wiaVBhZFwiOmIuZW52Lm9zLmlzQW5kcm9pZD9cIkFuZHJvaWRQYWRcIjpiLmVudi5vcy5uYW1lOmIuZW52Lm9zLm5hbWUpLCFnJiZlLmluZGV4T2YoXCJUQklPU1wiKT4wJiYoZz1cIlRCXCIpLGY/Yi5lbnYuYWxpYXBwPXt3aW5kdmFuZTpiLnZlcnNpb24oY3x8XCIwLjAuMFwiKSxhcHBuYW1lOmd8fFwidW5rb3duXCIsdmVyc2lvbjpiLnZlcnNpb24oaXx8XCIwLjAuMFwiKSxwbGF0Zm9ybTpofHxiLmVudi5vcy5uYW1lfTpiLmVudi5hbGlhcHA9ITEsYi5lbnYudGFvYmFvQXBwPWIuZW52LmFsaWFwcH0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSk7O21vZHVsZS5leHBvcnRzID0gd2luZG93LmxpYlsnZW52J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZW52ZC9idWlsZC9lbnZkLmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSAmJiAod2luZG93ID0ge2N0cmw6IHt9LCBsaWI6IHt9fSk7IXdpbmRvdy5jdHJsICYmICh3aW5kb3cuY3RybCA9IHt9KTshd2luZG93LmxpYiAmJiAod2luZG93LmxpYiA9IHt9KTshZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe3ZhciBiPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwicGFyYW1zXCIse3NldDpmdW5jdGlvbihhKXtpZihcIm9iamVjdFwiPT10eXBlb2YgYSl7Zm9yKHZhciBjIGluIGIpZGVsZXRlIGJbY107Zm9yKHZhciBjIGluIGEpYltjXT1hW2NdfX0sZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGJ9LGVudW1lcmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcInNlYXJjaFwiLHtzZXQ6ZnVuY3Rpb24oYSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGEpezA9PT1hLmluZGV4T2YoXCI/XCIpJiYoYT1hLnN1YnN0cigxKSk7dmFyIGM9YS5zcGxpdChcIiZcIik7Zm9yKHZhciBkIGluIGIpZGVsZXRlIGJbZF07Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspe3ZhciBmPWNbZV0uc3BsaXQoXCI9XCIpO2lmKHZvaWQgMCE9PWZbMV0mJihmWzFdPWZbMV0udG9TdHJpbmcoKSksZlswXSl0cnl7YltkZWNvZGVVUklDb21wb25lbnQoZlswXSldPWRlY29kZVVSSUNvbXBvbmVudChmWzFdKX1jYXRjaChnKXtiW2ZbMF1dPWZbMV19fX19LGdldDpmdW5jdGlvbigpe3ZhciBhPVtdO2Zvcih2YXIgYyBpbiBiKWlmKHZvaWQgMCE9PWJbY10paWYoXCJcIiE9PWJbY10pdHJ5e2EucHVzaChlbmNvZGVVUklDb21wb25lbnQoYykrXCI9XCIrZW5jb2RlVVJJQ29tcG9uZW50KGJbY10pKX1jYXRjaChkKXthLnB1c2goYytcIj1cIitiW2NdKX1lbHNlIHRyeXthLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGMpKX1jYXRjaChkKXthLnB1c2goYyl9cmV0dXJuIGEubGVuZ3RoP1wiP1wiK2Euam9pbihcIiZcIik6XCJcIn0sZW51bWVyYWJsZTohMH0pO3ZhciBjO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwiaGFzaFwiLHtzZXQ6ZnVuY3Rpb24oYSl7XCJzdHJpbmdcIj09dHlwZW9mIGEmJihhJiZhLmluZGV4T2YoXCIjXCIpPDAmJihhPVwiI1wiK2EpLGM9YXx8XCJcIil9LGdldDpmdW5jdGlvbigpe3JldHVybiBjfSxlbnVtZXJhYmxlOiEwfSksdGhpcy5zZXQ9ZnVuY3Rpb24oYSl7YT1hfHxcIlwiO3ZhciBiO2lmKCEoYj1hLm1hdGNoKG5ldyBSZWdFeHAoXCJeKFthLXowLTktXSs6KT9bL117Mn0oPzooW15ALzo/XSspKD86OihbXkAvOl0rKSk/QCk/KFteOi8/I10rKSg/Ols6XShbMC05XSspKT8oWy9dW14/IztdKik/KD86Wz9dKFteI10qKSk/KFsjXVteP10qKT8kXCIsXCJpXCIpKSkpdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgdXJpIHNjaGVtZS5cIik7dGhpcy5wcm90b2NvbD1iWzFdfHwoXCJvYmplY3RcIj09dHlwZW9mIGxvY2F0aW9uP2xvY2F0aW9uLnByb3RvY29sOlwiXCIpLHRoaXMudXNlcm5hbWU9YlsyXXx8XCJcIix0aGlzLnBhc3N3b3JkPWJbM118fFwiXCIsdGhpcy5ob3N0bmFtZT10aGlzLmhvc3Q9Yls0XSx0aGlzLnBvcnQ9Yls1XXx8XCJcIix0aGlzLnBhdGhuYW1lPWJbNl18fFwiL1wiLHRoaXMuc2VhcmNoPWJbN118fFwiXCIsdGhpcy5oYXNoPWJbOF18fFwiXCIsdGhpcy5vcmlnaW49dGhpcy5wcm90b2NvbCtcIi8vXCIrdGhpcy5ob3N0bmFtZX0sdGhpcy50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBhPXRoaXMucHJvdG9jb2wrXCIvL1wiO3JldHVybiB0aGlzLnVzZXJuYW1lJiYoYSs9dGhpcy51c2VybmFtZSx0aGlzLnBhc3N3b3JkJiYoYSs9XCI6XCIrdGhpcy5wYXNzd29yZCksYSs9XCJAXCIpLGErPXRoaXMuaG9zdCx0aGlzLnBvcnQmJlwiODBcIiE9PXRoaXMucG9ydCYmKGErPVwiOlwiK3RoaXMucG9ydCksdGhpcy5wYXRobmFtZSYmKGErPXRoaXMucGF0aG5hbWUpLHRoaXMuc2VhcmNoJiYoYSs9dGhpcy5zZWFyY2gpLHRoaXMuaGFzaCYmKGErPXRoaXMuaGFzaCksYX0sYSYmdGhpcy5zZXQoYS50b1N0cmluZygpKX1iLmh0dHB1cmw9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBjKGEpfX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSk7O21vZHVsZS5leHBvcnRzID0gd2luZG93LmxpYlsnaHR0cHVybCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2h0dHB1cmwvYnVpbGQvaHR0cHVybC5jb21tb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGVzbGludC1kaXNhYmxlICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgaXNJbml0aWFsaXplZCA9IGZhbHNlXG5cbi8vIG1ham9yIGV2ZW50cyBzdXBwb3J0ZWQ6XG4vLyAgIHBhbnN0YXJ0XG4vLyAgIHBhbm1vdmVcbi8vICAgcGFuZW5kXG4vLyAgIHN3aXBlXG4vLyAgIGxvbmdwcmVzc1xuLy8gZXh0cmEgZXZlbnRzIHN1cHBvcnRlZDpcbi8vICAgZHVhbHRvdWNoc3RhcnRcbi8vICAgZHVhbHRvdWNoXG4vLyAgIGR1YWx0b3VjaGVuZFxuLy8gICB0YXBcbi8vICAgZG91YmxldGFwXG4vLyAgIHByZXNzZW5kXG5cbnZhciBkb2MgPSB3aW5kb3cuZG9jdW1lbnRcbnZhciBkb2NFbCA9IGRvYy5kb2N1bWVudEVsZW1lbnRcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxudmFyIGdlc3R1cmVzID0ge31cbnZhciBsYXN0VGFwID0gbnVsbFxuXG4vKipcbiAqIGZpbmQgdGhlIGNsb3Nlc3QgY29tbW9uIGFuY2VzdG9yXG4gKiBpZiB0aGVyZSdzIG5vIG9uZSwgcmV0dXJuIG51bGxcbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbDEgZmlyc3QgZWxlbWVudFxuICogQHBhcmFtICB7RWxlbWVudH0gZWwyIHNlY29uZCBlbGVtZW50XG4gKiBAcmV0dXJuIHtFbGVtZW50fSAgICAgY29tbW9uIGFuY2VzdG9yXG4gKi9cbmZ1bmN0aW9uIGdldENvbW1vbkFuY2VzdG9yKGVsMSwgZWwyKSB7XG4gIHZhciBlbCA9IGVsMVxuICB3aGlsZSAoZWwpIHtcbiAgICBpZiAoZWwuY29udGFpbnMoZWwyKSB8fCBlbCA9PSBlbDIpIHtcbiAgICAgIHJldHVybiBlbFxuICAgIH1cbiAgICBlbCA9IGVsLnBhcmVudE5vZGVcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG4vKipcbiAqIGZpcmUgYSBIVE1MRXZlbnRcbiAqXG4gKiBAcGFyYW0gIHtFbGVtZW50fSBlbGVtZW50IHdoaWNoIGVsZW1lbnQgdG8gZmlyZSBhIGV2ZW50IG9uXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICB0eXBlICAgIHR5cGUgb2YgZXZlbnRcbiAqIEBwYXJhbSAge29iamVjdH0gIGV4dHJhICAgZXh0cmEgZGF0YSBmb3IgdGhlIGV2ZW50IG9iamVjdFxuICovXG5mdW5jdGlvbiBmaXJlRXZlbnQoZWxlbWVudCwgdHlwZSwgZXh0cmEpIHtcbiAgdmFyIGV2ZW50ID0gZG9jLmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJylcbiAgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpXG5cbiAgaWYgKHR5cGVvZiBleHRyYSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBwIGluIGV4dHJhKSB7XG4gICAgICBldmVudFtwXSA9IGV4dHJhW3BdXG4gICAgfVxuICB9XG5cbiAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KVxufVxuXG4vKipcbiAqIGNhbGMgdGhlIHRyYW5zZm9ybVxuICogYXNzdW1lIDQgcG9pbnRzIEFCQ0Qgb24gdGhlIGNvb3JkaW5hdGUgc3lzdGVtXG4gKiA+IHJvdGF0Ze+8mmFuZ2xlIHJvdGF0aW5nIGZyb20gQUIgdG8gQ0RcbiAqID4gc2NhbGXvvJpzY2FsZSByYXRpbyBmcm9tIEFCIHRvIENEXG4gKiA+IHRyYW5zbGF0Ze+8mnRyYW5zbGF0ZSBzaGlmdCBmcm9tIEEgdG8gQ1xuICpcbiAqIEBwYXJhbSAge251bWJlcn0geDEgYWJzY2lzc2Egb2YgQVxuICogQHBhcmFtICB7bnVtYmVyfSB5MSBvcmRpbmF0ZSBvZiBBXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgyIGFic2Npc3NhIG9mIEJcbiAqIEBwYXJhbSAge251bWJlcn0geTIgb3JkaW5hdGUgb2YgQlxuICogQHBhcmFtICB7bnVtYmVyfSB4MyBhYnNjaXNzYSBvZiBDXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkzIG9yZGluYXRlIG9mIENcbiAqIEBwYXJhbSAge251bWJlcn0geDQgYWJzY2lzc2Egb2YgRFxuICogQHBhcmFtICB7bnVtYmVyfSB5NCBvcmRpbmF0ZSBvZiBEXG4gKiBAcmV0dXJuIHtvYmplY3R9ICAgIHRyYW5zZm9ybSBvYmplY3QgbGlrZVxuICogICB7cm90YXRlLCBzY2FsZSwgdHJhbnNsYXRlWzJdLCBtYXRyaXhbM11bM119XG4gKi9cbmZ1bmN0aW9uIGNhbGMoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KSB7XG4gIHZhciByb3RhdGUgPSBNYXRoLmF0YW4yKHk0IC0geTMsIHg0IC0geDMpIC0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKVxuICB2YXIgc2NhbGUgPSBNYXRoLnNxcnQoKE1hdGgucG93KHk0IC0geTMsIDIpXG4gICAgKyBNYXRoLnBvdyh4NCAtIHgzLCAyKSkgLyAoTWF0aC5wb3coeTIgLSB5MSwgMilcbiAgICArIE1hdGgucG93KHgyIC0geDEsIDIpKSlcbiAgdmFyIHRyYW5zbGF0ZSA9IFtcbiAgICB4M1xuICAgIC0gc2NhbGUgKiB4MSAqIE1hdGguY29zKHJvdGF0ZSlcbiAgICArIHNjYWxlICogeTEgKiBNYXRoLnNpbihyb3RhdGUpLFxuICAgIHkzXG4gICAgLSBzY2FsZSAqIHkxICogTWF0aC5jb3Mocm90YXRlKVxuICAgIC0gc2NhbGUgKiB4MSAqIE1hdGguc2luKHJvdGF0ZSldXG5cbiAgcmV0dXJuIHtcbiAgICByb3RhdGU6IHJvdGF0ZSxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgdHJhbnNsYXRlOiB0cmFuc2xhdGUsXG4gICAgbWF0cml4OiBbXG4gICAgICBbc2NhbGUgKiBNYXRoLmNvcyhyb3RhdGUpLCAtc2NhbGUgKiBNYXRoLnNpbihyb3RhdGUpLCB0cmFuc2xhdGVbMF1dLFxuICAgICAgW3NjYWxlICogTWF0aC5zaW4ocm90YXRlKSwgc2NhbGUgKiBNYXRoLmNvcyhyb3RhdGUpLCB0cmFuc2xhdGVbMV1dLFxuICAgICAgWzAsIDAsIDFdXG4gICAgXVxuICB9XG59XG5cbi8qKlxuICogdGFrZSBvdmVyIHRoZSB0b3VjaHN0YXJ0IGV2ZW50cy4gQWRkIG5ldyB0b3VjaGVzIHRvIHRoZSBnZXN0dXJlcy5cbiAqIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIHJlY29yZHMsIHRoZW4gYmluZCB0b3VjaG1vdmUsIHRvY2hlbmRcbiAqIGFuZCB0b3VjaGNhbmNlbCBldmVudHMuXG4gKiBuZXcgdG91Y2hlcyBpbml0aWFsaXplZCB3aXRoIHN0YXRlICd0YXBwaW5nJywgYW5kIHdpdGhpbiA1MDAgbWlsbGlzZWNvbmRzXG4gKiBpZiB0aGUgc3RhdGUgaXMgc3RpbGwgdGFwcGluZywgdGhlbiB0cmlnZ2VyIGdlc3R1cmUgJ3ByZXNzJy5cbiAqIElmIHRoZXJlIGFyZSB0d28gdG91Y2hlIHBvaW50cywgdGhlbiB0aGUgJ2R1YWx0b3VjaHN0YXJ0JyBpcyB0cmlnZ2VyZC4gVGhlXG4gKiBub2RlIG9mIHRoZSB0b3VjaCBnZXN0dXJlIGlzIHRoZWlyIGNsb2VzdCBjb21tb24gYW5jZXN0b3IuXG4gKlxuICogQGV2ZW50XG4gKiBAcGFyYW0gIHtldmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gdG91Y2hzdGFydEhhbmRsZXIoZXZlbnQpIHtcblxuICBpZiAoT2JqZWN0LmtleXMoZ2VzdHVyZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgIGRvY0VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNobW92ZUhhbmRsZXIsIGZhbHNlKVxuICAgIGRvY0VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hlbmRIYW5kbGVyLCBmYWxzZSlcbiAgICBkb2NFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRvdWNoY2FuY2VsSGFuZGxlciwgZmFsc2UpXG4gIH1cblxuICAvLyByZWNvcmQgZXZlcnkgdG91Y2hcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzW2ldXG4gICAgdmFyIHRvdWNoUmVjb3JkID0ge31cblxuICAgIGZvciAodmFyIHAgaW4gdG91Y2gpIHtcbiAgICAgIHRvdWNoUmVjb3JkW3BdID0gdG91Y2hbcF1cbiAgICB9XG5cbiAgICB2YXIgZ2VzdHVyZSA9IHtcbiAgICAgIHN0YXJ0VG91Y2g6IHRvdWNoUmVjb3JkLFxuICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgc3RhdHVzOiAndGFwcGluZycsXG4gICAgICBlbGVtZW50OiBldmVudC5zcmNFbGVtZW50IHx8IGV2ZW50LnRhcmdldCxcbiAgICAgIHByZXNzaW5nSGFuZGxlcjogc2V0VGltZW91dChmdW5jdGlvbiAoZWxlbWVudCwgdG91Y2gpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZ2VzdHVyZS5zdGF0dXMgPT09ICd0YXBwaW5nJykge1xuICAgICAgICAgICAgZ2VzdHVyZS5zdGF0dXMgPSAncHJlc3NpbmcnXG5cbiAgICAgICAgICAgIGZpcmVFdmVudChlbGVtZW50LCAnbG9uZ3ByZXNzJywge1xuICAgICAgICAgICAgICAvLyBhZGQgdG91Y2ggZGF0YSBmb3Igd2VleFxuICAgICAgICAgICAgICB0b3VjaDogdG91Y2gsXG4gICAgICAgICAgICAgIHRvdWNoZXM6IGV2ZW50LnRvdWNoZXMsXG4gICAgICAgICAgICAgIGNoYW5nZWRUb3VjaGVzOiBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgICAgICAgdG91Y2hFdmVudDogZXZlbnRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGdlc3R1cmUucHJlc3NpbmdIYW5kbGVyKVxuICAgICAgICAgIGdlc3R1cmUucHJlc3NpbmdIYW5kbGVyID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9KGV2ZW50LnNyY0VsZW1lbnQgfHwgZXZlbnQudGFyZ2V0LCBldmVudC5jaGFuZ2VkVG91Y2hlc1tpXSksIDUwMClcbiAgICB9XG4gICAgZ2VzdHVyZXNbdG91Y2guaWRlbnRpZmllcl0gPSBnZXN0dXJlXG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoZ2VzdHVyZXMpLmxlbmd0aCA9PSAyKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gW11cblxuICAgIGZvciAodmFyIHAgaW4gZ2VzdHVyZXMpIHtcbiAgICAgIGVsZW1lbnRzLnB1c2goZ2VzdHVyZXNbcF0uZWxlbWVudClcbiAgICB9XG5cbiAgICBmaXJlRXZlbnQoZ2V0Q29tbW9uQW5jZXN0b3IoZWxlbWVudHNbMF0sIGVsZW1lbnRzWzFdKSwgJ2R1YWx0b3VjaHN0YXJ0Jywge1xuICAgICAgdG91Y2hlczogc2xpY2UuY2FsbChldmVudC50b3VjaGVzKSxcbiAgICAgIHRvdWNoRXZlbnQ6IGV2ZW50XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIHRha2Ugb3ZlciB0b3VjaG1vdmUgZXZlbnRzLCBhbmQgaGFuZGxlIHBhbiBhbmQgZHVhbCByZWxhdGVkIGdlc3R1cmVzLlxuICpcbiAqIDEuIHRyYXZlcnNlIGV2ZXJ5IHRvdWNoIHBvaW5077yaXG4gKiA+IGlmICd0YXBwaW5nJyBhbmQgdGhlIHNoaWZ0IGlzIG92ZXIgMTAgcGl4bGVzLCB0aGVuIGl0J3MgYSAncGFubmluZycuXG4gKiAyLiBpZiB0aGVyZSBhcmUgdHdvIHRvdWNoIHBvaW50cywgdGhlbiBjYWxjIHRoZSB0cmFuZm9ybSBhbmQgdHJpZ2dlclxuICogICAnZHVhbHRvdWNoJy5cbiAqXG4gKiBAZXZlbnRcbiAqIEBwYXJhbSAge2V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiB0b3VjaG1vdmVIYW5kbGVyKGV2ZW50KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1tpXVxuICAgIHZhciBnZXN0dXJlID0gZ2VzdHVyZXNbdG91Y2guaWRlbnRpZmllcl1cblxuICAgIGlmICghZ2VzdHVyZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFnZXN0dXJlLmxhc3RUb3VjaCkge1xuICAgICAgZ2VzdHVyZS5sYXN0VG91Y2ggPSBnZXN0dXJlLnN0YXJ0VG91Y2hcbiAgICB9XG4gICAgaWYgKCFnZXN0dXJlLmxhc3RUaW1lKSB7XG4gICAgICBnZXN0dXJlLmxhc3RUaW1lID0gZ2VzdHVyZS5zdGFydFRpbWVcbiAgICB9XG4gICAgaWYgKCFnZXN0dXJlLnZlbG9jaXR5WCkge1xuICAgICAgZ2VzdHVyZS52ZWxvY2l0eVggPSAwXG4gICAgfVxuICAgIGlmICghZ2VzdHVyZS52ZWxvY2l0eVkpIHtcbiAgICAgIGdlc3R1cmUudmVsb2NpdHlZID0gMFxuICAgIH1cbiAgICBpZiAoIWdlc3R1cmUuZHVyYXRpb24pIHtcbiAgICAgIGdlc3R1cmUuZHVyYXRpb24gPSAwXG4gICAgfVxuXG4gICAgdmFyIHRpbWUgPSAgRGF0ZS5ub3coKSAtIGdlc3R1cmUubGFzdFRpbWVcbiAgICB2YXIgdnggPSAodG91Y2guY2xpZW50WCAtIGdlc3R1cmUubGFzdFRvdWNoLmNsaWVudFgpIC8gdGltZVxuICAgIHZhciB2eSA9ICh0b3VjaC5jbGllbnRZIC0gZ2VzdHVyZS5sYXN0VG91Y2guY2xpZW50WSkgLyB0aW1lXG5cbiAgICB2YXIgUkVDT1JEX0RVUkFUSU9OID0gNzBcbiAgICBpZiAodGltZSA+IFJFQ09SRF9EVVJBVElPTikge1xuICAgICAgdGltZSA9IFJFQ09SRF9EVVJBVElPTlxuICAgIH1cbiAgICBpZiAoZ2VzdHVyZS5kdXJhdGlvbiArIHRpbWUgPiBSRUNPUkRfRFVSQVRJT04pIHtcbiAgICAgIGdlc3R1cmUuZHVyYXRpb24gPSBSRUNPUkRfRFVSQVRJT04gLSB0aW1lXG4gICAgfVxuXG4gICAgZ2VzdHVyZS52ZWxvY2l0eVggPSAoZ2VzdHVyZS52ZWxvY2l0eVggKiBnZXN0dXJlLmR1cmF0aW9uICsgdnggKiB0aW1lKVxuICAgICAgLyAoZ2VzdHVyZS5kdXJhdGlvbiArIHRpbWUpXG4gICAgZ2VzdHVyZS52ZWxvY2l0eVkgPSAoZ2VzdHVyZS52ZWxvY2l0eVkgKiBnZXN0dXJlLmR1cmF0aW9uICsgdnkgKiB0aW1lKVxuICAgICAgLyAoZ2VzdHVyZS5kdXJhdGlvbiArIHRpbWUpXG4gICAgZ2VzdHVyZS5kdXJhdGlvbiArPSB0aW1lXG5cbiAgICBnZXN0dXJlLmxhc3RUb3VjaCA9IHt9XG5cbiAgICBmb3IgKHZhciBwIGluIHRvdWNoKSB7XG4gICAgICBnZXN0dXJlLmxhc3RUb3VjaFtwXSA9IHRvdWNoW3BdXG4gICAgfVxuICAgIGdlc3R1cmUubGFzdFRpbWUgPSBEYXRlLm5vdygpXG5cbiAgICB2YXIgZGlzcGxhY2VtZW50WCA9IHRvdWNoLmNsaWVudFggLSBnZXN0dXJlLnN0YXJ0VG91Y2guY2xpZW50WFxuICAgIHZhciBkaXNwbGFjZW1lbnRZID0gdG91Y2guY2xpZW50WSAtIGdlc3R1cmUuc3RhcnRUb3VjaC5jbGllbnRZXG4gICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KGRpc3BsYWNlbWVudFgsIDIpXG4gICAgICArIE1hdGgucG93KGRpc3BsYWNlbWVudFksIDIpKVxuICAgIHZhciBpc1ZlcnRpY2FsID0gIShNYXRoLmFicyhkaXNwbGFjZW1lbnRYKSA+IE1hdGguYWJzKGRpc3BsYWNlbWVudFkpKVxuICAgIHZhciBkaXJlY3Rpb24gPSBpc1ZlcnRpY2FsXG4gICAgICA/IGRpc3BsYWNlbWVudFkgPj0gMCA/ICdkb3duJyA6ICd1cCdcbiAgICAgIDogZGlzcGxhY2VtZW50WCA+PSAwID8gJ3JpZ2h0JyA6ICdsZWZ0J1xuXG4gICAgLy8gbWFnaWMgbnVtYmVyIDEwOiBtb3ZpbmcgMTBweCBtZWFucyBwYW4sIG5vdCB0YXBcbiAgICBpZiAoKGdlc3R1cmUuc3RhdHVzID09PSAndGFwcGluZycgfHwgZ2VzdHVyZS5zdGF0dXMgPT09ICdwcmVzc2luZycpXG4gICAgICAgICYmIGRpc3RhbmNlID4gMTApIHtcbiAgICAgIGdlc3R1cmUuc3RhdHVzID0gJ3Bhbm5pbmcnXG4gICAgICBnZXN0dXJlLmlzVmVydGljYWwgPSBpc1ZlcnRpY2FsXG4gICAgICBnZXN0dXJlLmRpcmVjdGlvbiA9IGRpcmVjdGlvblxuXG4gICAgICBmaXJlRXZlbnQoZ2VzdHVyZS5lbGVtZW50LCAncGFuc3RhcnQnLCB7XG4gICAgICAgIHRvdWNoOiB0b3VjaCxcbiAgICAgICAgdG91Y2hlczogZXZlbnQudG91Y2hlcyxcbiAgICAgICAgY2hhbmdlZFRvdWNoZXM6IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICB0b3VjaEV2ZW50OiBldmVudCxcbiAgICAgICAgaXNWZXJ0aWNhbDogZ2VzdHVyZS5pc1ZlcnRpY2FsLFxuICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoZ2VzdHVyZS5zdGF0dXMgPT09ICdwYW5uaW5nJykge1xuICAgICAgZ2VzdHVyZS5wYW5UaW1lID0gRGF0ZS5ub3coKVxuXG4gICAgICBmaXJlRXZlbnQoZ2VzdHVyZS5lbGVtZW50LCAncGFubW92ZScsIHtcbiAgICAgICAgZGlzcGxhY2VtZW50WDogZGlzcGxhY2VtZW50WCxcbiAgICAgICAgZGlzcGxhY2VtZW50WTogZGlzcGxhY2VtZW50WSxcbiAgICAgICAgdG91Y2g6IHRvdWNoLFxuICAgICAgICB0b3VjaGVzOiBldmVudC50b3VjaGVzLFxuICAgICAgICBjaGFuZ2VkVG91Y2hlczogZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIHRvdWNoRXZlbnQ6IGV2ZW50LFxuICAgICAgICBpc1ZlcnRpY2FsOiBnZXN0dXJlLmlzVmVydGljYWwsXG4gICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhnZXN0dXJlcykubGVuZ3RoID09IDIpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBbXVxuICAgIHZhciBjdXJyZW50ID0gW11cbiAgICB2YXIgZWxlbWVudHMgPSBbXVxuICAgIHZhciB0cmFuc2Zvcm1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQudG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRvdWNoID0gZXZlbnQudG91Y2hlc1tpXVxuICAgICAgdmFyIGdlc3R1cmUgPSBnZXN0dXJlc1t0b3VjaC5pZGVudGlmaWVyXVxuICAgICAgcG9zaXRpb24ucHVzaChbZ2VzdHVyZS5zdGFydFRvdWNoLmNsaWVudFgsIGdlc3R1cmUuc3RhcnRUb3VjaC5jbGllbnRZXSlcbiAgICAgIGN1cnJlbnQucHVzaChbdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WV0pXG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBnZXN0dXJlcykge1xuICAgICAgZWxlbWVudHMucHVzaChnZXN0dXJlc1twXS5lbGVtZW50KVxuICAgIH1cblxuICAgIHRyYW5zZm9ybSA9IGNhbGMoXG4gICAgICBwb3NpdGlvblswXVswXSxcbiAgICAgIHBvc2l0aW9uWzBdWzFdLFxuICAgICAgcG9zaXRpb25bMV1bMF0sXG4gICAgICBwb3NpdGlvblsxXVsxXSxcbiAgICAgIGN1cnJlbnRbMF1bMF0sXG4gICAgICBjdXJyZW50WzBdWzFdLFxuICAgICAgY3VycmVudFsxXVswXSxcbiAgICAgIGN1cnJlbnRbMV1bMV1cbiAgICApXG4gICAgZmlyZUV2ZW50KGdldENvbW1vbkFuY2VzdG9yKGVsZW1lbnRzWzBdLCBlbGVtZW50c1sxXSksICdkdWFsdG91Y2gnLCB7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgIHRvdWNoZXM6IGV2ZW50LnRvdWNoZXMsXG4gICAgICB0b3VjaEV2ZW50OiBldmVudFxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBoYW5kbGUgdG91Y2hlbmQgZXZlbnRcbiAqXG4gKiAxLiBpZiB0aGVyZSBhcmUgdG93IHRvdWNoIHBvaW50cywgdGhlbiB0cmlnZ2VyICdkdWFsdG91Y2hlbmQn5aaCXG4gKlxuICogMi4gdHJhdmVyc2UgZXZlcnkgdG91Y2ggcGlvbnTvvJpcbiAqID4gaWYgdGFwcGluZywgdGhlbiB0cmlnZ2VyICd0YXAnLlxuICogSWYgdGhlcmUgaXMgYSB0YXAgMzAwIG1pbGxpc2Vjb25kcyBiZWZvcmUsIHRoZW4gaXQncyBhICdkb3VibGV0YXAnLlxuICogPiBpZiBwYWRkaW5nLCB0aGVuIGRlY2lkZSB0byB0cmlnZ2VyICdwYW5lbmQnIG9yICdzd2lwZSdcbiAqID4gaWYgcHJlc3NpbmcsIHRoZW4gdHJpZ2dlciAncHJlc3NlbmQnLlxuICpcbiAqIDMuIHJlbW92ZSBsaXN0ZW5lcnMuXG4gKlxuICogQGV2ZW50XG4gKiBAcGFyYW0gIHtldmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gdG91Y2hlbmRIYW5kbGVyKGV2ZW50KSB7XG5cbiAgaWYgKE9iamVjdC5rZXlzKGdlc3R1cmVzKS5sZW5ndGggPT0gMikge1xuICAgIHZhciBlbGVtZW50cyA9IFtdXG4gICAgZm9yICh2YXIgcCBpbiBnZXN0dXJlcykge1xuICAgICAgZWxlbWVudHMucHVzaChnZXN0dXJlc1twXS5lbGVtZW50KVxuICAgIH1cbiAgICBmaXJlRXZlbnQoZ2V0Q29tbW9uQW5jZXN0b3IoZWxlbWVudHNbMF0sIGVsZW1lbnRzWzFdKSwgJ2R1YWx0b3VjaGVuZCcsIHtcbiAgICAgIHRvdWNoZXM6IHNsaWNlLmNhbGwoZXZlbnQudG91Y2hlcyksXG4gICAgICB0b3VjaEV2ZW50OiBldmVudFxuICAgIH0pXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbaV1cbiAgICB2YXIgaWQgPSB0b3VjaC5pZGVudGlmaWVyXG4gICAgdmFyIGdlc3R1cmUgPSBnZXN0dXJlc1tpZF1cblxuICAgIGlmICghZ2VzdHVyZSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoZ2VzdHVyZS5wcmVzc2luZ0hhbmRsZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChnZXN0dXJlLnByZXNzaW5nSGFuZGxlcilcbiAgICAgIGdlc3R1cmUucHJlc3NpbmdIYW5kbGVyID0gbnVsbFxuICAgIH1cblxuICAgIGlmIChnZXN0dXJlLnN0YXR1cyA9PT0gJ3RhcHBpbmcnKSB7XG4gICAgICBnZXN0dXJlLnRpbWVzdGFtcCA9IERhdGUubm93KClcbiAgICAgIGZpcmVFdmVudChnZXN0dXJlLmVsZW1lbnQsICd0YXAnLCB7XG4gICAgICAgIHRvdWNoOiB0b3VjaCxcbiAgICAgICAgdG91Y2hFdmVudDogZXZlbnRcbiAgICAgIH0pXG5cbiAgICAgIGlmIChsYXN0VGFwICYmIGdlc3R1cmUudGltZXN0YW1wIC0gbGFzdFRhcC50aW1lc3RhbXAgPCAzMDApIHtcbiAgICAgICAgZmlyZUV2ZW50KGdlc3R1cmUuZWxlbWVudCwgJ2RvdWJsZXRhcCcsIHtcbiAgICAgICAgICB0b3VjaDogdG91Y2gsXG4gICAgICAgICAgdG91Y2hFdmVudDogZXZlbnRcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgbGFzdFRhcCA9IGdlc3R1cmVcbiAgICB9XG5cbiAgICBpZiAoZ2VzdHVyZS5zdGF0dXMgPT09ICdwYW5uaW5nJykge1xuICAgICAgdmFyIG5vdyA9IERhdGUubm93KClcbiAgICAgIHZhciBkdXJhdGlvbiA9IG5vdyAtIGdlc3R1cmUuc3RhcnRUaW1lXG4gICAgICB2YXIgZGlzcGxhY2VtZW50WCA9IHRvdWNoLmNsaWVudFggLSBnZXN0dXJlLnN0YXJ0VG91Y2guY2xpZW50WFxuICAgICAgdmFyIGRpc3BsYWNlbWVudFkgPSB0b3VjaC5jbGllbnRZIC0gZ2VzdHVyZS5zdGFydFRvdWNoLmNsaWVudFlcblxuICAgICAgdmFyIHZlbG9jaXR5ID0gTWF0aC5zcXJ0KGdlc3R1cmUudmVsb2NpdHlZICogZ2VzdHVyZS52ZWxvY2l0eVlcbiAgICAgICAgKyBnZXN0dXJlLnZlbG9jaXR5WCAqIGdlc3R1cmUudmVsb2NpdHlYKVxuICAgICAgdmFyIGlzU3dpcGUgPSB2ZWxvY2l0eSA+IDAuNSAmJiAobm93IC0gZ2VzdHVyZS5sYXN0VGltZSkgPCAxMDBcbiAgICAgIHZhciBleHRyYSA9IHtcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBpc1N3aXBlOiBpc1N3aXBlLFxuICAgICAgICB2ZWxvY2l0eVg6IGdlc3R1cmUudmVsb2NpdHlYLFxuICAgICAgICB2ZWxvY2l0eVk6IGdlc3R1cmUudmVsb2NpdHlZLFxuICAgICAgICBkaXNwbGFjZW1lbnRYOiBkaXNwbGFjZW1lbnRYLFxuICAgICAgICBkaXNwbGFjZW1lbnRZOiBkaXNwbGFjZW1lbnRZLFxuICAgICAgICB0b3VjaDogdG91Y2gsXG4gICAgICAgIHRvdWNoZXM6IGV2ZW50LnRvdWNoZXMsXG4gICAgICAgIGNoYW5nZWRUb3VjaGVzOiBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgdG91Y2hFdmVudDogZXZlbnQsXG4gICAgICAgIGlzVmVydGljYWw6IGdlc3R1cmUuaXNWZXJ0aWNhbCxcbiAgICAgICAgZGlyZWN0aW9uOiBnZXN0dXJlLmRpcmVjdGlvblxuICAgICAgfVxuXG4gICAgICBmaXJlRXZlbnQoZ2VzdHVyZS5lbGVtZW50LCAncGFuZW5kJywgZXh0cmEpXG4gICAgICBpZiAoaXNTd2lwZSkge1xuICAgICAgICBmaXJlRXZlbnQoZ2VzdHVyZS5lbGVtZW50LCAnc3dpcGUnLCBleHRyYSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ2VzdHVyZS5zdGF0dXMgPT09ICdwcmVzc2luZycpIHtcbiAgICAgIGZpcmVFdmVudChnZXN0dXJlLmVsZW1lbnQsICdwcmVzc2VuZCcsIHtcbiAgICAgICAgdG91Y2g6IHRvdWNoLFxuICAgICAgICB0b3VjaEV2ZW50OiBldmVudFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBkZWxldGUgZ2VzdHVyZXNbaWRdXG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoZ2VzdHVyZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgIGRvY0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNobW92ZUhhbmRsZXIsIGZhbHNlKVxuICAgIGRvY0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hlbmRIYW5kbGVyLCBmYWxzZSlcbiAgICBkb2NFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRvdWNoY2FuY2VsSGFuZGxlciwgZmFsc2UpXG4gIH1cbn1cblxuLyoqXG4gKiBoYW5kbGUgdG91Y2hjYW5jZWxcbiAqXG4gKiAxLiBpZiB0aGVyZSBhcmUgdHdvIHRvdWNoIHBvaW50cywgdGhlbiB0cmlnZ2VyICdkdWFsdG91Y2hlbmQnXG4gKlxuICogMi4gdHJhdmVyc2UgZXZlcnR5IHRvdWNoIHBvaW50OlxuICogPiBpZiBwYW5ubmlnLCB0aGVuIHRyaWdnZXIgJ3BhbmVuZCdcbiAqID4gaWYgcHJlc3NpbmcsIHRoZW4gdHJpZ2dlciAncHJlc3NlbmQnXG4gKlxuICogMy4gcmVtb3ZlIGxpc3RlbmVyc1xuICpcbiAqIEBldmVudFxuICogQHBhcmFtICB7ZXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHRvdWNoY2FuY2VsSGFuZGxlcihldmVudCkge1xuXG4gIGlmIChPYmplY3Qua2V5cyhnZXN0dXJlcykubGVuZ3RoID09IDIpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXVxuICAgIGZvciAodmFyIHAgaW4gZ2VzdHVyZXMpIHtcbiAgICAgIGVsZW1lbnRzLnB1c2goZ2VzdHVyZXNbcF0uZWxlbWVudClcbiAgICB9XG4gICAgZmlyZUV2ZW50KGdldENvbW1vbkFuY2VzdG9yKGVsZW1lbnRzWzBdLCBlbGVtZW50c1sxXSksICdkdWFsdG91Y2hlbmQnLCB7XG4gICAgICB0b3VjaGVzOiBzbGljZS5jYWxsKGV2ZW50LnRvdWNoZXMpLFxuICAgICAgdG91Y2hFdmVudDogZXZlbnRcbiAgICB9KVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzW2ldXG4gICAgdmFyIGlkID0gdG91Y2guaWRlbnRpZmllclxuICAgIHZhciBnZXN0dXJlID0gZ2VzdHVyZXNbaWRdXG5cbiAgICBpZiAoIWdlc3R1cmUpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGdlc3R1cmUucHJlc3NpbmdIYW5kbGVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZ2VzdHVyZS5wcmVzc2luZ0hhbmRsZXIpXG4gICAgICBnZXN0dXJlLnByZXNzaW5nSGFuZGxlciA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAoZ2VzdHVyZS5zdGF0dXMgPT09ICdwYW5uaW5nJykge1xuICAgICAgZmlyZUV2ZW50KGdlc3R1cmUuZWxlbWVudCwgJ3BhbmVuZCcsIHtcbiAgICAgICAgdG91Y2g6IHRvdWNoLFxuICAgICAgICB0b3VjaGVzOiBldmVudC50b3VjaGVzLFxuICAgICAgICBjaGFuZ2VkVG91Y2hlczogZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIHRvdWNoRXZlbnQ6IGV2ZW50XG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAoZ2VzdHVyZS5zdGF0dXMgPT09ICdwcmVzc2luZycpIHtcbiAgICAgIGZpcmVFdmVudChnZXN0dXJlLmVsZW1lbnQsICdwcmVzc2VuZCcsIHtcbiAgICAgICAgdG91Y2g6IHRvdWNoLFxuICAgICAgICB0b3VjaEV2ZW50OiBldmVudFxuICAgICAgfSlcbiAgICB9XG4gICAgZGVsZXRlIGdlc3R1cmVzW2lkXVxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKGdlc3R1cmVzKS5sZW5ndGggPT09IDApIHtcbiAgICBkb2NFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaG1vdmVIYW5kbGVyLCBmYWxzZSlcbiAgICBkb2NFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoZW5kSGFuZGxlciwgZmFsc2UpXG4gICAgZG9jRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0b3VjaGNhbmNlbEhhbmRsZXIsIGZhbHNlKVxuICB9XG59XG5cbmlmICghaXNJbml0aWFsaXplZCkge1xuICBkb2NFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydEhhbmRsZXIsIGZhbHNlKVxuICBpc0luaXRpYWxpemVkID0gdHJ1ZVxufVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvcmVuZGVyL2dlc3R1cmUuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IENvbXBvbmVudE1hbmFnZXIgZnJvbSAnLi4vZG9tL2NvbXBvbmVudE1hbmFnZXInXG5pbXBvcnQgY29uZmlnIGZyb20gJy4uL3JlbmRlci9jb25maWcnXG5cbmZ1bmN0aW9uIGRldGVjdFJvb3RIZWlnaHQgKHJvb3QpIHtcbiAgY29uc3Qgcm9vdFF1ZXJ5ID0gJyMnICsgcm9vdC5nZXRXZWV4SW5zdGFuY2UoKS5yb290SWRcbiAgY29uc3Qgcm9vdENvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iocm9vdFF1ZXJ5KSB8fCBkb2N1bWVudC5ib2R5XG4gIGNvbnN0IGhlaWdodCA9IHJvb3RDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gIGlmIChoZWlnaHQgPiBnbG9iYWwuaW5uZXJIZWlnaHQpIHtcbiAgICBjb25zb2xlLndhcm4oW1xuICAgICAgJ1toNS1yZW5kZXJdIGZvciBzY3JvbGxhYmxlIHJvb3QgbGlrZSBcXCdsaXN0XFwnIGFuZCBcXCdzY3JvbGxlclxcJywgdGhlIGhlaWdodCBvZiAnLFxuICAgICAgJ3RoZSByb290IGNvbnRhaW5lciBtdXN0IGJlIGEgdXNlci1zcGVjaWZpZWQgdmFsdWUuIE90aGVyd2lzZSAnLFxuICAgICAgJ3RoZSBzY3JvbGxhYmxlIGVsZW1lbnQgbWF5IG5vdCBiZSBhYmxlIHRvIHdvcmsgY29ycmVjdGx5LiAnLFxuICAgICAgJ0N1cnJlbnQgaGVpZ2h0IG9mIHRoZSByb290IGVsZW1lbnQgXFwnJyArIHJvb3RRdWVyeSArICdcXCcgaXMgJyxcbiAgICAgIGhlaWdodCArICdweCwgYW5kIG1vc3RseSBpdHMgaGVpZ2h0IHNob3VsZCBiZSBsZXNzIHRoYW4gdGhlICcsXG4gICAgICAndmlld3BvcnRcXCdzIGhlaWdodCAnICsgZ2xvYmFsLmlubmVySGVpZ2h0ICsgJ3B4LiBQbGVhc2UgJyxcbiAgICAgICdtYWtlIHN1cmUgdGhlIGhlaWdodCBpcyBjb3JyZWN0LidcbiAgICBdLmpvaW4oJycpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXQgKFdlZXgpIHtcbiAgY29uc3QgQ29tcG9uZW50ID0gV2VleC5Db21wb25lbnRcblxuICBmdW5jdGlvbiBSb290Q29tcG9uZW50IChkYXRhLCBub2RlVHlwZSkge1xuICAgIGNvbnN0IGlkID0gZGF0YS5yb290SWQgKyAnLXJvb3QnXG4gICAgY29uc3QgY20gPSBDb21wb25lbnRNYW5hZ2VyLmdldEluc3RhbmNlKGRhdGEuaW5zdGFuY2VJZClcblxuICAgIHRoaXMuZGF0YSA9IGRhdGFcblxuICAgIC8vIEluIHNvbWUgc2l0dWF0aW9uIHRoZSByb290IGNvbXBvbmVudCBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXNcbiAgICAvLyBpdHMgb3duIHR5cGUsIG90aGVyd2lzZSBpdCBoYXMgdG8gYmUgYSBkaXYgY29tcG9uZW50IGFzIGEgcm9vdC5cbiAgICBpZiAoIW5vZGVUeXBlKSB7XG4gICAgICBub2RlVHlwZSA9ICdkaXYnXG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbmZpZy52YWxpZFJvb3RzLmluZGV4T2Yobm9kZVR5cGUpID09PSAtMSkge1xuICAgICAgY29uc29sZS53YXJuKCdbaDUtcmVuZGVyXSB0aGUgcm9vdCBjb21wb25lbnQgdHlwZSBcXCcnICsgbm9kZVR5cGUgKyAnXFwnIGlzIG5vdCBvbmUgb2YgJ1xuICAgICAgICArICd0aGUgdHlwZXMgaW4gWycgKyBjb25maWcudmFsaWRSb290cyArICddIGxpc3QuIEl0IGlzIGF1dG8gZG93bmdyYWRlZCAnXG4gICAgICAgICsgJ3RvIFxcJ2RpdlxcJy4nKVxuICAgICAgbm9kZVR5cGUgPSAnZGl2J1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICghZ2xvYmFsLndlZXguZ2V0SW5zdGFuY2UoZGF0YS5pbnN0YW5jZUlkKS5lbWJlZCkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVuZGVyZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRldGVjdFJvb3RIZWlnaHQodGhpcylcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgfVxuICAgICAgIXRoaXMuZGF0YS5zdHlsZS5oZWlnaHQgJiYgKHRoaXMuZGF0YS5zdHlsZS5oZWlnaHQgPSAnMTAwJScpXG4gICAgfVxuXG4gICAgZGF0YS50eXBlID0gbm9kZVR5cGVcbiAgICBjb25zdCBjbXAgPSBjbS5jcmVhdGVFbGVtZW50KGRhdGEpXG4gICAgY21wLm5vZGUuaWQgPSBpZFxuICAgIHJldHVybiBjbXBcbiAgfVxuXG4gIFJvb3RDb21wb25lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlKVxuXG4gIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3Jvb3QnLCBSb290Q29tcG9uZW50KVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2Jhc2Uvcm9vdC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBpbml0IChXZWV4KSB7XG4gIGNvbnN0IENvbXBvbmVudCA9IFdlZXguQ29tcG9uZW50XG5cbiAgZnVuY3Rpb24gRGl2IChkYXRhLCBub2RlVHlwZSkge1xuICAgIENvbXBvbmVudC5jYWxsKHRoaXMsIGRhdGEsIG5vZGVUeXBlKVxuICAgIHRoaXMubm9kZS5jbGFzc0xpc3QuYWRkKCd3ZWV4LWNvbnRhaW5lcicpXG4gIH1cbiAgRGl2LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tcG9uZW50LnByb3RvdHlwZSlcblxuICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdkaXYnLCBEaXYpXG4gIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ2NvbnRhaW5lcicsIERpdilcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBpbml0IH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9iYXNlL2Rpdi5qc1xuICoqLyIsImltcG9ydCBJbWFnZSBmcm9tICcuL2ltYWdlJ1xuaW1wb3J0IFRleHQgZnJvbSAnLi90ZXh0J1xuLy8gaW1wb3J0IFZsaXN0IGZyb20gJy4vdmxpc3QnXG4vLyBpbXBvcnQgSGxpc3QgZnJvbSAnLi9obGlzdCdcbmltcG9ydCBTY3JvbGxhYmxlIGZyb20gJy4vc2Nyb2xsYWJsZScgICAvLyBUT0RPXG4vLyBpbXBvcnQgQ291bnRkb3duIGZyb20gJy4vY291bnRkb3duJ1xuLy8gaW1wb3J0IE1hcnF1ZWUgZnJvbSAnLi9tYXJxdWVlJ1xuaW1wb3J0IFNsaWRlciBmcm9tICcuL3NsaWRlcidcbmltcG9ydCBJbmRpY2F0b3IgZnJvbSAnLi9pbmRpY2F0b3InXG5pbXBvcnQgVGFiaGVhZGVyIGZyb20gJy4vdGFiaGVhZGVyJyAgICAgLy8gVE9ET1xuLy8gaW1wb3J0IFNjcm9sbGVyIGZyb20gJy4vc2Nyb2xsZXInXG5pbXBvcnQgSW5wdXQgZnJvbSAnLi9pbnB1dCdcbi8vIGltcG9ydCBTZWxlY3QgZnJvbSAnLi9zZWxlY3QnXG4vLyBpbXBvcnQgRGF0ZXBpY2tlciBmcm9tICcuL2RhdGVwaWNrZXInXG4vLyBpbXBvcnQgVGltZXBpY2tlciBmcm9tICcuL3RpbWVwaWNrZXInXG5pbXBvcnQgVmlkZW8gZnJvbSAnLi92aWRlbydcbmltcG9ydCBTd2l0Y2ggZnJvbSAnLi9zd2l0Y2gnXG5pbXBvcnQgQSBmcm9tICcuL2EnXG5pbXBvcnQgRW1iZWQgZnJvbSAnLi9lbWJlZCdcbi8vIGltcG9ydCBSZWZyZXNoIGZyb20gJy4vcmVmcmVzaCdcbi8vIGltcG9ydCBMb2FkaW5nIGZyb20gJy4vbG9hZGluZydcbmltcG9ydCBTcGlubmVyIGZyb20gJy4vc3Bpbm5lcidcbmltcG9ydCBXZWIgZnJvbSAnLi93ZWInXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogZnVuY3Rpb24gKFdlZXgpIHtcbiAgICBXZWV4Lmluc3RhbGwoSW1hZ2UpXG4gICAgV2VleC5pbnN0YWxsKFRleHQpXG4gICAgV2VleC5pbnN0YWxsKFNjcm9sbGFibGUpICAgIC8vIFRPRE9cbiAgICAvLyBXZWV4Lmluc3RhbGwoQ291bnRkb3duKVxuICAgIC8vIFdlZXguaW5zdGFsbChNYXJxdWVlKVxuICAgIFdlZXguaW5zdGFsbChTbGlkZXIpXG4gICAgV2VleC5pbnN0YWxsKEluZGljYXRvcilcbiAgICBXZWV4Lmluc3RhbGwoVGFiaGVhZGVyKSAgICAgLy8gVE9ET1xuICAgIFdlZXguaW5zdGFsbChJbnB1dClcbiAgICAvLyBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdsaXN0JywgVmxpc3QpXG4gICAgLy8gV2VleC5yZWdpc3RlckNvbXBvbmVudCgndmxpc3QnLCBWbGlzdClcbiAgICAvLyBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdobGlzdCcsIEhsaXN0KVxuICAgIC8vIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3Njcm9sbGVyJywgU2Nyb2xsZXIpXG4gICAgLy8gV2VleC5yZWdpc3RlckNvbXBvbmVudCgnc2VsZWN0JywgU2VsZWN0KVxuICAgIC8vIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ2RhdGVwaWNrZXInLCBEYXRlcGlja2VyKVxuICAgIC8vIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3RpbWVwaWNrZXInLCBUaW1lcGlja2VyKVxuICAgIFdlZXguaW5zdGFsbChWaWRlbylcbiAgICBXZWV4Lmluc3RhbGwoU3dpdGNoKVxuICAgIFdlZXguaW5zdGFsbChBKVxuICAgIFdlZXguaW5zdGFsbChFbWJlZClcbiAgICAvLyBXZWV4Lmluc3RhbGwoUmVmcmVzaClcbiAgICAvLyBXZWV4Lmluc3RhbGwoTG9hZGluZylcbiAgICBXZWV4Lmluc3RhbGwoU3Bpbm5lcilcbiAgICBXZWV4Lmluc3RhbGwoV2ViKVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvaW5kZXguanNcbiAqKi8iLCIvKiBnbG9iYWwgbGliICovXG5cbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgJy4vaW1hZ2UuY3NzJ1xuXG5jb25zdCBERUZBVUxUX1NJWkUgPSAyMDBcbmNvbnN0IFJFU0laRV9NT0RFUyA9IFsnc3RyZXRjaCcsICdjb3ZlcicsICdjb250YWluJ11cbmNvbnN0IERFRkFVTFRfUkVTSVpFX01PREUgPSAnc3RyZXRjaCdcblxuLyoqXG4gKiByZXNpemU6ICdjb3ZlcicgfCAnY29udGFpbicgfCAnc3RyZXRjaCcsIGRlZmF1bHQgaXMgJ3N0cmV0Y2gnXG4gKiBzcmM6IHVybFxuICovXG5jb25zdCBwcm90byA9IHtcbiAgY3JlYXRlICgpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtaW1nJywgJ3dlZXgtZWxlbWVudCcpXG4gICAgcmV0dXJuIG5vZGVcbiAgfSxcblxuICBjbGVhckF0dHIgKCkge1xuICAgIHRoaXMuc3JjID0gJydcbiAgICB0aGlzLm5vZGUuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJydcbiAgfVxufVxuXG5jb25zdCBhdHRyID0ge1xuICBzcmM6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAoIXRoaXMuc3JjKSB7XG4gICAgICB0aGlzLnNyYyA9IGxpYi5pbWcuZGVmYXVsdFNyY1xuICAgICAgdGhpcy5ub2RlLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoJyArIHRoaXMuc3JjICsgJyknXG4gICAgfVxuICAgIHRoaXMuZW5hYmxlTGF6eWxvYWQodmFsKVxuICB9LFxuXG4gIHJlc2l6ZTogZnVuY3Rpb24gKHZhbCkge1xuICAgIGlmIChSRVNJWkVfTU9ERVMuaW5kZXhPZih2YWwpID09PSAtMSkge1xuICAgICAgdmFsID0gJ3N0cmV0Y2gnXG4gICAgfVxuICAgIHRoaXMubm9kZS5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IHZhbCA9PT0gJ3N0cmV0Y2gnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcxMDAlIDEwMCUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhbFxuICB9XG59XG5cbmNvbnN0IHN0eWxlID0ge1xuICB3aWR0aDogZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKSAqIHRoaXMuZGF0YS5zY2FsZVxuICAgIGlmICh2YWwgPCAwIHx8IGlzTmFOKHZhbCkpIHtcbiAgICAgIHZhbCA9IERFRkFVTFRfU0laRVxuICAgIH1cbiAgICB0aGlzLm5vZGUuc3R5bGUud2lkdGggPSB2YWwgKyAncHgnXG4gIH0sXG5cbiAgaGVpZ2h0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFsID0gcGFyc2VGbG9hdCh2YWwpICogdGhpcy5kYXRhLnNjYWxlXG4gICAgaWYgKHZhbCA8IDAgfHwgaXNOYU4odmFsKSkge1xuICAgICAgdmFsID0gREVGQVVMVF9TSVpFXG4gICAgfVxuICAgIHRoaXMubm9kZS5zdHlsZS5oZWlnaHQgPSB2YWwgKyAncHgnXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdCAoV2VleCkge1xuICBjb25zdCBBdG9taWMgPSBXZWV4LkF0b21pY1xuICBjb25zdCBleHRlbmQgPSBXZWV4LnV0aWxzLmV4dGVuZFxuXG4gIGZ1bmN0aW9uIEltYWdlIChkYXRhKSB7XG4gICAgdGhpcy5yZXNpemUgPSBERUZBVUxUX1JFU0laRV9NT0RFXG4gICAgQXRvbWljLmNhbGwodGhpcywgZGF0YSlcbiAgfVxuICBJbWFnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUpXG4gIGV4dGVuZChJbWFnZS5wcm90b3R5cGUsIHByb3RvKVxuICBleHRlbmQoSW1hZ2UucHJvdG90eXBlLCB7IGF0dHIgfSlcbiAgZXh0ZW5kKEltYWdlLnByb3RvdHlwZSwge1xuICAgIHN0eWxlOiBleHRlbmQoT2JqZWN0LmNyZWF0ZShBdG9taWMucHJvdG90eXBlLnN0eWxlKSwgc3R5bGUpXG4gIH0pXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnaW1hZ2UnLCBJbWFnZSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBpbml0IH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9pbWFnZS9pbmRleC5qc1xuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW1hZ2UuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2ltYWdlLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2ltYWdlLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvaW1hZ2UvaW1hZ2UuY3NzXG4gKiogbW9kdWxlIGlkID0gMTQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi53ZWV4LWltZyB7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgYmFja2dyb3VuZC1zaXplOiAxMDAlIDEwMCU7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiA1MCU7XFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL2ltYWdlL2ltYWdlLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IERFRkFVTFRfRk9OVF9TSVpFID0gMzJcbmNvbnN0IERFRkFVTFRfVEVYVF9PVkVSRkxPVyA9ICdlbGxpcHNpcydcblxuY29uc3QgcHJvdG8gPSB7XG4gIGNyZWF0ZSAoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgbm9kZS5jbGFzc0xpc3QuYWRkKCd3ZWV4LWNvbnRhaW5lcicpXG4gICAgbm9kZS5zdHlsZS5mb250U2l6ZSA9IERFRkFVTFRfRk9OVF9TSVpFICogdGhpcy5kYXRhLnNjYWxlICsgJ3B4J1xuICAgIHRoaXMudGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICAvLyBHaXZlIHRoZSBkZXZlbG9wZXJzIHRoZSBhYmlsaXR5IHRvIGNvbnRyb2wgc3BhY2VcbiAgICAvLyBhbmQgbGluZS1icmVha2Vycy5cbiAgICB0aGlzLnRleHROb2RlLnN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnXG4gICAgdGhpcy50ZXh0Tm9kZS5zdHlsZS53b3JkV3JhcCA9ICdicmVhay13b3JkJ1xuICAgIHRoaXMudGV4dE5vZGUuc3R5bGUuZGlzcGxheSA9ICctd2Via2l0LWJveCdcbiAgICB0aGlzLnRleHROb2RlLnN0eWxlLndlYmtpdEJveE9yaWVudCA9ICd2ZXJ0aWNhbCdcbiAgICB0aGlzLnN0eWxlLmxpbmVzLmNhbGwodGhpcywgdGhpcy5kYXRhLnN0eWxlLmxpbmVzKVxuICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy50ZXh0Tm9kZSlcbiAgICByZXR1cm4gbm9kZVxuICB9LFxuXG4gIGNsZWFyQXR0ciAoKSB7XG4gICAgdGhpcy5ub2RlLmZpcnN0Q2hpbGQudGV4dENvbnRlbnQgPSAnJ1xuICB9XG59XG5cbmNvbnN0IGF0dHIgPSB7XG4gIHZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBjb25zdCBzcGFuID0gdGhpcy5ub2RlLmZpcnN0Q2hpbGRcbiAgICBzcGFuLmlubmVySFRNTCA9ICcnXG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc3Bhbi50ZXh0Q29udGVudCA9IHZhbHVlXG4gICAgLyoqXG4gICAgICogRGV2ZWxvcGVycyBhcmUgc3VwcG9zZWQgdG8gaGF2ZSB0aGUgYWJpbGl0eSB0byBicmVhayB0ZXh0XG4gICAgICogbGluZXMgbWFudWFsbHkuIFVzaW5nIGBgJm5ic3A7YGAgdG8gcmVwbGFjZSB0ZXh0IHNwYWNlIGlzXG4gICAgICogbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgYGAtd2Via2l0LWxpbmUtY2xhbXBgYC4gVGhlcmVmb3JcbiAgICAgKiB3ZSB1c2UgYGB3aGl0ZS1zcGFjZTogbm8td3JhcGBgIGluc3RlYWQgKGluc3RlYWQgb2YgdGhlXG4gICAgICogY29kZSBiZWxsb3cpLlxuXG4gICAgICBjb25zdCBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gICAgICAgIHRleHQuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyKVxuICAgICAgICAgIGNvbnN0IHNwYWNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpXG4gICAgICAgICAgc3BhY2UuaW5uZXJIVE1MID0gJyZuYnNwOydcbiAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKHNwYWNlKVxuICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQodGV4dE5vZGUpXG4gICAgICAgIH0pXG4gICAgICAgIGZyYWcucmVtb3ZlQ2hpbGQoZnJhZy5maXJzdENoaWxkKVxuICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJykpXG4gICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoZnJhZylcbiAgICAgIH0pXG4gICAgICBzcGFuLnJlbW92ZUNoaWxkKHNwYW4uZmlyc3RDaGlsZClcbiAgICAgKi9cbiAgfVxufVxuXG5jb25zdCBzdHlsZSA9IHtcbiAgbGluZXM6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YWwgPSBwYXJzZUludCh2YWwpXG4gICAgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodmFsIDw9IDApIHtcbiAgICAgIHRoaXMudGV4dE5vZGUuc3R5bGUudGV4dE92ZXJmbG93ID0gJydcbiAgICAgIHRoaXMudGV4dE5vZGUuc3R5bGUub3ZlcmZsb3cgPSAndmlzaWJsZSdcbiAgICAgIHRoaXMudGV4dE5vZGUuc3R5bGUud2Via2l0TGluZUNsYW1wID0gJydcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBzdHlsZSA9IHRoaXMuZGF0YSA/IHRoaXMuZGF0YS5zdHlsZSA6IG51bGxcbiAgICAgIHRoaXMudGV4dE5vZGUuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJ1xuICAgICAgdGhpcy50ZXh0Tm9kZS5zdHlsZS50ZXh0T3ZlcmZsb3cgPSBzdHlsZVxuICAgICAgICA/IHN0eWxlLnRleHRPdmVyZmxvd1xuICAgICAgICA6IERFRkFVTFRfVEVYVF9PVkVSRkxPV1xuICAgICAgdGhpcy50ZXh0Tm9kZS5zdHlsZS53ZWJraXRMaW5lQ2xhbXAgPSB2YWxcbiAgICB9XG4gIH0sXG5cbiAgdGV4dE92ZXJmbG93OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdGhpcy50ZXh0Tm9kZS5zdHlsZS50ZXh0T3ZlcmZsb3cgPSB2YWxcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0IChXZWV4KSB7XG4gIGNvbnN0IEF0b21pYyA9IFdlZXguQXRvbWljXG4gIGNvbnN0IGV4dGVuZCA9IFdlZXgudXRpbHMuZXh0ZW5kXG5cbiAgLy8gYXR0clxuICAvLyAgLSB2YWx1ZTogdGV4dCBjb250ZW50LlxuICAvLyBzdHlsZVxuICAvLyAgLSBsaW5lczogbWF4aW11bSBsaW5lcyBvZiB0aGUgdGV4dC5cbiAgZnVuY3Rpb24gVGV4dCAoZGF0YSkge1xuICAgIEF0b21pYy5jYWxsKHRoaXMsIGRhdGEpXG4gIH1cbiAgVGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUpXG4gIGV4dGVuZChUZXh0LnByb3RvdHlwZSwgcHJvdG8pXG4gIGV4dGVuZChUZXh0LnByb3RvdHlwZSwgeyBhdHRyIH0pXG4gIGV4dGVuZChUZXh0LnByb3RvdHlwZSwge1xuICAgIHN0eWxlOiBleHRlbmQoT2JqZWN0LmNyZWF0ZShBdG9taWMucHJvdG90eXBlLnN0eWxlKSwgc3R5bGUpXG4gIH0pXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgndGV4dCcsIFRleHQpXG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgaW5pdCB9XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvdGV4dC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgbGlzdCBmcm9tICcuL2xpc3QnXG5pbXBvcnQgc2Nyb2xsZXIgZnJvbSAnLi9zY3JvbGxlcidcbmltcG9ydCByZWZyZXNoIGZyb20gJy4vcmVmcmVzaCdcbmltcG9ydCBsb2FkaW5nIGZyb20gJy4vbG9hZGluZydcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBmdW5jdGlvbiAoV2VleCkge1xuICAgIFdlZXguaW5zdGFsbChsaXN0KVxuICAgIFdlZXguaW5zdGFsbChzY3JvbGxlcilcbiAgICBXZWV4Lmluc3RhbGwocmVmcmVzaClcbiAgICBXZWV4Lmluc3RhbGwobG9hZGluZylcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IFZsaXN0IGZyb20gJy4vdmxpc3QnXG5pbXBvcnQgSGxpc3QgZnJvbSAnLi9obGlzdCdcblxuZnVuY3Rpb24gaW5pdCAoV2VleCkge1xuICBXZWV4Lmluc3RhbGwoVmxpc3QpXG4gIFdlZXguaW5zdGFsbChIbGlzdClcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBpbml0IH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL2xpc3QvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IGxpc3RNb2R1bGUgZnJvbSAnLi9saXN0J1xuXG5mdW5jdGlvbiBpbml0IChXZWV4KSB7XG4gIGNvbnN0IExpc3QgPSBsaXN0TW9kdWxlLmluaXQoV2VleClcblxuICBmdW5jdGlvbiBWbGlzdCAoZGF0YSwgbm9kZVR5cGUpIHtcbiAgICBkYXRhLmF0dHIuZGlyZWN0aW9uID0gJ3YnXG4gICAgTGlzdC5jYWxsKHRoaXMsIGRhdGEsIG5vZGVUeXBlKVxuICB9XG4gIFZsaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGlzdC5wcm90b3R5cGUpXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnbGlzdCcsIFZsaXN0KVxuICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCd2bGlzdCcsIFZsaXN0KVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvbGlzdC92bGlzdC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgc2Nyb2xsYWJsZU1vZHVsZSBmcm9tICcuLi9zY3JvbGxhYmxlJ1xuXG5jb25zdCBhdmFpbGFibGVDaGlsZHJlblR5cGVzID0gWydjZWxsJywgJ2xvYWRpbmcnLCAncmVmcmVzaCddXG5cbmZ1bmN0aW9uIGdldFByb3RvIChTY3JvbGxhYmxlKSB7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlICgpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBTY3JvbGxhYmxlLnByb3RvdHlwZS5jcmVhdGUuY2FsbCh0aGlzKVxuICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCdsaXN0LXdyYXAnKVxuICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2xpc3QtZWxlbWVudCcpXG4gICAgICByZXR1cm4gbm9kZVxuICAgIH0sXG5cbiAgICBjcmVhdGVDaGlsZHJlbiAoKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlbiB8fCBbXVxuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBjb25zdCB0eXBlID0gZGF0YS50eXBlXG4gICAgICAgIGlmIChhdmFpbGFibGVDaGlsZHJlblR5cGVzLmluZGV4T2YodHlwZSkgPT09IC0xKSB7XG4gICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdbaDUtcmVuZGVyXSBpbnZhbGlkIGNoaWxkIHR5cGUgXCInXG4gICAgICAgICAgLy8gICArIHR5cGUgKyAnXCIgZm9yIGxpc3QuJylcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1toNS1yZW5kZXJdIGludmFsaWQgY2hpbGQgdHlwZSBcIidcbiAgICAgICAgICAgICsgdHlwZSArICdcIiBmb3IgbGlzdC4nKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcmV0dXJuIFNjcm9sbGFibGUucHJvdG90eXBlLmNyZWF0ZUNoaWxkcmVuLmNhbGwodGhpcylcbiAgICB9LFxuXG4gICAgYXBwZW5kQ2hpbGQgKGRhdGEpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBkYXRhLnR5cGVcbiAgICAgIGlmIChhdmFpbGFibGVDaGlsZHJlblR5cGVzLmluZGV4T2YodHlwZSkgPT09IC0xKSB7XG4gICAgICAgIC8vIHRocm93IG5ldyBFcnJvcignW2g1LXJlbmRlcl0gaW52YWxpZCBjaGlsZCB0eXBlIFwiJ1xuICAgICAgICAvLyAgICsgdHlwZSArICdcIiBmb3IgbGlzdC4nKVxuICAgICAgICBjb25zb2xlLndhcm4oJ1toNS1yZW5kZXJdIGludmFsaWQgY2hpbGQgdHlwZSBcIidcbiAgICAgICAgICArIHR5cGUgKyAnXCIgZm9yIGxpc3QuJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBTY3JvbGxhYmxlLnByb3RvdHlwZS5hcHBlbmRDaGlsZC5jYWxsKHRoaXMsIGRhdGEpXG4gICAgfSxcblxuICAgIGluc2VydEJlZm9yZSAoY2hpbGQsIGJlZm9yZSkge1xuICAgICAgY29uc3QgdHlwZSA9IGNoaWxkLmRhdGEudHlwZVxuICAgICAgaWYgKGF2YWlsYWJsZUNoaWxkcmVuVHlwZXMuaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcbiAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdbaDUtcmVuZGVyXSBpbnZhbGlkIGNoaWxkIHR5cGUgXCInXG4gICAgICAgIC8vICAgKyB0eXBlICsgJ1wiIGZvciBsaXN0LicpXG4gICAgICAgIGNvbnNvbGUud2FybignW2g1LXJlbmRlcl0gaW52YWxpZCBjaGlsZCB0eXBlIFwiJ1xuICAgICAgICAgICsgdHlwZSArICdcIiBmb3IgbGlzdC4nKVxuICAgICAgfVxuICAgICAgcmV0dXJuIFNjcm9sbGFibGUucHJvdG90eXBlLmluc2VydEJlZm9yZS5jYWxsKHRoaXMsIGNoaWxkLCBiZWZvcmUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXQgKFdlZXgpIHtcbiAgY29uc3QgU2Nyb2xsYWJsZSA9IHNjcm9sbGFibGVNb2R1bGUuaW5pdChXZWV4KVxuICBmdW5jdGlvbiBMaXN0IChkYXRhLCBub2RlVHlwZSkge1xuICAgIFNjcm9sbGFibGUuY2FsbCh0aGlzLCBkYXRhLCBub2RlVHlwZSlcbiAgfVxuICBjb25zdCBleHRlbmQgPSBXZWV4LnV0aWxzLmV4dGVuZFxuXG4gIExpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY3JvbGxhYmxlLnByb3RvdHlwZSlcbiAgZXh0ZW5kKExpc3QucHJvdG90eXBlLCBnZXRQcm90byhTY3JvbGxhYmxlKSlcblxuICByZXR1cm4gTGlzdFxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvbGlzdC9saXN0LmpzXG4gKiovIiwiLyogZ2xvYmFsIGxpYiAqL1xuXG4ndXNlIHN0cmljdCdcblxucmVxdWlyZSgnLi9zY3JvbGxhYmxlLmNzcycpXG5yZXF1aXJlKCcuL3Njcm9sbCcpXG5cbi8vIGxpYi5zY3JvbGwgZXZlbnRzOlxuLy8gIC0gc2Nyb2xsc3RhcnRcbi8vICAtIHNjcm9sbGluZ1xuLy8gIC0gcHVsbGRvd25lbmRcbi8vICAtIHB1bGx1cGVuZFxuLy8gIC0gcHVsbGxlZnRlbmRcbi8vICAtIHB1bGxyaWdodGVuZFxuLy8gIC0gcHVsbGRvd25cbi8vICAtIHB1bGx1cFxuLy8gIC0gcHVsbGxlZnRcbi8vICAtIHB1bGxyaWdodFxuLy8gIC0gY29udGVudHJlZnJlc2hcblxuY29uc3QgZGlyZWN0aW9uTWFwID0ge1xuICBoOiBbJ3JvdycsICdob3Jpem9udGFsJywgJ2gnLCAneCddLFxuICB2OiBbJ2NvbHVtbicsICd2ZXJ0aWNhbCcsICd2JywgJ3knXVxufVxuXG5jb25zdCBERUZBVUxUX0RJUkVDVElPTiA9ICdjb2x1bW4nXG5jb25zdCBERUZBVUxUX0xPQURfTU9SRV9PRkZTRVQgPSAwXG5cbmZ1bmN0aW9uIHJlZnJlc2hXaGVuRG9tUmVuZGVyZW5kIChjb21wKSB7XG4gIGlmICghY29tcC5yZW5kZXJlbmRIYW5kbGVyKSB7XG4gICAgY29tcC5yZW5kZXJlbmRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29tcC5zY3JvbGxlci5yZWZyZXNoKClcbiAgICB9XG4gIH1cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbmRlcmVuZCcsIGNvbXAucmVuZGVyZW5kSGFuZGxlcilcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRzIChjb21wKSB7XG4gIGlmIChjb21wLnJlbmRlcmVuZEhhbmRsZXIpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVuZGVyZW5kJywgY29tcC5yZW5kZXJlbmRIYW5kbGVyKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFByb3RvIChXZWV4KSB7XG4gIGNvbnN0IENvbXBvbmVudCA9IFdlZXguQ29tcG9uZW50XG5cbiAgZnVuY3Rpb24gY3JlYXRlIChub2RlVHlwZSkge1xuICAgIGNvbnN0IFNjcm9sbCA9IGxpYi5zY3JvbGxcbiAgICBjb25zdCBub2RlID0gQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGUuY2FsbCh0aGlzLCBub2RlVHlwZSlcbiAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtY29udGFpbmVyJywgJ3Njcm9sbGFibGUtd3JhcCcpXG4gICAgdGhpcy5zY3JvbGxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcbiAgICAgICd3ZWV4LWNvbnRhaW5lcicsXG4gICAgICAnc2Nyb2xsYWJsZS1lbGVtZW50JyxcbiAgICAgICdkaXItJyArIHRoaXMuZGlyZWN0aW9uXG4gICAgKVxuXG4gICAgdGhpcy5zY3JvbGxFbGVtZW50LnN0eWxlLndlYmtpdEJveE9yaWVudCA9IGRpcmVjdGlvbk1hcFt0aGlzLmRpcmVjdGlvbl1bMV1cbiAgICB0aGlzLnNjcm9sbEVsZW1lbnQuc3R5bGUud2Via2l0RmxleERpcmVjdGlvbiA9IGRpcmVjdGlvbk1hcFt0aGlzLmRpcmVjdGlvbl1bMF1cbiAgICB0aGlzLnNjcm9sbEVsZW1lbnQuc3R5bGUuZmxleERpcmVjdGlvbiA9IGRpcmVjdGlvbk1hcFt0aGlzLmRpcmVjdGlvbl1bMF1cblxuICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxFbGVtZW50KVxuICAgIHRoaXMuc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsKHtcbiAgICAgIC8vIGlmIHRoZSBkaXJlY3Rpb24gaXMgeCwgdGhlbiB0aGUgYm91bmRpbmcgcmVjdCBvZiB0aGUgc2Nyb2xsIGVsZW1lbnRcbiAgICAgIC8vIHNob3VsZCBiZSBnb3QgYnkgdGhlICdSYW5nZScgQVBJIG90aGVyIHRoYW4gdGhlICdnZXRCb3VuZGluZ0NsaWVudFJlY3QnXG4gICAgICAvLyBBUEksIGJlY2F1c2UgdGhlIHdpZHRoIG91dHNpZGUgdGhlIHZpZXdwb3J0IHdvbid0IGJlIGNvdW50IGluIGJ5XG4gICAgICAvLyAnZ2V0Qm91bmRpbmdDbGllbnRSZWN0Jy5cbiAgICAgIC8vIE90aGVyd2lzZSBzaG91bGQgdXNlIHRoZSBlbGVtZW50IHJlY3QgaW4gY2FzZSB0aGVyZSBpcyBhIGNoaWxkIHNjcm9sbGVyXG4gICAgICAvLyBvciBsaXN0IGluIHRoaXMgc2Nyb2xsZXIuIElmIHVzaW5nICdSYW5nZScsIHRoZSB3aG9sZSBzY3JvbGwgZWxlbWVudFxuICAgICAgLy8gaW5jbHVkaW5nIHRoZSBoaWRpbmcgcGFydCB3aWxsIGJlIGNvdW50IGluIHRoZSByZWN0LlxuICAgICAgdXNlRWxlbWVudFJlY3Q6IHRoaXMuZGlyZWN0aW9uID09PSAndicsXG4gICAgICBzY3JvbGxFbGVtZW50OiB0aGlzLnNjcm9sbEVsZW1lbnQsXG4gICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uID09PSAnaCcgPyAneCcgOiAneSdcbiAgICB9KVxuICAgIHRoaXMuc2Nyb2xsZXIuaW5pdCgpXG4gICAgdGhpcy5vZmZzZXQgPSAwXG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICAgIGNvbnN0IHBhcmVudFJlZiA9IHRoaXMuZGF0YS5yZWZcbiAgICBjb25zdCBjb21wb25lbnRNYW5hZ2VyID0gdGhpcy5nZXRDb21wb25lbnRNYW5hZ2VyKClcbiAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICAgICAgbGV0IGlzRmxleCA9IGZhbHNlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkcmVuW2ldLmluc3RhbmNlSWQgPSB0aGlzLmRhdGEuaW5zdGFuY2VJZFxuICAgICAgICBjaGlsZHJlbltpXS5zY2FsZSA9IHRoaXMuZGF0YS5zY2FsZVxuICAgICAgICBjb25zdCBjaGlsZCA9IGNvbXBvbmVudE1hbmFnZXIuY3JlYXRlRWxlbWVudChjaGlsZHJlbltpXSlcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQubm9kZSlcbiAgICAgICAgY2hpbGQucGFyZW50UmVmID0gcGFyZW50UmVmXG4gICAgICAgIGlmICghaXNGbGV4XG4gICAgICAgICAgICAmJiBjaGlsZC5kYXRhLnN0eWxlXG4gICAgICAgICAgICAmJiBjaGlsZC5kYXRhLnN0eWxlLmhhc093blByb3BlcnR5KCdmbGV4JylcbiAgICAgICAgICApIHtcbiAgICAgICAgICBpc0ZsZXggPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudC5hcHBlbmRDaGlsZChmcmFnbWVudClcbiAgICB9XG4gICAgLy8gd2FpdCBmb3IgZnJhZ21lbnQgdG8gYXBwZW5kZWQgb24gc2Nyb2xsRWxlbWVudCBvbiBVSSB0aHJlYWQuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnNjcm9sbGVyLnJlZnJlc2goKVxuICAgIH0uYmluZCh0aGlzKSwgMClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZENoaWxkIChkYXRhKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgICBjb25zdCBjb21wb25lbnRNYW5hZ2VyID0gdGhpcy5nZXRDb21wb25lbnRNYW5hZ2VyKClcbiAgICBjb25zdCBjaGlsZCA9IGNvbXBvbmVudE1hbmFnZXIuY3JlYXRlRWxlbWVudChkYXRhKVxuICAgIHRoaXMuc2Nyb2xsRWxlbWVudC5hcHBlbmRDaGlsZChjaGlsZC5ub2RlKVxuXG4gICAgLy8gd2FpdCBmb3IgVUkgdGhyZWFkIHRvIHVwZGF0ZS5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc2Nyb2xsZXIucmVmcmVzaCgpXG4gICAgfS5iaW5kKHRoaXMpLCAwKVxuXG4gICAgLy8gdXBkYXRlIHRoaXMuZGF0YS5jaGlsZHJlblxuICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdGhpcy5kYXRhLmNoaWxkcmVuID0gW2RhdGFdXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2hpbGRyZW4ucHVzaChkYXRhKVxuICAgIH1cblxuICAgIHJldHVybiBjaGlsZFxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChjaGlsZCwgYmVmb3JlKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgICBsZXQgaSA9IDBcbiAgICBsZXQgaXNBcHBlbmQgPSBmYWxzZVxuXG4gICAgLy8gdXBkYXRlIHRoaXMuZGF0YS5jaGlsZHJlblxuICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCAhYmVmb3JlKSB7XG4gICAgICBpc0FwcGVuZCA9IHRydWVcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsZXQgbFxuICAgICAgZm9yIChsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbltpXS5yZWYgPT09IGJlZm9yZS5kYXRhLnJlZikge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID09PSBsKSB7XG4gICAgICAgIGlzQXBwZW5kID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0FwcGVuZCkge1xuICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LmFwcGVuZENoaWxkKGNoaWxkLm5vZGUpXG4gICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkLmRhdGEpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgcmVmcmVzaExvYWRpbmdQbGFjZWhvbGRlciA9IGJlZm9yZS5yZWZyZXNoUGxhY2Vob2xkZXJcbiAgICAgICAgfHwgYmVmb3JlLmxvYWRpbmdQbGFjZWhvbGRlclxuICAgICAgaWYgKHJlZnJlc2hMb2FkaW5nUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50Lmluc2VydEJlZm9yZShjaGlsZC5ub2RlLCByZWZyZXNoTG9hZGluZ1BsYWNlaG9sZGVyKVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYmVmb3JlLmZpeGVkUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50Lmluc2VydEJlZm9yZShjaGlsZC5ub2RlLCBiZWZvcmUuZml4ZWRQbGFjZWhvbGRlcilcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJlZm9yZS5zdGlja3lQbGFjZWhvbGRlcikge1xuICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLm5vZGUsIGJlZm9yZS5zdGlja3lQbGFjZWhvbGRlcilcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLm5vZGUsIGJlZm9yZS5ub2RlKVxuICAgICAgfVxuICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDAsIGNoaWxkLmRhdGEpXG4gICAgfVxuXG4gICAgLy8gd2FpdCBmb3IgVUkgdGhyZWFkIHRvIHVwZGF0ZS5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc2Nyb2xsZXIucmVmcmVzaCgpXG4gICAgfS5iaW5kKHRoaXMpLCAwKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKGNoaWxkKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgICAvLyByZW1vdmUgZnJvbSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgICBsZXQgaSA9IDBcbiAgICBjb25zdCBjb21wb25lbnRNYW5hZ2VyID0gdGhpcy5nZXRDb21wb25lbnRNYW5hZ2VyKClcbiAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBsZXQgbFxuICAgICAgZm9yIChsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbltpXS5yZWYgPT09IGNoaWxkLmRhdGEucmVmKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPCBsKSB7XG4gICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAxKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyByZW1vdmUgZnJvbSBjb21wb25lbnRNYXAgcmVjdXJzaXZlbHlcbiAgICBjb21wb25lbnRNYW5hZ2VyLnJlbW92ZUNvbXBvbmVudChjaGlsZC5kYXRhLnJlZilcbiAgICBjb25zdCByZWZyZXNoTG9hZGluZ1BsYWNlaG9sZGVyID0gY2hpbGQucmVmcmVzaFBsYWNlaG9sZGVyXG4gICAgICB8fCBjaGlsZC5sb2FkaW5nUGxhY2Vob2xkZXJcbiAgICBjaGlsZC51bnNldFBvc2l0aW9uKClcbiAgICBpZiAocmVmcmVzaExvYWRpbmdQbGFjZWhvbGRlcikge1xuICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LnJlbW92ZUNoaWxkKHJlZnJlc2hMb2FkaW5nUGxhY2Vob2xkZXIpXG4gICAgfVxuICAgIGNoaWxkLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZC5ub2RlKVxuXG4gICAgLy8gd2FpdCBmb3IgVUkgdGhyZWFkIHRvIHVwZGF0ZS5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuc2Nyb2xsZXIucmVmcmVzaCgpXG4gICAgfS5iaW5kKHRoaXMpLCAwKVxuICB9XG5cbiAgZnVuY3Rpb24gYmluZEV2ZW50cyAoZXZ0cykge1xuICAgIENvbXBvbmVudC5wcm90b3R5cGUuYmluZEV2ZW50cy5jYWxsKHRoaXMsIGV2dHMpXG4gICAgLy8gdG8gZW5hYmxlIGxhenlsb2FkIGZvciBJbWFnZXNcbiAgICB0aGlzLnNjcm9sbGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbGluZycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBjb25zdCBzbyA9IGUuc2Nyb2xsT2JqXG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSBzby5nZXRTY3JvbGxUb3AoKVxuICAgICAgY29uc3Qgc2Nyb2xsTGVmdCA9IHNvLmdldFNjcm9sbExlZnQoKVxuICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5kaXJlY3Rpb24gPT09ICd2JyA/IHNjcm9sbFRvcCA6IHNjcm9sbExlZnRcbiAgICAgIGNvbnN0IGRpZmYgPSBvZmZzZXQgLSB0aGlzLm9mZnNldFxuICAgICAgbGV0IGRpclxuICAgICAgaWYgKGRpZmYgPj0gMCkge1xuICAgICAgICBkaXIgPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ3YnID8gJ3VwJyA6ICdsZWZ0J1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRpciA9IHRoaXMuZGlyZWN0aW9uID09PSAndicgPyAnZG93bicgOiAncmlnaHQnXG4gICAgICB9XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3Njcm9sbCcsIHtcbiAgICAgICAgb3JpZ2luYWxUeXBlOiAnc2Nyb2xsaW5nJyxcbiAgICAgICAgc2Nyb2xsVG9wOiBzby5nZXRTY3JvbGxUb3AoKSxcbiAgICAgICAgc2Nyb2xsTGVmdDogc28uZ2V0U2Nyb2xsTGVmdCgpLFxuICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgZGlyZWN0aW9uOiBkaXJcbiAgICAgIH0sIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgfSlcbiAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0XG5cbiAgICAgIC8vIGZpcmUgbG9hZG1vcmUgZXZlbnQuXG4gICAgICBjb25zdCBsZWZ0RGlzdCA9IE1hdGguYWJzKHNvLm1heFNjcm9sbE9mZnNldCkgLSB0aGlzLm9mZnNldFxuICAgICAgaWYgKGxlZnREaXN0IDw9IHRoaXMubG9hZG1vcmVvZmZzZXQgJiYgdGhpcy5pc0F2YWlsYWJsZVRvRmlyZWxvYWRtb3JlKSB7XG4gICAgICAgIHRoaXMuaXNBdmFpbGFibGVUb0ZpcmVsb2FkbW9yZSA9IGZhbHNlXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnbG9hZG1vcmUnKVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGVmdERpc3QgPiB0aGlzLmxvYWRtb3Jlb2Zmc2V0ICYmICF0aGlzLmlzQXZhaWxhYmxlVG9GaXJlbG9hZG1vcmUpIHtcbiAgICAgICAgdGhpcy5pc0F2YWlsYWJsZVRvRmlyZWxvYWRtb3JlID0gdHJ1ZVxuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQXBwZW5kICgpIHtcbiAgICByZWZyZXNoV2hlbkRvbVJlbmRlcmVuZCh0aGlzKVxuICB9XG5cbiAgZnVuY3Rpb24gb25SZW1vdmUgKCkge1xuICAgIHJlbW92ZUV2ZW50cyh0aGlzKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGUsXG4gICAgY3JlYXRlQ2hpbGRyZW4sXG4gICAgYXBwZW5kQ2hpbGQsXG4gICAgaW5zZXJ0QmVmb3JlLFxuICAgIHJlbW92ZUNoaWxkLFxuICAgIGJpbmRFdmVudHMsXG4gICAgb25BcHBlbmQsXG4gICAgb25SZW1vdmVcbiAgfVxufVxuXG5jb25zdCBhdHRyID0ge1xuICBsb2FkbW9yZW9mZnNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKVxuICAgIGlmICh2YWwgPCAwIHx8IGlzTmFOKHZhbCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignW2g1LXJlbmRlcl0gaW52YWxpZGEnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMubG9hZG1vcmVvZmZzZXQgPSB2YWxcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0IChXZWV4KSB7XG4gIGNvbnN0IENvbXBvbmVudCA9IFdlZXguQ29tcG9uZW50XG4gIGNvbnN0IGV4dGVuZCA9IFdlZXgudXRpbHMuZXh0ZW5kXG5cbiAgLy8gYXR0cnM6XG4gIC8vICAtIGxvYWRtb3Jlb2Zmc2V0OiB1cGRhdGFibGVcbiAgLy8gIC0gc2Nyb2xsLWRpcmVjaXRvbjogbm9uZXx2ZXJ0aWNhbHxob3Jpem9udGFsIChkZWZhdWx0IGlzIHZlcnRpY2FsKVxuICAvLyAgLSBzaG93LXNjcm9sbGJhcjogdHJ1ZXxmYWxzZSAoZGVmYXVsdCBpcyB0cnVlKVxuICBmdW5jdGlvbiBTY3JvbGxhYmxlIChkYXRhLCBub2RlVHlwZSkge1xuICAgIHRoaXMubG9hZG1vcmVvZmZzZXQgPSBERUZBVUxUX0xPQURfTU9SRV9PRkZTRVRcbiAgICB0aGlzLmlzQXZhaWxhYmxlVG9GaXJlbG9hZG1vcmUgPSB0cnVlXG4gICAgY29uc3QgYXR0cnMgPSBkYXRhLmF0dHIgfHwge31cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBhdHRycy5zY3JvbGxEaXJlY3Rpb25cbiAgICAgIHx8IGF0dHJzLmRpcmVjdGlvblxuICAgICAgfHwgREVGQVVMVF9ESVJFQ1RJT05cbiAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbk1hcC5oLmluZGV4T2YoZGlyZWN0aW9uKSA9PT0gLTFcbiAgICAgID8gJ3YnXG4gICAgICA6ICdoJ1xuICAgIHRoaXMuc2hvd1Njcm9sbGJhciA9IGF0dHJzLnNob3dTY3JvbGxiYXIgfHwgdHJ1ZVxuICAgIENvbXBvbmVudC5jYWxsKHRoaXMsIGRhdGEsIG5vZGVUeXBlKVxuICB9XG4gIFNjcm9sbGFibGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlKVxuICBleHRlbmQoU2Nyb2xsYWJsZS5wcm90b3R5cGUsIGdldFByb3RvKFdlZXgpKVxuICBleHRlbmQoU2Nyb2xsYWJsZS5wcm90b3R5cGUsIHsgYXR0ciB9KVxuICByZXR1cm4gU2Nyb2xsYWJsZVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvc2Nyb2xsYWJsZS5qc1xuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc2Nyb2xsYWJsZS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc2Nyb2xsYWJsZS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zY3JvbGxhYmxlLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9zY3JvbGxhYmxlLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuc2Nyb2xsYWJsZS13cmFwIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuLnNjcm9sbGFibGUtZWxlbWVudC5ob3Jpem9udGFsIHtcXG4gIC13ZWJraXQtYm94LW9yaWVudDogaG9yaXpvbnRhbDtcXG4gIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxufVxcbi5zY3JvbGxhYmxlLWVsZW1lbnQudmVydGljYWwge1xcbiAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcXG4gIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvc2Nyb2xsYWJsZS5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGVzbGludC1kaXNhYmxlICovXG5cbnJlcXVpcmUoJy4vbW90aW9uJylcblxudmFyIGRvYyA9IHdpbmRvdy5kb2N1bWVudFxudmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnRcbnZhciBzY3JvbGxPYmpzID0ge31cbnZhciBwbHVnaW5zID0ge31cbnZhciBkcHIgPSB3aW5kb3cuZHByXG4gIHx8ICghIXdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9pUGhvbmV8aVBhZHxpUG9kLylcbiAgICA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCAvIHdpbmRvdy5zY3JlZW4uYXZhaWxXaWR0aFxuICAgIDogMSlcbnZhciBpbmVydGlhQ29lZmZpY2llbnQgPSB7XG4gIG5vcm1hbDogWzIgKiBkcHIsIDAuMDAxNSAqIGRwcl0sXG4gIHNsb3c6IFsxLjUgKiBkcHIsIDAuMDAzICogZHByXSxcbiAgdmVyeXNsb3c6IFsxLjUgKiBkcHIsIDAuMDA1ICogZHByXVxufVxudmFyIHRpbWVGdW5jdGlvbiA9IHtcbiAgZWFzZTogWy4yNSwuMSwuMjUsMV0sXG4gIGxpbmVyOiBbMCwwLDEsMV0sXG4gICdlYXNlLWluJzogWy40MiwwLDEsMV0sXG4gICdlYXNlLW91dCc6IFswLDAsLjU4LDFdLFxuICAnZWFzZS1pbi1vdXQnOiBbLjQyLDAsLjU4LDFdXG59XG52YXIgRmlyZWZveCA9ICEhdWEubWF0Y2goL0ZpcmVmb3gvaSlcbnZhciBJRU1vYmlsZSA9ICEhdWEubWF0Y2goL0lFTW9iaWxlL2kpXG52YXIgY3NzUHJlZml4ID0gRmlyZWZveCA/ICctbW96LScgOiBJRU1vYmlsZSA/ICctbXMtJyA6ICctd2Via2l0LSdcbnZhciBzdHlsZVByZWZpeCA9IEZpcmVmb3ggPyAnTW96JyA6IElFTW9iaWxlID8gJ21zJyA6ICd3ZWJraXQnXG5cbmZ1bmN0aW9uIGRlYnVnTG9nKCkge1xuICBpZiAobGliLnNjcm9sbC5vdXRwdXREZWJ1Z0xvZykge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpIHtcbiAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBpZiAoIXJlY3QpIHtcbiAgICByZWN0ID0ge31cbiAgICByZWN0LndpZHRoID0gZWwub2Zmc2V0V2lkdGhcbiAgICByZWN0LmhlaWdodCA9IGVsLm9mZnNldEhlaWdodFxuXG4gICAgcmVjdC5sZWZ0ID0gZWwub2Zmc2V0TGVmdFxuICAgIHJlY3QudG9wID0gZWwub2Zmc2V0VG9wXG4gICAgdmFyIHBhcmVudCA9IGVsLm9mZnNldFBhcmVudFxuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIHJlY3QubGVmdCArPSBwYXJlbnQub2Zmc2V0TGVmdFxuICAgICAgcmVjdC50b3AgKz0gcGFyZW50Lm9mZnNldFRvcFxuICAgICAgcGFyZW50ID0gcGFyZW50Lm9mZnNldFBhcmVudFxuICAgIH1cblxuICAgIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyByZWN0LndpZHRoXG4gICAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIHJlY3QuaGVpZ2h0XG4gIH1cbiAgcmV0dXJuIHJlY3Rcbn1cblxuZnVuY3Rpb24gZ2V0TWluU2Nyb2xsT2Zmc2V0KHNjcm9sbE9iaikge1xuICByZXR1cm4gMCAtIHNjcm9sbE9iai5vcHRpb25zW3Njcm9sbE9iai5heGlzICsgJ1BhZGRpbmdUb3AnXVxufVxuXG5mdW5jdGlvbiBnZXRNYXhTY3JvbGxPZmZzZXQoc2Nyb2xsT2JqKSB7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHNjcm9sbE9iai5lbGVtZW50KVxuICB2YXIgcFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc2Nyb2xsT2JqLnZpZXdwb3J0KVxuICB2YXIgbWluID0gZ2V0TWluU2Nyb2xsT2Zmc2V0KHNjcm9sbE9iailcbiAgaWYgKHNjcm9sbE9iai5heGlzID09PSAneScpIHtcbiAgICB2YXIgbWF4ID0gMCAtIHJlY3QuaGVpZ2h0ICsgcFJlY3QuaGVpZ2h0XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1heCA9IDAgLSByZWN0LndpZHRoICsgcFJlY3Qud2lkdGhcbiAgfVxuICByZXR1cm4gTWF0aC5taW4oXG4gICAgbWF4ICsgc2Nyb2xsT2JqLm9wdGlvbnNbc2Nyb2xsT2JqLmF4aXMgKyAnUGFkZGluZ0JvdHRvbSddLFxuICAgIG1pblxuICApXG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kYXJ5T2Zmc2V0KHNjcm9sbE9iaiwgb2Zmc2V0KSB7XG4gIGlmIChvZmZzZXQgPiBzY3JvbGxPYmoubWluU2Nyb2xsT2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCAtIHNjcm9sbE9iai5taW5TY3JvbGxPZmZzZXRcbiAgfVxuICBpZiAob2Zmc2V0IDwgc2Nyb2xsT2JqLm1heFNjcm9sbE9mZnNldCkge1xuICAgIHJldHVybiBvZmZzZXQgLSBzY3JvbGxPYmoubWF4U2Nyb2xsT2Zmc2V0XG4gIH1cbn1cblxuZnVuY3Rpb24gdG91Y2hCb3VuZGFyeShzY3JvbGxPYmosIG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID4gc2Nyb2xsT2JqLm1pblNjcm9sbE9mZnNldCkge1xuICAgIG9mZnNldCA9IHNjcm9sbE9iai5taW5TY3JvbGxPZmZzZXRcbiAgfSBlbHNlIGlmIChvZmZzZXQgPCBzY3JvbGxPYmoubWF4U2Nyb2xsT2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gc2Nyb2xsT2JqLm1heFNjcm9sbE9mZnNldFxuICB9XG4gIHJldHVybiBvZmZzZXRcbn1cblxuZnVuY3Rpb24gZmlyZUV2ZW50KHNjcm9sbE9iaiwgZXZlbnROYW1lLCBleHRyYSkge1xuICBkZWJ1Z0xvZyhzY3JvbGxPYmouZWxlbWVudC5zY3JvbGxJZCwgZXZlbnROYW1lLCBleHRyYSlcbiAgdmFyIGV2ZW50ID0gZG9jLmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJylcbiAgZXZlbnQuaW5pdEV2ZW50KGV2ZW50TmFtZSwgZmFsc2UsIHRydWUpXG4gIGV2ZW50LnNjcm9sbE9iaiA9IHNjcm9sbE9ialxuICBpZiAoZXh0cmEpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZXh0cmEpIHtcbiAgICAgIGV2ZW50W2tleV0gPSBleHRyYVtrZXldXG4gICAgfVxuICB9XG4gIHNjcm9sbE9iai5lbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gIHNjcm9sbE9iai52aWV3cG9ydC5kaXNwYXRjaEV2ZW50KGV2ZW50KVxufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1PZmZzZXQoc2Nyb2xsT2JqKSB7XG4gIHZhciBvZmZzZXQgPSB7eDogMCwgeTogMH1cbiAgdmFyIHRyYW5zZm9ybSA9IGdldENvbXB1dGVkU3R5bGUoc2Nyb2xsT2JqLmVsZW1lbnQpXG4gICAgW3N0eWxlUHJlZml4ICsgJ1RyYW5zZm9ybSddXG4gIHZhciBtYXRjaGVkXG4gIHZhciByZWcxID0gbmV3IFJlZ0V4cCgnXm1hdHJpeDNkJ1xuICAgICsgJ1xcXFwoKD86Wy1cXFxcZC5dKyxcXFxccyopezEyfShbLVxcXFxkLl0rKSwnXG4gICAgKyAnXFxcXHMqKFstXFxcXGQuXSspKD86LFxcXFxzKlstXFxcXGQuXSspezJ9XFxcXCknKVxuICB2YXIgcmVnMiA9IG5ldyBSZWdFeHAoJ15tYXRyaXgnXG4gICAgKyAnXFxcXCgoPzpbLVxcXFxkLl0rLFxcXFxzKil7NH0oWy1cXFxcZC5dKyksXFxcXHMqKFstXFxcXGQuXSspXFxcXCkkJylcbiAgaWYgKHRyYW5zZm9ybSAhPT0gJ25vbmUnKSB7XG4gICAgaWYgKChtYXRjaGVkID0gdHJhbnNmb3JtLm1hdGNoKHJlZzEpIHx8XG4gICAgICAgIHRyYW5zZm9ybS5tYXRjaChyZWcyKSkpIHtcbiAgICAgIG9mZnNldC54ID0gcGFyc2VGbG9hdChtYXRjaGVkWzFdKSB8fCAwXG4gICAgICBvZmZzZXQueSA9IHBhcnNlRmxvYXQobWF0Y2hlZFsyXSkgfHwgMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRcbn1cblxudmFyIENTU01hdHJpeCA9IElFTW9iaWxlID8gJ01TQ1NTTWF0cml4JyA6ICdXZWJLaXRDU1NNYXRyaXgnXG52YXIgaGFzM2QgPSAhIUZpcmVmb3hcbiAgfHwgQ1NTTWF0cml4IGluIHdpbmRvd1xuICAmJiAnbTExJyBpbiBuZXcgd2luZG93W0NTU01hdHJpeF0oKVxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRlKHgsIHkpIHtcbiAgeCA9IHBhcnNlRmxvYXQoeClcbiAgeSA9IHBhcnNlRmxvYXQoeSlcblxuICBpZiAoeCAhPSAwKSB7XG4gICAgeCArPSAncHgnXG4gIH1cblxuICBpZiAoeSAhPSAwKSB7XG4gICAgeSArPSAncHgnXG4gIH1cblxuICBpZiAoaGFzM2QpIHtcbiAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJywgJyArIHkgKyAnLCAwKSdcbiAgfVxuICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeCArICcsICcgKyB5ICsgJyknXG59XG5cbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25TdHlsZShzY3JvbGxPYmosIGR1cmF0aW9uLCB0aW1pbmdGdW5jdGlvbikge1xuICBpZiAoZHVyYXRpb24gPT09ICcnICYmIHRpbWluZ0Z1bmN0aW9uID09PSAnJykge1xuICAgIHNjcm9sbE9iai5lbGVtZW50LnN0eWxlW3N0eWxlUHJlZml4ICsgJ1RyYW5zaXRpb24nXSA9ICcnXG4gIH0gZWxzZSB7XG4gICAgc2Nyb2xsT2JqLmVsZW1lbnQuc3R5bGVbc3R5bGVQcmVmaXggKyAnVHJhbnNpdGlvbiddXG4gICAgICA9IGNzc1ByZWZpeCArICd0cmFuc2Zvcm0gJyArIGR1cmF0aW9uICsgJyAnICsgdGltaW5nRnVuY3Rpb24gKyAnIDBzJ1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldFRyYW5zZm9ybVN0eWxlKHNjcm9sbE9iaiwgb2Zmc2V0KSB7XG4gIHZhciB4ID0gMFxuICB2YXIgeSA9IDBcbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdvYmplY3QnKSB7XG4gICAgeCA9IG9mZnNldC54XG4gICAgeSA9IG9mZnNldC55XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNjcm9sbE9iai5heGlzID09PSAneScpIHtcbiAgICAgIHkgPSBvZmZzZXRcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IG9mZnNldFxuICAgIH1cbiAgfVxuICBzY3JvbGxPYmouZWxlbWVudC5zdHlsZVtzdHlsZVByZWZpeCArICdUcmFuc2Zvcm0nXSA9IGdldFRyYW5zbGF0ZSh4LCB5KVxufVxuXG52YXIgcGFubmluZyA9IGZhbHNlXG5kb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgaWYgKHBhbm5pbmcpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufSwgZmFsc2UpXG5cbmZ1bmN0aW9uIFNjcm9sbChlbGVtZW50LCBvcHRpb25zKSB7XG4gIHZhciB0aGF0ID0gdGhpc1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIG9wdGlvbnMubm9Cb3VuY2UgPSAhIW9wdGlvbnMubm9Cb3VuY2VcbiAgb3B0aW9ucy5wYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nIHx8IHt9XG5cbiAgaWYgKG9wdGlvbnMuaXNQcmV2ZW50ID09IG51bGwpIHtcbiAgICBvcHRpb25zLmlzUHJldmVudCA9IHRydWVcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmlzUHJldmVudCA9ICEhb3B0aW9ucy5pc1ByZXZlbnRcbiAgfVxuXG4gIGlmIChvcHRpb25zLmlzRml4U2Nyb2xsZW5kQ2xpY2sgPT0gbnVsbCkge1xuICAgIG9wdGlvbnMuaXNGaXhTY3JvbGxlbmRDbGljayA9IHRydWVcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmlzRml4U2Nyb2xsZW5kQ2xpY2sgPSAhIW9wdGlvbnMuaXNGaXhTY3JvbGxlbmRDbGlja1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucGFkZGluZykge1xuICAgIG9wdGlvbnMueVBhZGRpbmdUb3AgPSAtb3B0aW9ucy5wYWRkaW5nLnRvcCB8fCAwXG4gICAgb3B0aW9ucy55UGFkZGluZ0JvdHRvbSA9IC1vcHRpb25zLnBhZGRpbmcuYm90dG9tIHx8IDBcbiAgICBvcHRpb25zLnhQYWRkaW5nVG9wID0gLW9wdGlvbnMucGFkZGluZy5sZWZ0IHx8IDBcbiAgICBvcHRpb25zLnhQYWRkaW5nQm90dG9tID0gLW9wdGlvbnMucGFkZGluZy5yaWdodCB8fCAwXG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy55UGFkZGluZ1RvcCA9IDBcbiAgICBvcHRpb25zLnlQYWRkaW5nQm90dG9tID0gMFxuICAgIG9wdGlvbnMueFBhZGRpbmdUb3AgPSAwXG4gICAgb3B0aW9ucy54UGFkZGluZ0JvdHRvbSA9IDBcbiAgfVxuXG4gIG9wdGlvbnMuZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24gfHwgJ3knXG4gIG9wdGlvbnMuaW5lcnRpYSA9IG9wdGlvbnMuaW5lcnRpYSB8fCAnbm9ybWFsJ1xuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgdGhhdC5heGlzID0gb3B0aW9ucy5kaXJlY3Rpb25cbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudFxuICB0aGlzLnZpZXdwb3J0ID0gZWxlbWVudC5wYXJlbnROb2RlXG4gIHRoaXMucGx1Z2lucyA9IHt9XG5cbiAgdGhpcy5lbGVtZW50LnNjcm9sbElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2Nyb2xsT2Jqc1t0aGF0LmVsZW1lbnQuc2Nyb2xsSWQgKyAnJ10gPSB0aGF0XG4gIH0sIDEpXG5cbiAgdGhpcy52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydEhhbmRsZXIsIGZhbHNlKVxuICB0aGlzLnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hlbmRIYW5kbGVyLCBmYWxzZSlcbiAgdGhpcy52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRvdWNoZW5kSGFuZGxlciwgZmFsc2UpXG4gIHRoaXMudmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcigncGFuc3RhcnQnLCBwYW5zdGFydEhhbmRsZXIsIGZhbHNlKVxuICB0aGlzLnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ3Bhbm1vdmUnLCBwYW5IYW5kbGVyLCBmYWxzZSlcbiAgdGhpcy52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCdwYW5lbmQnLCBwYW5lbmRIYW5kbGVyLCBmYWxzZSlcblxuICBpZiAob3B0aW9ucy5pc1ByZXZlbnQpIHtcbiAgICB0aGlzLnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgcGFubmluZyA9IHRydWVcbiAgICB9LCBmYWxzZSlcbiAgICB0aGF0LnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHBhbm5pbmcgPSBmYWxzZVxuICAgIH0sIGZhbHNlKVxuICB9XG5cbiAgLy8gaWYgKG9wdGlvbnMuaXNQcmV2ZW50KSB7XG4gIC8vICAgdmFyIGQgPSB0aGlzLmF4aXMgPT09ICd5Jz8ndmVydGljYWwnOidob3Jpem9udGFsJ1xuICAvLyAgIHRoaXMudmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihkICsgJ3BhbnN0YXJ0JywgZnVuY3Rpb24gKGUpIHtcbiAgLy8gICAgIHBhbm5pbmcgPSB0cnVlXG4gIC8vICAgfSwgZmFsc2UpXG4gIC8vICAgdGhhdC52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCdwYW5lbmQnLCBmdW5jdGlvbiAoZSkge1xuICAvLyAgICAgcGFubmluZyA9IGZhbHNlXG4gIC8vICAgfSwgZmFsc2UpXG4gIC8vIH1cblxuICBpZiAob3B0aW9ucy5pc0ZpeFNjcm9sbGVuZENsaWNrKSB7XG4gICAgdmFyIHByZXZlbnRTY3JvbGxlbmRDbGlja1xuICAgIHZhciBmaXhTY3JvbGxlbmRDbGlja1RpbWVvdXRJZFxuXG4gICAgdGhpcy52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGxpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBwcmV2ZW50U2Nyb2xsZW5kQ2xpY2sgPSB0cnVlXG4gICAgICBmaXhTY3JvbGxlbmRDbGlja1RpbWVvdXRJZCAmJiBjbGVhclRpbWVvdXQoZml4U2Nyb2xsZW5kQ2xpY2tUaW1lb3V0SWQpXG4gICAgICBmaXhTY3JvbGxlbmRDbGlja1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcHJldmVudFNjcm9sbGVuZENsaWNrID0gZmFsc2VcbiAgICAgIH0sIDQwMClcbiAgICB9LCBmYWxzZSlcblxuICAgIGZ1bmN0aW9uIHByZXZlbnRTY3JvbGxlbmRDbGlja0hhbmRsZXIoZSkge1xuICAgICAgaWYgKHByZXZlbnRTY3JvbGxlbmRDbGljayB8fCBpc1Njcm9sbGluZykge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlyZU5pY2VUYXBFdmVudEhhbmRsZXIoZSkge1xuICAgICAgaWYgKCFwcmV2ZW50U2Nyb2xsZW5kQ2xpY2sgJiYgIWlzU2Nyb2xsaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBuaWNlVGFwRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpXG4gICAgICAgICAgbmljZVRhcEV2ZW50LmluaXRFdmVudCgnbmljZWNsaWNrJywgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgICBlLnRhcmdldC5kaXNwYXRjaEV2ZW50KG5pY2VUYXBFdmVudClcbiAgICAgICAgfSwgMzAwKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBwcmV2ZW50U2Nyb2xsZW5kQ2xpY2tIYW5kbGVyKVxuICAgIHRoaXMudmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcigndGFwJywgZmlyZU5pY2VUYXBFdmVudEhhbmRsZXIpXG4gIH1cblxuICBmdW5jdGlvbiBzZXRUcmFuc2l0aW9uRW5kSGFuZGxlcihoLCB0KSB7XG4gICAgaWYgKG9wdGlvbnMudXNlRnJhbWVBbmltYXRpb24pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0cmFuc2l0aW9uRW5kSGFuZGxlciA9IG51bGxcbiAgICBjbGVhclRpbWVvdXQodHJhbnNpdGlvbkVuZFRpbWVvdXRJZClcblxuICAgIHRyYW5zaXRpb25FbmRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0cmFuc2l0aW9uRW5kSGFuZGxlcikge1xuICAgICAgICB0cmFuc2l0aW9uRW5kSGFuZGxlciA9IG51bGxcbiAgICAgICAgbGliLmFuaW1hdGlvbi5yZXF1ZXN0RnJhbWUoaClcbiAgICAgIH1cbiAgICB9LCAodCB8fCA0MDApKVxuXG4gICAgdHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBoXG4gIH1cblxuICBpZiAob3B0aW9ucy51c2VGcmFtZUFuaW1hdGlvbikge1xuICAgIHZhciBzY3JvbGxBbmltYXRpb25cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYW5pbWF0aW9uJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzY3JvbGxBbmltYXRpb25cbiAgICAgIH1cbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHZhciB0cmFuc2l0aW9uRW5kSGFuZGxlclxuICAgIHZhciB0cmFuc2l0aW9uRW5kVGltZW91dElkID0gMFxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBGaXJlZm94XG4gICAgICAgICAgPyAndHJhbnNpdGlvbmVuZCdcbiAgICAgICAgICA6IChzdHlsZVByZWZpeCArICdUcmFuc2l0aW9uRW5kJyksIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAodHJhbnNpdGlvbkVuZEhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0cmFuc2l0aW9uRW5kSGFuZGxlclxuXG4gICAgICAgIHRyYW5zaXRpb25FbmRIYW5kbGVyID0gbnVsbFxuICAgICAgICBjbGVhclRpbWVvdXQodHJhbnNpdGlvbkVuZFRpbWVvdXRJZClcblxuICAgICAgICBsaWIuYW5pbWF0aW9uLnJlcXVlc3RGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaGFuZGxlcihlKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sIGZhbHNlKVxuICB9XG5cbiAgdmFyIHBhbkZpeFJhdGlvXG4gIHZhciBpc1Njcm9sbGluZ1xuICB2YXIgaXNGbGlja1Njcm9sbGluZ1xuICB2YXIgY2FuY2VsU2Nyb2xsRW5kXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpc1Njcm9sbGluZycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhIWlzU2Nyb2xsaW5nXG4gICAgfVxuICB9KVxuXG4gIGZ1bmN0aW9uIGlzRW5hYmxlZChlKSB7XG4gICAgaWYgKCF0aGF0LmVuYWJsZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZS5pc1ZlcnRpY2FsICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodGhhdC5heGlzID09PSAneScgJiYgZS5pc1ZlcnRpY2FsXG4gICAgICAgICAgfHwgdGhhdC5heGlzID09PSAneCcgJiYgIWUuaXNWZXJ0aWNhbCkge1xuICAgICAgICAvLyBnZXN0dXJlIGluIHNhbWUgZGlyZWN0aW9uLCBzdG9wIGJ1YmJsaW5nIHVwXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdlc3R1cmUgaW4gZGlmZmVyZW50IGRpcmVjdGlvbiwgYnViYmxpbmcgdXBcbiAgICAgICAgLy8gdG8gdGhlIHRvcCwgd2l0aG91dCBhbnkgb3RoZXIgcHJvY2Vzc1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydEhhbmRsZXIoZSkge1xuICAgIGlmICghaXNFbmFibGVkKGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNTY3JvbGxpbmcpIHtcbiAgICAgIHNjcm9sbEVuZCgpXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudXNlRnJhbWVBbmltYXRpb24pIHtcbiAgICAgIHNjcm9sbEFuaW1hdGlvbiAmJiBzY3JvbGxBbmltYXRpb24uc3RvcCgpXG4gICAgICBzY3JvbGxBbmltYXRpb24gPSBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm1PZmZzZXQodGhhdClcbiAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIHRyYW5zZm9ybSlcbiAgICAgIHNldFRyYW5zaXRpb25TdHlsZSh0aGF0LCAnJywgJycpXG4gICAgICB0cmFuc2l0aW9uRW5kSGFuZGxlciA9IG51bGxcbiAgICAgIGNsZWFyVGltZW91dCh0cmFuc2l0aW9uRW5kVGltZW91dElkKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kSGFuZGxlcihlKSB7XG4gICAgaWYgKCFpc0VuYWJsZWQoZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBzMCA9IGdldFRyYW5zZm9ybU9mZnNldCh0aGF0KVt0aGF0LmF4aXNdXG4gICAgdmFyIGJvdW5kYXJ5T2Zmc2V0ID0gZ2V0Qm91bmRhcnlPZmZzZXQodGhhdCwgczApXG5cbiAgICBpZiAoYm91bmRhcnlPZmZzZXQpIHtcbiAgICAgIC8vIGRyYWdnaW5nIG91dCBvZiBib3VuZHJheSwgYm91bmNlIGlzIG5lZWRlZFxuICAgICAgdmFyIHMxID0gdG91Y2hCb3VuZGFyeSh0aGF0LCBzMClcblxuICAgICAgaWYgKG9wdGlvbnMudXNlRnJhbWVBbmltYXRpb24pIHtcbiAgICAgICAgLy8gZnJhbWVcbiAgICAgICAgdmFyIF9zID0gczEgLSBzMFxuICAgICAgICBzY3JvbGxBbmltYXRpb24gPSBuZXcgbGliLmFuaW1hdGlvbihcbiAgICAgICAgICAgIDQwMCxcbiAgICAgICAgICAgIGxpYi5jdWJpY2Jlemllci5lYXNlLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChpMSwgaTIpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gKHMwICsgX3MgKiBpMikudG9GaXhlZCgyKVxuICAgICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldClcbiAgICAgICAgICBmaXJlRXZlbnQodGhhdCwgJ3Njcm9sbGluZycpXG4gICAgICAgIH0pXG4gICAgICAgIHNjcm9sbEFuaW1hdGlvbi5vbmVuZChzY3JvbGxFbmQpXG4gICAgICAgIHNjcm9sbEFuaW1hdGlvbi5wbGF5KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNzc1xuICAgICAgICB2YXIgb2Zmc2V0ID0gIHMxLnRvRml4ZWQoMClcbiAgICAgICAgc2V0VHJhbnNpdGlvbkVuZEhhbmRsZXIoc2Nyb2xsRW5kLCA0MDApXG4gICAgICAgIHNldFRyYW5zaXRpb25TdHlsZSh0aGF0LCAnMC40cycsICdlYXNlJylcbiAgICAgICAgc2V0VHJhbnNmb3JtU3R5bGUodGhhdCwgb2Zmc2V0KVxuXG4gICAgICAgIGxpYi5hbmltYXRpb24ucmVxdWVzdEZyYW1lKGZ1bmN0aW9uIGRvU2Nyb2xsKCkge1xuICAgICAgICAgIGlmIChpc1Njcm9sbGluZyAmJiB0aGF0LmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGZpcmVFdmVudCh0aGF0LCAnc2Nyb2xsaW5nJylcbiAgICAgICAgICAgIGxpYi5hbmltYXRpb24ucmVxdWVzdEZyYW1lKGRvU2Nyb2xsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgaWYgKGJvdW5kYXJ5T2Zmc2V0ID4gMCkge1xuICAgICAgICBmaXJlRXZlbnQodGhhdCwgdGhhdC5heGlzID09PSAneScgPyAncHVsbGRvd25lbmQnIDogJ3B1bGxyaWdodGVuZCcpXG4gICAgICB9IGVsc2UgaWYgKGJvdW5kYXJ5T2Zmc2V0IDwgMCkge1xuICAgICAgICBmaXJlRXZlbnQodGhhdCwgdGhhdC5heGlzID09PSAneScgPyAncHVsbHVwZW5kJyA6ICdwdWxsbGVmdGVuZCcpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1Njcm9sbGluZykge1xuICAgICAgLy8gd2l0aG91dCBleGNlZWRpbmcgdGhlIGJvdW5kYXJ5LCBqdXN0IGVuZCBpdFxuICAgICAgc2Nyb2xsRW5kKClcbiAgICB9XG4gIH1cblxuICB2YXIgbGFzdERpc3BsYWNlbWVudFxuICBmdW5jdGlvbiBwYW5zdGFydEhhbmRsZXIoZSkge1xuICAgIGlmICghaXNFbmFibGVkKGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGF0LnRyYW5zZm9ybU9mZnNldCA9IGdldFRyYW5zZm9ybU9mZnNldCh0aGF0KVxuICAgIHRoYXQubWluU2Nyb2xsT2Zmc2V0ID0gZ2V0TWluU2Nyb2xsT2Zmc2V0KHRoYXQpXG4gICAgdGhhdC5tYXhTY3JvbGxPZmZzZXQgPSBnZXRNYXhTY3JvbGxPZmZzZXQodGhhdClcbiAgICBwYW5GaXhSYXRpbyA9IDIuNVxuICAgIGNhbmNlbFNjcm9sbEVuZCA9IHRydWVcbiAgICBpc1Njcm9sbGluZyA9IHRydWVcbiAgICBpc0ZsaWNrU2Nyb2xsaW5nID0gZmFsc2VcbiAgICBmaXJlRXZlbnQodGhhdCwgJ3Njcm9sbHN0YXJ0JylcblxuICAgIGxhc3REaXNwbGFjZW1lbnQgPSBlWydkaXNwbGFjZW1lbnQnICsgdGhhdC5heGlzLnRvVXBwZXJDYXNlKCldXG4gIH1cblxuXG4gIGZ1bmN0aW9uIHBhbkhhbmRsZXIoZSkge1xuICAgIGlmICghaXNFbmFibGVkKGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaW5nZXIgbW92ZSBsZXNzIHRoYW4gNSBweC4ganVzdCBpZ25vcmUgdGhhdC5cbiAgICB2YXIgZGlzcGxhY2VtZW50ID0gZVsnZGlzcGxhY2VtZW50JyArIHRoYXQuYXhpcy50b1VwcGVyQ2FzZSgpXVxuICAgIGlmIChNYXRoLmFicyhkaXNwbGFjZW1lbnQgLSBsYXN0RGlzcGxhY2VtZW50KSA8IDUpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBsYXN0RGlzcGxhY2VtZW50ID0gZGlzcGxhY2VtZW50XG5cbiAgICB2YXIgb2Zmc2V0ID0gdGhhdC50cmFuc2Zvcm1PZmZzZXRbdGhhdC5heGlzXSArIGRpc3BsYWNlbWVudFxuICAgIGlmIChvZmZzZXQgPiB0aGF0Lm1pblNjcm9sbE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gdGhhdC5taW5TY3JvbGxPZmZzZXRcbiAgICAgICAgKyAob2Zmc2V0IC0gdGhhdC5taW5TY3JvbGxPZmZzZXQpIC8gcGFuRml4UmF0aW9cbiAgICAgIHBhbkZpeFJhdGlvICo9IDEuMDAzXG4gICAgfSBlbHNlIGlmIChvZmZzZXQgPCB0aGF0Lm1heFNjcm9sbE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gdGhhdC5tYXhTY3JvbGxPZmZzZXRcbiAgICAgICAgLSAodGhhdC5tYXhTY3JvbGxPZmZzZXQgLSBvZmZzZXQpIC8gcGFuRml4UmF0aW9cbiAgICAgIHBhbkZpeFJhdGlvICo9IDEuMDAzXG4gICAgfVxuICAgIGlmIChwYW5GaXhSYXRpbyA+IDQpIHtcbiAgICAgIHBhbkZpeFJhdGlvID0gNFxuICAgIH1cblxuICAgIC8vIHRlbGwgd2hldGhlciBvciBub3QgcmVhY2ggdGhlIGZyaW5nZVxuICAgIHZhciBib3VuZGFyeU9mZnNldCA9IGdldEJvdW5kYXJ5T2Zmc2V0KHRoYXQsIG9mZnNldClcbiAgICBpZiAoYm91bmRhcnlPZmZzZXQpIHtcbiAgICAgIGZpcmVFdmVudChcbiAgICAgICAgICB0aGF0LFxuICAgICAgICAgIGJvdW5kYXJ5T2Zmc2V0ID4gMFxuICAgICAgICAgID8gKHRoYXQuYXhpcyA9PT0gJ3knID8gJ3B1bGxkb3duJyA6ICdwdWxscmlnaHQnKVxuICAgICAgICAgIDogKHRoYXQuYXhpcyA9PT0gJ3knID8gJ3B1bGx1cCcgOiAncHVsbGxlZnQnKSwge1xuICAgICAgICBib3VuZGFyeU9mZnNldDogTWF0aC5hYnMoYm91bmRhcnlPZmZzZXQpXG4gICAgICB9KVxuICAgICAgaWYgKHRoYXQub3B0aW9ucy5ub0JvdW5jZSkge1xuICAgICAgICBvZmZzZXQgPSB0b3VjaEJvdW5kYXJ5KHRoYXQsIG9mZnNldClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRUcmFuc2Zvcm1TdHlsZSh0aGF0LCBvZmZzZXQudG9GaXhlZCgyKSlcbiAgICBmaXJlRXZlbnQodGhhdCwgJ3Njcm9sbGluZycpXG4gIH1cblxuICBmdW5jdGlvbiBwYW5lbmRIYW5kbGVyKGUpIHtcbiAgICBpZiAoIWlzRW5hYmxlZChlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGUuaXNTd2lwZSkge1xuICAgICAgZmxpY2tIYW5kbGVyKGUpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmxpY2tIYW5kbGVyKGUpIHtcbiAgICBjYW5jZWxTY3JvbGxFbmQgPSB0cnVlXG5cbiAgICB2YXIgdjAsIGEwLCB0MCwgczAsIHMsIG1vdGlvbjBcbiAgICB2YXIgdjEsIGExLCB0MSwgczEsIG1vdGlvbjEsc2lnblxuICAgIHZhciB2MiwgYTIsIHQyLCBzMiwgbW90aW9uMiwgZnRcblxuICAgIHMwID0gZ2V0VHJhbnNmb3JtT2Zmc2V0KHRoYXQpW3RoYXQuYXhpc11cbiAgICB2YXIgYm91bmRhcnlPZmZzZXQwID0gZ2V0Qm91bmRhcnlPZmZzZXQodGhhdCwgczApXG4gICAgaWYgKCFib3VuZGFyeU9mZnNldDApIHtcbiAgICAgIC8vIHdoZW4gZmluZ2VycyBsZWZ0IHRoZSByYW5nZSBvZiBzY3JlZW4sIGxldCB0b3VjaCBlbmQgaGFuZGxlclxuICAgICAgLy8gdG8gZGVhbCB3aXRoIGl0LlxuICAgICAgLy8gd2hlbiBmaW5nZXJzIGxlZnQgdGhlIHNjcmVlbiwgYnV0IHN0aWxsIGluIHRoZSByYW5nZSBvZlxuICAgICAgLy8gc2NyZWVuLCBjYWxjdWxhdGUgdGhlIGludGVydGlhLlxuICAgICAgdjAgPSBlWyd2ZWxvY2l0eScgKyB0aGF0LmF4aXMudG9VcHBlckNhc2UoKV1cblxuICAgICAgdmFyIG1heFYgPSAyXG4gICAgICB2YXIgZnJpY3Rpb24gPSAwLjAwMTVcbiAgICAgIGlmIChvcHRpb25zLmluZXJ0aWEgJiYgaW5lcnRpYUNvZWZmaWNpZW50W29wdGlvbnMuaW5lcnRpYV0pIHtcbiAgICAgICAgbWF4ViA9IGluZXJ0aWFDb2VmZmljaWVudFtvcHRpb25zLmluZXJ0aWFdWzBdXG4gICAgICAgIGZyaWN0aW9uID0gaW5lcnRpYUNvZWZmaWNpZW50W29wdGlvbnMuaW5lcnRpYV1bMV1cbiAgICAgIH1cblxuICAgICAgaWYgKHYwID4gbWF4Vikge1xuICAgICAgICB2MCA9IG1heFZcbiAgICAgIH1cbiAgICAgIGlmICh2MCA8IC1tYXhWKSB7XG4gICAgICAgIHYwID0gLW1heFZcbiAgICAgIH1cbiAgICAgIGEwID0gZnJpY3Rpb24gKiAodjAgLyBNYXRoLmFicyh2MCkpXG4gICAgICBtb3Rpb24wID0gbmV3IGxpYi5tb3Rpb24oe1xuICAgICAgICB2OiB2MCxcbiAgICAgICAgYTogLWEwXG4gICAgICB9KVxuICAgICAgdDAgPSBtb3Rpb24wLnRcbiAgICAgIHMgPSBzMCArIG1vdGlvbjAuc1xuXG4gICAgICB2YXIgYm91bmRhcnlPZmZzZXQxID0gZ2V0Qm91bmRhcnlPZmZzZXQodGhhdCwgcylcbiAgICAgIGlmIChib3VuZGFyeU9mZnNldDEpIHtcbiAgICAgICAgZGVidWdMb2coJ2luZXJ0aWFsIGNhbGN1bGF0aW9uIGhhcyBleGNlZWRlZCB0aGUgYm91bmRhcnknLFxuICAgICAgICAgIGJvdW5kYXJ5T2Zmc2V0MSlcblxuICAgICAgICB2MSA9IHYwXG4gICAgICAgIGExID0gYTBcbiAgICAgICAgaWYgKGJvdW5kYXJ5T2Zmc2V0MSA+IDApIHtcbiAgICAgICAgICBzMSA9IHRoYXQubWluU2Nyb2xsT2Zmc2V0XG4gICAgICAgICAgc2lnbiA9IDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHRoYXQubWF4U2Nyb2xsT2Zmc2V0XG4gICAgICAgICAgc2lnbiA9IC0xXG4gICAgICAgIH1cbiAgICAgICAgbW90aW9uMSA9IG5ldyBsaWIubW90aW9uKHtcbiAgICAgICAgICB2OiBzaWduICogdjEsXG4gICAgICAgICAgYTogLXNpZ24gKiBhMSxcbiAgICAgICAgICBzOiBNYXRoLmFicyhzMSAtIHMwKVxuICAgICAgICB9KVxuICAgICAgICB0MSA9IG1vdGlvbjEudFxuICAgICAgICB2YXIgdGltZUZ1bmN0aW9uMSA9IG1vdGlvbjEuZ2VuZXJhdGVDdWJpY0JlemllcigpXG5cbiAgICAgICAgdjIgPSB2MSAtIGExICogdDFcbiAgICAgICAgYTIgPSAwLjAzICogKHYyIC8gTWF0aC5hYnModjIpKVxuICAgICAgICBtb3Rpb24yID0gbmV3IGxpYi5tb3Rpb24oe1xuICAgICAgICAgIHY6IHYyLFxuICAgICAgICAgIGE6IC1hMlxuICAgICAgICB9KVxuICAgICAgICB0MiA9IG1vdGlvbjIudFxuICAgICAgICBzMiA9IHMxICsgbW90aW9uMi5zXG4gICAgICAgIHZhciB0aW1lRnVuY3Rpb24yID0gbW90aW9uMi5nZW5lcmF0ZUN1YmljQmV6aWVyKClcblxuICAgICAgICBpZiAob3B0aW9ucy5ub0JvdW5jZSkge1xuICAgICAgICAgIGRlYnVnTG9nKCdubyBib3VuY2UgZWZmZWN0JylcblxuICAgICAgICAgIGlmIChzMCAhPT0gczEpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVzZUZyYW1lQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIGZyYW1lXG4gICAgICAgICAgICAgIHZhciBfcyA9IHMxIC0gczBcbiAgICAgICAgICAgICAgdmFyIGJlemllciA9IGxpYi5jdWJpY2JlemllcihcbiAgICAgICAgICAgICAgICB0aW1lRnVuY3Rpb24xWzBdWzBdLFxuICAgICAgICAgICAgICAgIHRpbWVGdW5jdGlvbjFbMF1bMV0sXG4gICAgICAgICAgICAgICAgdGltZUZ1bmN0aW9uMVsxXVswXSxcbiAgICAgICAgICAgICAgICB0aW1lRnVuY3Rpb24xWzFdWzFdXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgc2Nyb2xsQW5pbWF0aW9uID0gbmV3IGxpYi5hbmltYXRpb24oXG4gICAgICAgICAgICAgICAgICB0MS50b0ZpeGVkKDApLFxuICAgICAgICAgICAgICAgICAgYmV6aWVyLFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChpMSwgaTIpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gKHMwICsgX3MgKiBpMilcbiAgICAgICAgICAgICAgICBnZXRUcmFuc2Zvcm1PZmZzZXQodGhhdCwgb2Zmc2V0LnRvRml4ZWQoMikpXG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KHRoYXQsICdzY3JvbGxpbmcnLCB7XG4gICAgICAgICAgICAgICAgICBhZnRlckZsaWNrOiB0cnVlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICBzY3JvbGxBbmltYXRpb24ub25lbmQoc2Nyb2xsRW5kKVxuXG4gICAgICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbi5wbGF5KClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNzc1xuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gczEudG9GaXhlZCgwKVxuICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uRW5kSGFuZGxlcihcbiAgICAgICAgICAgICAgICBzY3JvbGxFbmQsXG4gICAgICAgICAgICAgICAgKHQxIC8gMTAwMCkudG9GaXhlZCgyKSAqIDEwMDBcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uU3R5bGUoXG4gICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICAodDEgLyAxMDAwKS50b0ZpeGVkKDIpICsgJ3MnLFxuICAgICAgICAgICAgICAgICdjdWJpYy1iZXppZXIoJyArIHRpbWVGdW5jdGlvbjEgKyAnKSdcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBzZXRUcmFuc2Zvcm1TdHlsZSh0aGF0LCBvZmZzZXQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbEVuZCgpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHMwICE9PSBzMikge1xuICAgICAgICAgIGRlYnVnTG9nKFxuICAgICAgICAgICAgJ3Njcm9sbCBmb3IgaW5lcnRpYScsXG4gICAgICAgICAgICAncz0nICsgczIudG9GaXhlZCgwKSxcbiAgICAgICAgICAgICd0PScgKyAoKHQxICsgdDIpIC8gMTAwMCkudG9GaXhlZCgyKVxuICAgICAgICAgIClcblxuICAgICAgICAgIGlmIChvcHRpb25zLnVzZUZyYW1lQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX3MgPSBzMiAtIHMwXG4gICAgICAgICAgICB2YXIgYmV6aWVyID0gbGliLmN1YmljYmV6aWVyLmVhc2VPdXRcbiAgICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbiA9IG5ldyBsaWIuYW5pbWF0aW9uKFxuICAgICAgICAgICAgICAgICh0MSArIHQyKS50b0ZpeGVkKDApLFxuICAgICAgICAgICAgICAgIGJlemllcixcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChpMSwgaTIpIHtcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHMwICsgX3MgKiBpMlxuICAgICAgICAgICAgICBzZXRUcmFuc2Zvcm1TdHlsZSh0aGF0LCBvZmZzZXQudG9GaXhlZCgyKSlcbiAgICAgICAgICAgICAgZmlyZUV2ZW50KHRoYXQsICdzY3JvbGxpbmcnLHtcbiAgICAgICAgICAgICAgICBhZnRlckZsaWNrOiB0cnVlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBzY3JvbGxBbmltYXRpb24ub25lbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoIXRoYXQuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIF9zID0gczEgLSBzMlxuICAgICAgICAgICAgICB2YXIgYmV6aWVyID0gbGliLmN1YmljYmV6aWVyLmVhc2VcbiAgICAgICAgICAgICAgc2Nyb2xsQW5pbWF0aW9uID0gbmV3IGxpYi5hbmltYXRpb24oXG4gICAgICAgICAgICAgICAgICA0MDAsXG4gICAgICAgICAgICAgICAgICBiZXppZXIsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGkxLCBpMikge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBzMiArIF9zICogaTJcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2Zvcm1TdHlsZSh0aGF0LCBvZmZzZXQudG9GaXhlZCgyKSlcbiAgICAgICAgICAgICAgICBmaXJlRXZlbnQodGhhdCwgJ3Njcm9sbGluZycse1xuICAgICAgICAgICAgICAgICAgYWZ0ZXJGbGljazogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgc2Nyb2xsQW5pbWF0aW9uLm9uZW5kKHNjcm9sbEVuZClcblxuICAgICAgICAgICAgICBzY3JvbGxBbmltYXRpb24ucGxheSgpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBzY3JvbGxBbmltYXRpb24ucGxheSgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBzMi50b0ZpeGVkKDApXG4gICAgICAgICAgICBzZXRUcmFuc2l0aW9uRW5kSGFuZGxlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBpZiAoIXRoYXQuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGVidWdMb2coJ2luZXJ0aWFsIGJvdW5jZScsXG4gICAgICAgICAgICAgICAgJ3M9JyArIHMxLnRvRml4ZWQoMCksXG4gICAgICAgICAgICAgICAgJ3Q9NDAwJ1xuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgaWYgKHMyICE9PSBzMSkge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBzMS50b0ZpeGVkKDApXG4gICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvblN0eWxlKHRoYXQsICcwLjRzJywgJ2Vhc2UnKVxuICAgICAgICAgICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldClcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uRW5kSGFuZGxlcihzY3JvbGxFbmQsIDQwMClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxFbmQoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAoKHQxICsgdDIpIC8gMTAwMCkudG9GaXhlZCgyKSAqIDEwMDApXG5cbiAgICAgICAgICAgIHNldFRyYW5zaXRpb25TdHlsZShcbiAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgKCh0MSArIHQyKSAvIDEwMDApLnRvRml4ZWQoMikgKyAncycsXG4gICAgICAgICAgICAgICdlYXNlLW91dCdcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Nyb2xsRW5kKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWdMb2coJ2luZXJ0aWFsIGNhbGN1bGF0aW9uIGhhc25cXCd0IGV4Y2VlZGVkIHRoZSBib3VuZGFyeScpXG4gICAgICAgIHZhciB0aW1lRnVuY3Rpb24gPSBtb3Rpb24wLmdlbmVyYXRlQ3ViaWNCZXppZXIoKVxuXG4gICAgICAgIGlmIChvcHRpb25zLnVzZUZyYW1lQW5pbWF0aW9uKSB7XG4gICAgICAgICAgLy8gZnJhbWVcbiAgICAgICAgICB2YXIgX3MgPSBzIC0gczBcbiAgICAgICAgICB2YXIgYmV6aWVyID0gbGliLmN1YmljYmV6aWVyKFxuICAgICAgICAgICAgdGltZUZ1bmN0aW9uWzBdWzBdLFxuICAgICAgICAgICAgdGltZUZ1bmN0aW9uWzBdWzFdLFxuICAgICAgICAgICAgdGltZUZ1bmN0aW9uWzFdWzBdLFxuICAgICAgICAgICAgdGltZUZ1bmN0aW9uWzFdWzFdXG4gICAgICAgICAgKVxuICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbiA9IG5ldyBsaWIuYW5pbWF0aW9uKFxuICAgICAgICAgICAgICB0MC50b0ZpeGVkKDApLFxuICAgICAgICAgICAgICBiZXppZXIsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChpMSwgaTIpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAoczAgKyBfcyAqIGkyKS50b0ZpeGVkKDIpXG4gICAgICAgICAgICBzZXRUcmFuc2Zvcm1TdHlsZSh0aGF0LCBvZmZzZXQpXG4gICAgICAgICAgICBmaXJlRXZlbnQodGhhdCwgJ3Njcm9sbGluZycse1xuICAgICAgICAgICAgICBhZnRlckZsaWNrOiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBzY3JvbGxBbmltYXRpb24ub25lbmQoc2Nyb2xsRW5kKVxuXG4gICAgICAgICAgc2Nyb2xsQW5pbWF0aW9uLnBsYXkoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNzc1xuICAgICAgICAgIHZhciBvZmZzZXQgPSBzLnRvRml4ZWQoMClcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uRW5kSGFuZGxlcihzY3JvbGxFbmQsICh0MCAvIDEwMDApLnRvRml4ZWQoMikgKiAxMDAwKVxuICAgICAgICAgIHNldFRyYW5zaXRpb25TdHlsZShcbiAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAodDAgLyAxMDAwKS50b0ZpeGVkKDIpICsgJ3MnLFxuICAgICAgICAgICAgJ2N1YmljLWJlemllcignICsgdGltZUZ1bmN0aW9uICsgJyknXG4gICAgICAgICAgKVxuICAgICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldClcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIGlzRmxpY2tTY3JvbGxpbmcgPSB0cnVlXG4gICAgICBpZiAoIW9wdGlvbnMudXNlRnJhbWVBbmltYXRpb24pIHtcbiAgICAgICAgbGliLmFuaW1hdGlvbi5yZXF1ZXN0RnJhbWUoZnVuY3Rpb24gZG9TY3JvbGwoKSB7XG4gICAgICAgICAgaWYgKGlzU2Nyb2xsaW5nICYmIGlzRmxpY2tTY3JvbGxpbmcgJiYgdGhhdC5lbmFibGVkKSB7XG4gICAgICAgICAgICBmaXJlRXZlbnQodGhhdCwgJ3Njcm9sbGluZycsIHtcbiAgICAgICAgICAgICAgYWZ0ZXJGbGljazogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGxpYi5hbmltYXRpb24ucmVxdWVzdEZyYW1lKGRvU2Nyb2xsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxFbmQoKSB7XG4gICAgaWYgKCF0aGF0LmVuYWJsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNhbmNlbFNjcm9sbEVuZCA9IGZhbHNlXG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghY2FuY2VsU2Nyb2xsRW5kICYmIGlzU2Nyb2xsaW5nKSB7XG4gICAgICAgIGlzU2Nyb2xsaW5nID0gZmFsc2VcbiAgICAgICAgaXNGbGlja1Njcm9sbGluZyA9IGZhbHNlXG5cbiAgICAgICAgaWYgKG9wdGlvbnMudXNlRnJhbWVBbmltYXRpb24pIHtcbiAgICAgICAgICBzY3JvbGxBbmltYXRpb24gJiYgc2Nyb2xsQW5pbWF0aW9uLnN0b3AoKVxuICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbiA9IG51bGxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uU3R5bGUodGhhdCwgJycsICcnKVxuICAgICAgICB9XG4gICAgICAgIGZpcmVFdmVudCh0aGF0LCAnc2Nyb2xsZW5kJylcbiAgICAgIH1cbiAgICB9LCA1MClcbiAgfVxuXG4gIHZhciBwcm90byA9IHtcbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmVuYWJsZSgpXG4gICAgICB0aGlzLnJlZnJlc2goKVxuICAgICAgdGhpcy5zY3JvbGxUbygwKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLmVsZW1lbnRcbiAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlRnJhbWVBbmltYXRpb24pIHtcbiAgICAgICAgc2Nyb2xsQW5pbWF0aW9uICYmIHNjcm9sbEFuaW1hdGlvbi5zdG9wKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYi5hbmltYXRpb24ucmVxdWVzdEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZVtzdHlsZVByZWZpeCArICdUcmFuc2Zvcm0nXVxuICAgICAgICAgICAgPSBnZXRDb21wdXRlZFN0eWxlKGVsKVtzdHlsZVByZWZpeCArICdUcmFuc2Zvcm0nXVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBnZXRTY3JvbGxXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLmVsZW1lbnQpLndpZHRoXG4gICAgfSxcblxuICAgIGdldFNjcm9sbEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLmVsZW1lbnQpLmhlaWdodFxuICAgIH0sXG5cbiAgICBnZXRTY3JvbGxMZWZ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gLWdldFRyYW5zZm9ybU9mZnNldCh0aGlzKS54IC0gdGhpcy5vcHRpb25zLnhQYWRkaW5nVG9wXG4gICAgfSxcblxuICAgIGdldFNjcm9sbFRvcDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIC1nZXRUcmFuc2Zvcm1PZmZzZXQodGhpcykueSAtIHRoaXMub3B0aW9ucy55UGFkZGluZ1RvcFxuICAgIH0sXG5cbiAgICBnZXRNYXhTY3JvbGxMZWZ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gLXRoYXQubWF4U2Nyb2xsT2Zmc2V0IC0gdGhpcy5vcHRpb25zLnhQYWRkaW5nVG9wXG4gICAgfSxcblxuICAgIGdldE1heFNjcm9sbFRvcDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIC10aGF0Lm1heFNjcm9sbE9mZnNldCAtIHRoaXMub3B0aW9ucy55UGFkZGluZ1RvcFxuICAgIH0sXG5cbiAgICBnZXRCb3VuZGFyeU9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKFxuICAgICAgICBnZXRCb3VuZGFyeU9mZnNldCh0aGlzLCBnZXRUcmFuc2Zvcm1PZmZzZXQodGhpcylbdGhpcy5heGlzXSkgfHwgMFxuICAgICAgKVxuICAgIH0sXG5cbiAgICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLmVsZW1lbnRcbiAgICAgIHZhciBpc1ZlcnRpY2FsID0gKHRoaXMuYXhpcyA9PT0gJ3knKVxuICAgICAgdmFyIHR5cGUgPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnXG4gICAgICB2YXIgc2l6ZSwgcmVjdCwgZXh0cmFTaXplXG5cbiAgICAgIGZ1bmN0aW9uIGdldEV4dHJhU2l6ZShlbCwgaXNWZXJ0aWNhbCkge1xuICAgICAgICB2YXIgZXh0cmFUeXBlID0gaXNWZXJ0aWNhbCA/IFsndG9wJywgJ2JvdHRvbSddIDogWydsZWZ0JywgJ3JpZ2h0J11cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoXG4gICAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZShlbC5maXJzdEVsZW1lbnRDaGlsZClbJ21hcmdpbi0nICsgZXh0cmFUeXBlWzBdXVxuICAgICAgICApICsgcGFyc2VGbG9hdChcbiAgICAgICAgICBnZXRDb21wdXRlZFN0eWxlKGVsLmxhc3RFbGVtZW50Q2hpbGQpWydtYXJnaW4tJyArIGV4dHJhVHlwZVsxXV1cbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zW3R5cGVdICE9IG51bGwpIHtcbiAgICAgICAgLy8gdXNlIG9wdGlvbnNcbiAgICAgICAgc2l6ZSA9IHRoaXMub3B0aW9uc1t0eXBlXVxuICAgICAgfSBlbHNlIGlmIChlbC5jaGlsZEVsZW1lbnRDb3VudCA8PSAwKSB7XG4gICAgICAgIGVsLnN0eWxlW3R5cGVdID0gJ2F1dG8nXG4gICAgICAgIHNpemUgPSBudWxsXG4gICAgICB9IGVsc2UgaWYgKCEhdGhpcy5vcHRpb25zLnVzZUVsZW1lbnRSZWN0KSB7XG4gICAgICAgIGVsLnN0eWxlW3R5cGVdID0gJ2F1dG8nXG4gICAgICAgIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpXG4gICAgICAgIHNpemUgPSByZWN0W3R5cGVdXG4gICAgICAgIHNpemUgKz0gZ2V0RXh0cmFTaXplKGVsLCBpc1ZlcnRpY2FsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJhbmdlLCByZWN0XG4gICAgICAgIHZhciBmaXJzdEVsID0gZWwuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgICAgdmFyIGxhc3RFbCA9IGVsLmxhc3RFbGVtZW50Q2hpbGRcblxuICAgICAgICBpZiAoZG9jdW1lbnQuY3JlYXRlUmFuZ2UgJiYgIXRoaXMub3B0aW9ucy5pZ25vcmVPdmVyZmxvdykge1xuICAgICAgICAgIC8vIHVzZSByYW5nZVxuICAgICAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKVxuICAgICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhlbClcbiAgICAgICAgICByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJhbmdlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICBzaXplID0gcmVjdFt0eXBlXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVzZSBjaGlsZCBvZmZzZXRzXG4gICAgICAgICAgd2hpbGUgKGZpcnN0RWwpIHtcbiAgICAgICAgICAgIGlmIChnZXRCb3VuZGluZ0NsaWVudFJlY3QoZmlyc3RFbClbdHlwZV0gPT09IDBcbiAgICAgICAgICAgICAgICAmJiBmaXJzdEVsLm5leHRFbGVtZW50U2libGluZykge1xuICAgICAgICAgICAgICBmaXJzdEVsID0gZmlyc3RFbC5uZXh0RWxlbWVudFNpYmxpbmdcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hpbGUgKGxhc3RFbCAmJiBsYXN0RWwgIT09IGZpcnN0RWwpIHtcbiAgICAgICAgICAgIGlmIChnZXRCb3VuZGluZ0NsaWVudFJlY3QobGFzdEVsKVt0eXBlXSA9PT0gMFxuICAgICAgICAgICAgICAgICYmIGxhc3RFbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgIGxhc3RFbCA9IGxhc3RFbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNpemUgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QobGFzdEVsKVtcbiAgICAgICAgICAgICAgaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0J11cbiAgICAgICAgICAgIC0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGZpcnN0RWwpW1xuICAgICAgICAgICAgICBpc1ZlcnRpY2FsID8gJ3RvcCcgOiAnbGVmdCddXG4gICAgICAgIH1cblxuICAgICAgICBzaXplICs9IGdldEV4dHJhU2l6ZShlbCwgaXNWZXJ0aWNhbClcblxuICAgICAgfVxuXG4gICAgICBlbC5zdHlsZVt0eXBlXSA9IHNpemUgPyBzaXplICsgJ3B4JyA6ICdhdXRvJ1xuXG4gICAgICB0aGlzLnRyYW5zZm9ybU9mZnNldCA9IGdldFRyYW5zZm9ybU9mZnNldCh0aGlzKVxuICAgICAgdGhpcy5taW5TY3JvbGxPZmZzZXQgPSBnZXRNaW5TY3JvbGxPZmZzZXQodGhpcylcbiAgICAgIHRoaXMubWF4U2Nyb2xsT2Zmc2V0ID0gZ2V0TWF4U2Nyb2xsT2Zmc2V0KHRoaXMpXG5cbiAgICAgIHRoaXMuc2Nyb2xsVG8oXG4gICAgICAgIC10aGlzLnRyYW5zZm9ybU9mZnNldFt0aGlzLmF4aXNdXG4gICAgICAgIC0gdGhpcy5vcHRpb25zW3RoaXMuYXhpcyArICdQYWRkaW5nVG9wJ11cbiAgICAgIClcbiAgICAgIGZpcmVFdmVudCh0aGlzLCAnY29udGVudHJlZnJlc2gnKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBvZmZzZXQ6IGZ1bmN0aW9uIChjaGlsZEVsKSB7XG4gICAgICB2YXIgZWxSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMuZWxlbWVudClcbiAgICAgIHZhciBjaGlsZFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoY2hpbGRFbClcbiAgICAgIGlmICh0aGlzLmF4aXMgPT09ICd5Jykge1xuICAgICAgICB2YXIgb2Zmc2V0UmVjdCA9IHtcbiAgICAgICAgICB0b3A6IGNoaWxkUmVjdC50b3AgLSBlbFJlY3QudG9wIC0gdGhpcy5vcHRpb25zLnlQYWRkaW5nVG9wLFxuICAgICAgICAgIGxlZnQ6IGNoaWxkUmVjdC5sZWZ0IC0gZWxSZWN0LmxlZnQsXG4gICAgICAgICAgcmlnaHQ6IGVsUmVjdC5yaWdodCAtIGNoaWxkUmVjdC5yaWdodCxcbiAgICAgICAgICB3aWR0aDogY2hpbGRSZWN0LndpZHRoLFxuICAgICAgICAgIGhlaWdodDogY2hpbGRSZWN0LmhlaWdodFxuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0UmVjdC5ib3R0b20gPSBvZmZzZXRSZWN0LnRvcCArIG9mZnNldFJlY3QuaGVpZ2h0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb2Zmc2V0UmVjdCA9IHtcbiAgICAgICAgICB0b3A6IGNoaWxkUmVjdC50b3AgLSBlbFJlY3QudG9wLFxuICAgICAgICAgIGJvdHRvbTogZWxSZWN0LmJvdHRvbSAtIGNoaWxkUmVjdC5ib3R0b20sXG4gICAgICAgICAgbGVmdDogY2hpbGRSZWN0LmxlZnQgLSBlbFJlY3QubGVmdCAtIHRoaXMub3B0aW9ucy54UGFkZGluZ1RvcCxcbiAgICAgICAgICB3aWR0aDogY2hpbGRSZWN0LndpZHRoLFxuICAgICAgICAgIGhlaWdodDogY2hpbGRSZWN0LmhlaWdodFxuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0UmVjdC5yaWdodCA9IG9mZnNldFJlY3QubGVmdCArIG9mZnNldFJlY3Qud2lkdGhcbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXRSZWN0XG4gICAgfSxcblxuICAgIGdldFJlY3Q6IGZ1bmN0aW9uIChjaGlsZEVsKSB7XG4gICAgICB2YXIgdmlld1JlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy52aWV3cG9ydClcbiAgICAgIHZhciBjaGlsZFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoY2hpbGRFbClcbiAgICAgIGlmICh0aGlzLmF4aXMgPT09ICd5Jykge1xuICAgICAgICB2YXIgb2Zmc2V0UmVjdCA9IHtcbiAgICAgICAgICB0b3A6IGNoaWxkUmVjdC50b3AgLSB2aWV3UmVjdC50b3AsXG4gICAgICAgICAgbGVmdDogY2hpbGRSZWN0LmxlZnQgLSB2aWV3UmVjdC5sZWZ0LFxuICAgICAgICAgIHJpZ2h0OiB2aWV3UmVjdC5yaWdodCAtIGNoaWxkUmVjdC5yaWdodCxcbiAgICAgICAgICB3aWR0aDogY2hpbGRSZWN0LndpZHRoLFxuICAgICAgICAgIGhlaWdodDogY2hpbGRSZWN0LmhlaWdodFxuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0UmVjdC5ib3R0b20gPSBvZmZzZXRSZWN0LnRvcCArIG9mZnNldFJlY3QuaGVpZ2h0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb2Zmc2V0UmVjdCA9IHtcbiAgICAgICAgICB0b3A6IGNoaWxkUmVjdC50b3AgLSB2aWV3UmVjdC50b3AsXG4gICAgICAgICAgYm90dG9tOiB2aWV3UmVjdC5ib3R0b20gLSBjaGlsZFJlY3QuYm90dG9tLFxuICAgICAgICAgIGxlZnQ6IGNoaWxkUmVjdC5sZWZ0IC0gdmlld1JlY3QubGVmdCxcbiAgICAgICAgICB3aWR0aDogY2hpbGRSZWN0LndpZHRoLFxuICAgICAgICAgIGhlaWdodDogY2hpbGRSZWN0LmhlaWdodFxuICAgICAgICB9XG5cbiAgICAgICAgb2Zmc2V0UmVjdC5yaWdodCA9IG9mZnNldFJlY3QubGVmdCArIG9mZnNldFJlY3Qud2lkdGhcbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXRSZWN0XG4gICAgfSxcblxuICAgIGlzSW5WaWV3OiBmdW5jdGlvbiAoY2hpbGRFbCkge1xuICAgICAgdmFyIHZpZXdSZWN0ID0gdGhpcy5nZXRSZWN0KHRoaXMudmlld3BvcnQpXG4gICAgICB2YXIgY2hpbGRSZWN0ID0gdGhpcy5nZXRSZWN0KGNoaWxkRWwpXG4gICAgICBpZiAodGhpcy5heGlzID09PSAneScpIHtcbiAgICAgICAgcmV0dXJuIHZpZXdSZWN0LnRvcCA8IGNoaWxkUmVjdC5ib3R0b21cbiAgICAgICAgICAmJiB2aWV3UmVjdC5ib3R0b20gPiBjaGlsZFJlY3QudG9wXG4gICAgICB9XG4gICAgICByZXR1cm4gdmlld1JlY3QubGVmdCA8IGNoaWxkUmVjdC5yaWdodFxuICAgICAgICAmJiB2aWV3UmVjdC5yaWdodCA+IGNoaWxkUmVjdC5sZWZ0XG4gICAgfSxcblxuICAgIHNjcm9sbFRvOiBmdW5jdGlvbiAob2Zmc2V0LCBpc1Ntb290aCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudFxuXG4gICAgICBvZmZzZXQgPSAtb2Zmc2V0IC0gdGhpcy5vcHRpb25zW3RoaXMuYXhpcyArICdQYWRkaW5nVG9wJ11cbiAgICAgIG9mZnNldCA9IHRvdWNoQm91bmRhcnkodGhpcywgb2Zmc2V0KVxuXG4gICAgICBpc1Njcm9sbGluZyA9IHRydWVcbiAgICAgIGlmIChpc1Ntb290aCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVzZUZyYW1lQW5pbWF0aW9uKSB7XG4gICAgICAgICAgdmFyIHMwID0gZ2V0VHJhbnNmb3JtT2Zmc2V0KHRoYXQpW3RoaXMuYXhpc11cbiAgICAgICAgICB2YXIgX3MgPSBvZmZzZXQgLSBzMFxuICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbiA9IG5ldyBsaWIuYW5pbWF0aW9uKFxuICAgICAgICAgICAgICA0MDAsXG4gICAgICAgICAgICAgIGxpYi5jdWJpY2Jlemllci5lYXNlSW5PdXQsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChpMSwgaTIpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAoczAgKyBfcyAqIGkyKS50b0ZpeGVkKDIpXG4gICAgICAgICAgICBzZXRUcmFuc2Zvcm1TdHlsZSh0aGF0LCBvZmZzZXQpXG4gICAgICAgICAgICBmaXJlRXZlbnQodGhhdCwgJ3Njcm9sbGluZycpXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbi5vbmVuZChzY3JvbGxFbmQpXG5cbiAgICAgICAgICBzY3JvbGxBbmltYXRpb24ucGxheSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0VHJhbnNpdGlvbkVuZEhhbmRsZXIoc2Nyb2xsRW5kLCA0MDApXG4gICAgICAgICAgc2V0VHJhbnNpdGlvblN0eWxlKHRoYXQsICcwLjRzJywgJ2Vhc2UtaW4tb3V0JylcbiAgICAgICAgICBzZXRUcmFuc2Zvcm1TdHlsZSh0aGF0LCBvZmZzZXQpXG5cbiAgICAgICAgICBmdW5jdGlvbiBfY2FuY2VsU2Nyb2xsKCkge1xuICAgICAgICAgICAgaWYgKGlzU2Nyb2xsaW5nICYmIHRoYXQuZW5hYmxlZCkge1xuICAgICAgICAgICAgICBmaXJlRXZlbnQodGhhdCwgJ3Njcm9sbGluZycpXG4gICAgICAgICAgICAgIGxpYi5hbmltYXRpb24ucmVxdWVzdEZyYW1lKF9jYW5jZWxTY3JvbGwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGliLmFuaW1hdGlvbi5yZXF1ZXN0RnJhbWUoX2NhbmNlbFNjcm9sbClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudXNlRnJhbWVBbmltYXRpb24pIHtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uU3R5bGUodGhhdCwgJycsICcnKVxuICAgICAgICB9XG4gICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldClcbiAgICAgICAgc2Nyb2xsRW5kKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgc2Nyb2xsVG9FbGVtZW50OiBmdW5jdGlvbiAoY2hpbGRFbCwgaXNTbW9vdGgsIHRvcE9mZnNldCkge1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0KGNoaWxkRWwpXG4gICAgICBvZmZzZXQgPSBvZmZzZXRbdGhpcy5heGlzID09PSAneSc/J3RvcCc6J2xlZnQnXVxuICAgICAgdG9wT2Zmc2V0ICYmIChvZmZzZXQgKz0gdG9wT2Zmc2V0KVxuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVG8ob2Zmc2V0LCBpc1Ntb290aClcbiAgICB9LFxuXG4gICAgZ2V0Vmlld1dpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMudmlld3BvcnQpLndpZHRoXG4gICAgfSxcblxuICAgIGdldFZpZXdIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy52aWV3cG9ydCkuaGVpZ2h0XG4gICAgfSxcblxuICAgIGFkZFB1bGxkb3duSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3B1bGxkb3duZW5kJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhhdC5kaXNhYmxlKClcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoYXQsIGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LnNjcm9sbFRvKDAsIHRydWUpXG4gICAgICAgICAgdGhhdC5yZWZyZXNoKClcbiAgICAgICAgICB0aGF0LmVuYWJsZSgpXG4gICAgICAgIH0pXG4gICAgICB9LCBmYWxzZSlcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgYWRkUHVsbHVwSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuXG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncHVsbHVwZW5kJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhhdC5kaXNhYmxlKClcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoYXQsIGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LnNjcm9sbFRvKHRoYXQuZ2V0U2Nyb2xsSGVpZ2h0KCksIHRydWUpXG4gICAgICAgICAgdGhhdC5yZWZyZXNoKClcbiAgICAgICAgICB0aGF0LmVuYWJsZSgpXG4gICAgICAgIH0pXG4gICAgICB9LCBmYWxzZSlcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgYWRkU2Nyb2xsc3RhcnRIYW5kbGVyOiBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsc3RhcnQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBoYW5kbGVyLmNhbGwodGhhdCwgZSlcbiAgICAgIH0sIGZhbHNlKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBhZGRTY3JvbGxpbmdIYW5kbGVyOiBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsaW5nJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoYXQsIGUpXG4gICAgICB9LCBmYWxzZSlcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgYWRkU2Nyb2xsZW5kSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbGVuZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGF0LCBlKVxuICAgICAgfSwgZmFsc2UpXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGFkZENvbnRlbnRyZW5mcmVzaEhhbmRsZXI6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZW50cmVmcmVzaCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGF0LCBlKVxuICAgICAgfSwgZmFsc2UpXG4gICAgfSxcblxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChuYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGF0LCBlKVxuICAgICAgfSwgISF1c2VDYXB0dXJlKVxuICAgIH0sXG5cbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAobmFtZSwgaGFuZGxlcikge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBoYW5kbGVyLmNhbGwodGhhdCwgZSlcbiAgICAgIH0pXG4gICAgfSxcblxuICAgIGVuYWJsZVBsdWdpbjogZnVuY3Rpb24gKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwbHVnaW4gPSBwbHVnaW5zW25hbWVdXG4gICAgICBpZiAocGx1Z2luICYmICF0aGlzLnBsdWdpbnNbbmFtZV0pIHtcbiAgICAgICAgdGhpcy5wbHVnaW5zW25hbWVdID0gdHJ1ZVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgICAgICBwbHVnaW4uY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBrIGluIHByb3RvKSB7XG4gICAgdGhpc1trXSA9IHByb3RvW2tdXG4gIH1cbiAgLy8gZGVsZXRlIHByb3RvXG59XG5cbmxpYi5zY3JvbGwgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgIShhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzBdXG4gICAgaWYgKG9wdGlvbnMuc2Nyb2xsRWxlbWVudCkge1xuICAgICAgZWwgPSBvcHRpb25zLnNjcm9sbEVsZW1lbnRcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2Nyb2xsV3JhcCkge1xuICAgICAgZWwgPSBvcHRpb25zLnNjcm9sbFdyYXAuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBzY3JvbGwgZWxlbWVudCcpXG4gICAgfVxuICB9XG5cbiAgaWYgKCFlbC5wYXJlbnROb2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBkb20gdHJlZScpXG4gIH1cbiAgaWYgKG9wdGlvbnNcbiAgICAgICYmIG9wdGlvbnMuZGlyZWN0aW9uXG4gICAgICAmJiBbJ3gnLCAneSddLmluZGV4T2Yob3B0aW9ucy5kaXJlY3Rpb24pIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgZGlyZWN0aW9uJylcbiAgfVxuXG4gIHZhciBzY3JvbGxcbiAgaWYgKG9wdGlvbnMuZG93bmdyYWRlID09PSB0cnVlXG4gICAgICAmJiBsaWIuc2Nyb2xsLmRvd25ncmFkZSkge1xuICAgIHNjcm9sbCA9IGxpYi5zY3JvbGwuZG93bmdyYWRlKGVsLCBvcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGlmIChlbC5zY3JvbGxJZCkge1xuICAgICAgc2Nyb2xsID0gc2Nyb2xsT2Jqc1tlbC5zY3JvbGxJZF1cbiAgICB9IGVsc2Uge1xuICAgICAgc2Nyb2xsID0gbmV3IFNjcm9sbChlbCwgb3B0aW9ucylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNjcm9sbFxufVxuXG5saWIuc2Nyb2xsLnBsdWdpbiA9IGZ1bmN0aW9uIChuYW1lLCBjb25zdHJ1Y3Rvcikge1xuICBpZiAoY29uc3RydWN0b3IpIHtcbiAgICBuYW1lID0gbmFtZS5zcGxpdCgnLCcpXG4gICAgbmFtZS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICBwbHVnaW5zW25dID0gY29uc3RydWN0b3JcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwbHVnaW5zW25hbWVdXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL3Njcm9sbC5qc1xuICoqLyIsIi8qIGdsb2JhbCBsaWI6IHRydWUgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogdHJhbnNmZXIgUXVhZHJhdGljIEJlemllciBDdXJ2ZSB0byBDdWJpYyBCZXppZXIgQ3VydmVcbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGEgYWJzY2lzc2Egb2YgcDFcbiAqIEBwYXJhbSAge251bWJlcn0gYiBvcmRpbmF0ZSBvZiBwMVxuICogQHJldHVybiB7QXJyYXl9IHBhcmFtZXRlciBtYXRyaXggZm9yIGN1YmljIGJlemllciBjdXJ2ZVxuICogICBsaWtlIFtbcDF4LCBwMXldLCBbcDJ4LCBwMnldXVxuICovXG5mdW5jdGlvbiBxdWFkcmF0aWMyY3ViaWNCZXppZXIgKGEsIGIpIHtcbiAgcmV0dXJuIFtcbiAgICBbXG4gICAgICAoYSAvIDMgKyAoYSArIGIpIC8gMyAtIGEpIC8gKGIgLSBhKSxcbiAgICAgIChhICogYSAvIDMgKyBhICogYiAqIDIgLyAzIC0gYSAqIGEpIC8gKGIgKiBiIC0gYSAqIGEpXG4gICAgXSwgW1xuICAgICAgKGIgLyAzICsgKGEgKyBiKSAvIDMgLSBhKSAvIChiIC0gYSksXG4gICAgICAoYiAqIGIgLyAzICsgYSAqIGIgKiAyIC8gMyAtIGEgKiBhKSAvIChiICogYiAtIGEgKiBhKVxuICAgIF1cbiAgXVxufVxuXG4vKipcbiAqIGRlcml2ZSBwb3NpdGlvbiBkYXRhIGZyb20ga25vd2luZyBtb3Rpb24gcGFyYW1ldGVyc1xuICogYmFzZSBvbiBOZXd0b24ncyBzZWNvbmQgbGF3OiBzID0gdnQgKyBhdF4yLzJcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIG9iamVjdCBvZiB7IHYsIGEsIHMsIHQgfVxuICogICAtIHY6IGluaXRpYWwgdmVsb2NpdHlcbiAqICAgLSBhOiBhY2NlbGVyYXRlIHNwZWVkXG4gKiAgIC0gdDogdGltZVxuICogICAtIHM6IHNoaWZ0aW5nXG4gKi9cbmZ1bmN0aW9uIE1vdGlvbiAoY29uZmlnKSB7XG4gIHRoaXMudiA9IGNvbmZpZy52IHx8IDBcbiAgdGhpcy5hID0gY29uZmlnLmEgfHwgMFxuXG4gIGlmICh0eXBlb2YgY29uZmlnLnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy50ID0gY29uZmlnLnRcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29uZmlnLnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5zID0gY29uZmlnLnNcbiAgfVxuXG4gIC8vIGRlcml2ZSB0aW1lIGZyb20gc2hpZnRpbmdcbiAgaWYgKHR5cGVvZiB0aGlzLnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnQgPSAtdGhpcy52IC8gdGhpcy5hXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgdDEgPSAoTWF0aC5zcXJ0KHRoaXMudiAqIHRoaXMudiArIDIgKiB0aGlzLmEgKiB0aGlzLnMpIC0gdGhpcy52KVxuICAgICAgICAvIHRoaXMuYVxuICAgICAgY29uc3QgdDIgPSAoLU1hdGguc3FydCh0aGlzLnYgKiB0aGlzLnYgKyAyICogdGhpcy5hICogdGhpcy5zKSAtIHRoaXMudilcbiAgICAgICAgLyB0aGlzLmFcbiAgICAgIHRoaXMudCA9IE1hdGgubWluKHQxLCB0MilcbiAgICB9XG4gIH1cblxuICAvLyBkZXJpdmUgc2hpZnRpbmcgZnJvbSB0aW1lXG4gIGlmICh0eXBlb2YgdGhpcy5zID09PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMucyA9IHRoaXMuYSAqIHRoaXMudCAqIHRoaXMudCAvIDIgKyB0aGlzLnYgKiB0aGlzLnRcbiAgfVxufVxuXG4vKipcbiAqIGRlcml2ZSBjdWJpYyBiZXppZXIgcGFyYW1ldGVycyBmcm9tIG1vdGlvbiBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJuIHtBcnJheX0gcGFyYW1ldGVyIG1hdHJpeCBmb3IgY3ViaWMgYmV6aWVyIGN1cnZlXG4gKiAgIGxpa2UgW1twMXgsIHAxeV0sIFtwMngsIHAyeV1dXG4gKi9cbk1vdGlvbi5wcm90b3R5cGUuZ2VuZXJhdGVDdWJpY0JlemllciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHF1YWRyYXRpYzJjdWJpY0JlemllcihcbiAgICB0aGlzLnYgLyB0aGlzLmEsIHRoaXMudCArIHRoaXMudiAvIHRoaXMuYVxuICApXG59XG5cbiFsaWIgJiYgKGxpYiA9IHt9KVxubGliLm1vdGlvbiA9IE1vdGlvblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vdGlvblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3Njcm9sbGFibGUvbW90aW9uLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBsaXN0TW9kdWxlIGZyb20gJy4vbGlzdCdcblxuZnVuY3Rpb24gaW5pdCAoV2VleCkge1xuICBjb25zdCBMaXN0ID0gbGlzdE1vZHVsZS5pbml0KFdlZXgpXG5cbiAgZnVuY3Rpb24gSGxpc3QgKGRhdGEsIG5vZGVUeXBlKSB7XG4gICAgZGF0YS5hdHRyLmRpcmVjdGlvbiA9ICdoJ1xuICAgIExpc3QuY2FsbCh0aGlzLCBkYXRhLCBub2RlVHlwZSlcbiAgfVxuXG4gIEhsaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGlzdC5wcm90b3R5cGUpXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnaGxpc3QnLCBIbGlzdClcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBpbml0IH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL2xpc3QvaGxpc3QuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IHNjcm9sbGFibGVNb2R1bGUgZnJvbSAnLi4vc2Nyb2xsYWJsZSdcblxuZnVuY3Rpb24gaW5pdCAoV2VleCkge1xuICBjb25zdCBTY3JvbGxhYmxlID0gc2Nyb2xsYWJsZU1vZHVsZS5pbml0KFdlZXgpXG4gIGZ1bmN0aW9uIFNjcm9sbGVyIChkYXRhLCBub2RlVHlwZSkge1xuICAgIFNjcm9sbGFibGUuY2FsbCh0aGlzLCBkYXRhLCBub2RlVHlwZSlcbiAgfVxuICBjb25zdCBleHRlbmQgPSBXZWV4LnV0aWxzLmV4dGVuZFxuXG4gIFNjcm9sbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2Nyb2xsYWJsZS5wcm90b3R5cGUpXG4gIGV4dGVuZChTY3JvbGxlci5wcm90b3R5cGUsIHtcbiAgICBjcmVhdGUgKCkge1xuICAgICAgY29uc3Qgbm9kZSA9IFNjcm9sbGFibGUucHJvdG90eXBlLmNyZWF0ZS5jYWxsKHRoaXMpXG4gICAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ3Njcm9sbGVyLXdyYXAnKVxuICAgICAgdGhpcy5zY3JvbGxFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3Njcm9sbGVyLWVsZW1lbnQnKVxuICAgICAgcmV0dXJuIG5vZGVcbiAgICB9XG4gIH0pXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnc2Nyb2xsZXInLCBTY3JvbGxlcilcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBpbml0IH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL3Njcm9sbGVyL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCAnLi9yZWZyZXNoLmNzcydcblxuY29uc3QgcGFyZW50cyA9IFsnc2Nyb2xsZXInLCAnbGlzdCcsICd2bGlzdCddXG5cbi8vIE9ubHkgaWYgcHVsbGRvd24gb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoaXMgdmFsdWUgY2FuIHRoaXNcbi8vIGNvbXBvbmVudCB0cmlnZ2VyIHRoZSAncmVmcmVzaCcgZXZlbnQsIG90aGVyd2lzZSBqdXN0IHJlY292ZXJcbi8vIHRvIHRoZSBzdGFydCBwb2ludC5cbmNvbnN0IERFRkFVTFRfQ0xBTVAgPSAxMzBcbmNvbnN0IERFRkFVTFRfQUxJR05fSVRFTVMgPSAnY2VudGVyJ1xuY29uc3QgREVGQVVMVF9KVVNUSUZZX0NPTlRFTlQgPSAnY2VudGVyJ1xuXG5mdW5jdGlvbiBhZGp1c3RIZWlnaHQgKHJlZnJlc2gsIHZhbCkge1xuICByZWZyZXNoLm5vZGUuc3R5bGUuaGVpZ2h0ID0gdmFsICsgJ3B4J1xufVxuXG4vLyBmdW5jdGlvbiBhZEp1c3RQb3NpdGlvbiAocmVmcmVzaCwgdmFsKSB7XG4vLyAgIHJlZnJlc2gubm9kZS5zdHlsZS50b3AgPSAtdmFsICsgJ3B4J1xuLy8gfVxuXG5mdW5jdGlvbiBoYW5kbGVSZWZyZXNoIChyZWZyZXNoLCBlKSB7XG4gIHJlZnJlc2gubm9kZS5zdHlsZS5oZWlnaHQgPSByZWZyZXNoLmNsYW1wICsgJ3B4J1xuICByZWZyZXNoLmRpc3BhdGNoRXZlbnQoJ3JlZnJlc2gnKVxuICByZWZyZXNoLmlzUmVmcmVzaGluZyA9IHRydWVcbn1cblxuZnVuY3Rpb24gc2hvdyAocmVmcmVzaCkge1xuICByZWZyZXNoLmRpc3BsYXkgPSB0cnVlXG4gIHJlZnJlc2gubm9kZS5zdHlsZS5kaXNwbGF5ID0gJy13ZWJraXQtYm94J1xuICByZWZyZXNoLm5vZGUuc3R5bGUuZGlzcGxheSA9ICctd2Via2l0LWZsZXgnXG4gIHJlZnJlc2gubm9kZS5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXG59XG5cbmZ1bmN0aW9uIGhpZGUgKHJlZnJlc2gpIHtcbiAgcmVmcmVzaC5kaXNwbGF5ID0gZmFsc2VcbiAgcmVmcmVzaC5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgcmVmcmVzaC5pc1JlZnJlc2hpbmcgPSBmYWxzZVxufVxuXG5jb25zdCBwcm90byA9IHtcbiAgY3JlYXRlICgpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtY29udGFpbmVyJywgJ3dlZXgtcmVmcmVzaCcpXG4gICAgcmV0dXJuIG5vZGVcbiAgfSxcblxuICBvbkFwcGVuZCAoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKVxuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgaWYgKHBhcmVudHMuaW5kZXhPZihwYXJlbnQuZGF0YS50eXBlKSA9PT0gLTEpIHtcbiAgICAgIC8vIG5vdCBpbiBhIHNjcm9sbGVyIG9yIGEgbGlzdFxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMucmVmcmVzaFBsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB0aGlzLnJlZnJlc2hQbGFjZWhvbGRlci5jbGFzc0xpc3QuYWRkKCd3ZWV4LXJlZnJlc2gtcGxhY2Vob2xkZXInKVxuICAgIHRoaXMucmVmcmVzaFBsYWNlaG9sZGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICB0aGlzLnJlZnJlc2hQbGFjZWhvbGRlci5zdHlsZS53aWR0aCA9ICcwcHgnXG4gICAgdGhpcy5yZWZyZXNoUGxhY2Vob2xkZXIuc3R5bGUuaGVpZ2h0ID0gJzBweCdcbiAgICBjb25zdCBzY3JvbGxFbGVtZW50ID0gcGFyZW50LnNjcm9sbEVsZW1lbnQgfHwgcGFyZW50Lmxpc3RFbGVtZW50XG4gICAgc2Nyb2xsRWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5yZWZyZXNoUGxhY2Vob2xkZXIsIHRoaXMubm9kZSlcbiAgICBwYXJlbnQubm9kZS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpXG4gICAgcGFyZW50LnNjcm9sbGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3B1bGxkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChzZWxmLmlzUmVmcmVzaGluZykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGFkanVzdEhlaWdodChzZWxmLCBNYXRoLmFicyhlLnNjcm9sbE9iai5nZXRTY3JvbGxUb3AoKSkpXG4gICAgICBpZiAoIXNlbGYuZGlzcGxheSkge1xuICAgICAgICBzaG93KHNlbGYpXG4gICAgICB9XG4gICAgfSlcbiAgICBwYXJlbnQuc2Nyb2xsZXIuYWRkRXZlbnRMaXN0ZW5lcigncHVsbGRvd25lbmQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHNlbGYuaXNSZWZyZXNoaW5nKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgdG9wID0gTWF0aC5hYnMoZS5zY3JvbGxPYmouZ2V0U2Nyb2xsVG9wKCkpXG4gICAgICBpZiAodG9wID4gc2VsZi5jbGFtcCkge1xuICAgICAgICBoYW5kbGVSZWZyZXNoKHNlbGYsIGUpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaGlkZShzZWxmKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuY29uc3QgYXR0ciA9IHtcbiAgZGlzcGxheTogZnVuY3Rpb24gKHZhbCkge1xuICAgIGlmICh2YWwgPT09ICdzaG93Jykge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNob3codGhpcylcbiAgICAgIH0uYmluZCh0aGlzKSwgMClcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsID09PSAnaGlkZScpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBoaWRlKHRoaXMpXG4gICAgICB9LmJpbmQodGhpcyksIDApXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0gYXR0ciBcXCdkaXNwbGF5XFwnIG9mIDxyZWZyZXNoPlxcJzogdmFsdWUgJ1xuICAgICAgICArIHZhbFxuICAgICAgICArICcgaXMgaW52YWxpZC4gU2hvdWxkIGJlIFxcJ3Nob3dcXCcgb3IgXFwnaGlkZVxcJycpXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHN0eWxlID0ge1xuICBoZWlnaHQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbClcbiAgICBpZiAoaXNOYU4odmFsKSB8fCB2YWwgPCAwKSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKCdbaDUtcmVuZGVyXSA8cmVmcmVzaD5cXCdzIGhlaWdodCAoJyArIHZhbCArICcpIGlzIGludmFsaWQuJylcbiAgICB9XG4gICAgdGhpcy5jbGFtcCA9IHZhbCAqIHRoaXMuZGF0YS5zY2FsZVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXQgKFdlZXgpIHtcbiAgY29uc3QgQ29tcG9uZW50ID0gV2VleC5Db21wb25lbnRcbiAgY29uc3QgZXh0ZW5kID0gV2VleC51dGlscy5leHRlbmRcblxuICBmdW5jdGlvbiBSZWZyZXNoIChkYXRhKSB7XG4gICAgdGhpcy5pc1JlZnJlc2hpbmcgPSBmYWxzZVxuICAgIHRoaXMuY2xhbXAgPSAoZGF0YS5zdHlsZS5oZWlnaHQgfHwgREVGQVVMVF9DTEFNUCkgKiBkYXRhLnNjYWxlXG4gICAgIWRhdGEuc3R5bGUuYWxpZ25JdGVtcyAmJiAoZGF0YS5zdHlsZS5hbGlnbkl0ZW1zID0gREVGQVVMVF9BTElHTl9JVEVNUylcbiAgICAhZGF0YS5zdHlsZS5qdXN0aWZ5Q29udGVudFxuICAgICAgJiYgKGRhdGEuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSBERUZBVUxUX0pVU1RJRllfQ09OVEVOVClcbiAgICBDb21wb25lbnQuY2FsbCh0aGlzLCBkYXRhKVxuICB9XG4gIFJlZnJlc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlKVxuICBleHRlbmQoUmVmcmVzaC5wcm90b3R5cGUsIHByb3RvKVxuICBleHRlbmQoUmVmcmVzaC5wcm90b3R5cGUsIHsgYXR0ciB9KVxuICBleHRlbmQoUmVmcmVzaC5wcm90b3R5cGUsIHtcbiAgICBzdHlsZTogZXh0ZW5kKE9iamVjdC5jcmVhdGUoQ29tcG9uZW50LnByb3RvdHlwZS5zdHlsZSksIHN0eWxlKVxuICB9KVxuXG4gIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3JlZnJlc2gnLCBSZWZyZXNoKVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9yZWZyZXNoL2luZGV4LmpzXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9yZWZyZXNoLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9yZWZyZXNoLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3JlZnJlc2guY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL3JlZnJlc2gvcmVmcmVzaC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLndlZXgtcmVmcmVzaCB7XFxuICAvLyAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xcbiAgLy8gLXdlYmtpdC1hbGlnbi1pdGVtczogY2VudGVyO1xcbiAgLy8gYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIC8vIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcXG4gIC8vIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAvLyBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDA7XFxuICB6LWluZGV4OiA5OTk5OTk7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNjY2O1xcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL3JlZnJlc2gvcmVmcmVzaC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgJy4vbG9hZGluZy5jc3MnXG5cbmNvbnN0IHBhcmVudHMgPSBbJ3Njcm9sbGVyJywgJ2xpc3QnLCAndmxpc3QnXVxuXG5jb25zdCBERUZBVUxUX0NMQU1QID0gMTMwXG5jb25zdCBERUZBVUxUX0FMSUdOX0lURU1TID0gJ2NlbnRlcidcbmNvbnN0IERFRkFVTFRfSlVTVElGWV9DT05URU5UID0gJ2NlbnRlcidcblxuZnVuY3Rpb24gYWRqdXN0SGVpZ2h0IChsb2FkaW5nLCB2YWwpIHtcbiAgbG9hZGluZy5ub2RlLnN0eWxlLmhlaWdodCA9IHZhbCArICdweCdcbn1cblxuZnVuY3Rpb24gaGFuZGxlTG9hZGluZyAobG9hZGluZywgZSkge1xuICBsb2FkaW5nLm5vZGUuc3R5bGUuaGVpZ2h0ID0gbG9hZGluZy5jbGFtcCArICdweCdcbiAgbG9hZGluZy5kaXNwYXRjaEV2ZW50KCdsb2FkaW5nJylcbiAgbG9hZGluZy5pc0xvYWRpbmcgPSB0cnVlXG59XG5cbmZ1bmN0aW9uIHNob3cgKGxvYWRpbmcpIHtcbiAgbG9hZGluZy5kaXNwbGF5ID0gdHJ1ZVxuICBsb2FkaW5nLm5vZGUuc3R5bGUuZGlzcGxheSA9ICctd2Via2l0LWJveCdcbiAgbG9hZGluZy5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnLXdlYmtpdC1mbGV4J1xuICBsb2FkaW5nLm5vZGUuc3R5bGUuZGlzcGxheSA9ICdmbGV4J1xufVxuXG5mdW5jdGlvbiBoaWRlIChsb2FkaW5nKSB7XG4gIGxvYWRpbmcuZGlzcGxheSA9IGZhbHNlXG4gIGxvYWRpbmcubm9kZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gIGxvYWRpbmcuaXNMb2FkaW5nID0gZmFsc2Vcbn1cblxuY29uc3QgcHJvdG8gPSB7XG4gIGNyZWF0ZSAoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgbm9kZS5jbGFzc0xpc3QuYWRkKCd3ZWV4LWNvbnRhaW5lcicsICd3ZWV4LWxvYWRpbmcnKVxuICAgIHJldHVybiBub2RlXG4gIH0sXG5cbiAgb25BcHBlbmQgKCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KClcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIGNvbnN0IHNjcm9sbFdyYXBIZWlnaHQgPSBwYXJlbnQubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICBpZiAocGFyZW50cy5pbmRleE9mKHBhcmVudC5kYXRhLnR5cGUpID09PSAtMSkge1xuICAgICAgLy8gbm90IGluIGEgc2Nyb2xsZXIgb3IgYSBsaXN0XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5sb2FkaW5nUGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMubG9hZGluZ1BsYWNlaG9sZGVyLmNsYXNzTGlzdC5hZGQoJ3dlZXgtbG9hZGluZy1wbGFjZWhvbGRlcicpXG4gICAgdGhpcy5sb2FkaW5nUGxhY2Vob2xkZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgIHRoaXMubG9hZGluZ1BsYWNlaG9sZGVyLnN0eWxlLndpZHRoID0gJzBweCdcbiAgICB0aGlzLmxvYWRpbmdQbGFjZWhvbGRlci5zdHlsZS5oZWlnaHQgPSAnMHB4J1xuICAgIGNvbnN0IHNjcm9sbEVsZW1lbnQgPSBwYXJlbnQuc2Nyb2xsRWxlbWVudCB8fCBwYXJlbnQubGlzdEVsZW1lbnRcbiAgICBzY3JvbGxFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLmxvYWRpbmdQbGFjZWhvbGRlciwgdGhpcy5ub2RlKVxuICAgIHBhcmVudC5ub2RlLmFwcGVuZENoaWxkKHRoaXMubm9kZSlcbiAgICBwYXJlbnQuc2Nyb2xsZXIuYWRkRXZlbnRMaXN0ZW5lcigncHVsbHVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChzZWxmLmlzTG9hZGluZykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IG9iaiA9IGUuc2Nyb2xsT2JqXG4gICAgICBhZGp1c3RIZWlnaHQoc2VsZiwgTWF0aC5hYnMoXG4gICAgICAgIG9iai5nZXRTY3JvbGxIZWlnaHQoKSAtIG9iai5nZXRTY3JvbGxUb3AoKSAtIHNjcm9sbFdyYXBIZWlnaHQpKVxuICAgICAgaWYgKCFzZWxmLmRpc3BsYXkpIHtcbiAgICAgICAgc2hvdyhzZWxmKVxuICAgICAgfVxuICAgIH0pXG4gICAgcGFyZW50LnNjcm9sbGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3B1bGx1cGVuZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoc2VsZi5pc0xvYWRpbmcpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBoYW5kbGVMb2FkaW5nKHNlbGYsIGUpXG4gICAgfSlcbiAgfVxufVxuXG5jb25zdCBhdHRyID0ge1xuICBkaXNwbGF5OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKHZhbCA9PT0gJ3Nob3cnKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2hvdyh0aGlzKVxuICAgICAgfS5iaW5kKHRoaXMpLCAwKVxuICAgIH1cbiAgICBlbHNlIGlmICh2YWwgPT09ICdoaWRlJykge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhpZGUodGhpcylcbiAgICAgIH0uYmluZCh0aGlzKSwgMClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSBhdHRyIFxcJ2Rpc3BsYXlcXCcgb2YgPHJlZnJlc2g+XFwnOiB2YWx1ZSAnXG4gICAgICAgICsgdmFsXG4gICAgICAgICsgJyBpcyBpbnZhbGlkLiBTaG91bGQgYmUgXFwnc2hvd1xcJyBvciBcXCdoaWRlXFwnJylcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgc3R5bGUgPSB7XG4gIGhlaWdodDogZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKVxuICAgIGlmIChOdW1iZXIuaXNOYU4odmFsKSB8fCB2YWwgPCAwKSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKCdbaDUtcmVuZGVyXSA8bG9hZGluZz5cXCdzIGhlaWdodCAoJyArIHZhbCArICcpIGlzIGludmFsaWQuJylcbiAgICB9XG4gICAgdGhpcy5jbGFtcCA9IHZhbCAqIHRoaXMuZGF0YS5zY2FsZVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXQgKFdlZXgpIHtcbiAgY29uc3QgQ29tcG9uZW50ID0gV2VleC5Db21wb25lbnRcbiAgY29uc3QgZXh0ZW5kID0gV2VleC51dGlscy5leHRlbmRcblxuICBmdW5jdGlvbiBMb2FkaW5nIChkYXRhKSB7XG4gICAgdGhpcy5jbGFtcCA9IChkYXRhLnN0eWxlLmhlaWdodCB8fCBERUZBVUxUX0NMQU1QKSAqIGRhdGEuc2NhbGVcbiAgICAhZGF0YS5zdHlsZS5hbGlnbkl0ZW1zICYmIChkYXRhLnN0eWxlLmFsaWduSXRlbXMgPSBERUZBVUxUX0FMSUdOX0lURU1TKVxuICAgICFkYXRhLnN0eWxlLmp1c3RpZnlDb250ZW50XG4gICAgICAmJiAoZGF0YS5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IERFRkFVTFRfSlVTVElGWV9DT05URU5UKVxuICAgIENvbXBvbmVudC5jYWxsKHRoaXMsIGRhdGEpXG4gIH1cbiAgTG9hZGluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbXBvbmVudC5wcm90b3R5cGUpXG4gIGV4dGVuZChMb2FkaW5nLnByb3RvdHlwZSwgcHJvdG8pXG4gIGV4dGVuZChMb2FkaW5nLnByb3RvdHlwZSwgeyBhdHRyIH0pXG4gIGV4dGVuZChMb2FkaW5nLnByb3RvdHlwZSwge1xuICAgIHN0eWxlOiBleHRlbmQoT2JqZWN0LmNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlLnN0eWxlKSwgc3R5bGUpXG4gIH0pXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnbG9hZGluZycsIExvYWRpbmcpXG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgaW5pdCB9XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2Nyb2xsYWJsZS9sb2FkaW5nL2luZGV4LmpzXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9sb2FkaW5nLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9sb2FkaW5nLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2xvYWRpbmcuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL2xvYWRpbmcvbG9hZGluZy5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLndlZXgtbG9hZGluZyB7XFxuICAvLyAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xcbiAgLy8gLXdlYmtpdC1hbGlnbi1pdGVtczogY2VudGVyO1xcbiAgLy8gYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIC8vIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcXG4gIC8vIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAvLyBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBib3R0b206IDA7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNjY2O1xcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zY3JvbGxhYmxlL2xvYWRpbmcvbG9hZGluZy5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCBsaWIgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCAnLi9jYXJyb3VzZWwnXG5pbXBvcnQgJy4vc2xpZGVyLmNzcydcblxuY29uc3QgREVGQVVMVF9JTlRFUlZBTCA9IDMwMDBcblxubGV0IGV4dGVuZCwgQ29tcG9uZW50XG5cbmZ1bmN0aW9uIGlkbGVXaGVuUGFnZURpc2FwcGVhciAoc2xpZGVyKSB7XG4gIGZ1bmN0aW9uIGhhbmRsZVBhZ2VTaG93ICgpIHtcbiAgICBzbGlkZXIuaXNQYWdlU2hvdyA9IHRydWVcbiAgICBzbGlkZXIuYXV0b1BsYXkgJiYgIXNsaWRlci5pc0RvbVJlbmRlcmluZyAmJiBzbGlkZXIucGxheSgpXG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUGFnZUhpZGUgKCkge1xuICAgIHNsaWRlci5pc1BhZ2VTaG93ID0gZmFsc2VcbiAgICBzbGlkZXIuc3RvcCgpXG4gIH1cbiAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VzaG93JywgaGFuZGxlUGFnZVNob3cpXG4gIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIGhhbmRsZVBhZ2VIaWRlKVxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJykge1xuICAgICAgaGFuZGxlUGFnZVNob3coKVxuICAgIH1cbiAgICBlbHNlIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICBoYW5kbGVQYWdlSGlkZSgpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBpZGxlV2hlbkRvbVJlbmRlcmluZyAoc2xpZGVyKSB7XG4gIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdyZW5kZXJlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2xpZGVyLmlzRG9tUmVuZGVyaW5nID0gZmFsc2VcbiAgICBzbGlkZXIuYXV0b1BsYXkgJiYgc2xpZGVyLmlzUGFnZVNob3cgJiYgc2xpZGVyLnBsYXkoKVxuICB9KVxuICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcigncmVuZGVyYmVnaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2xpZGVyLmlzRG9tUmVuZGVyaW5nID0gdHJ1ZVxuICAgIHNsaWRlci5zdG9wKClcbiAgfSlcbn1cblxuZnVuY3Rpb24gdXBkYXRlSW5kaWNhdG9ycyAoc2xpZGVyKSB7XG4gIHNsaWRlci5pbmRpY2F0b3IgJiYgc2xpZGVyLmluZGljYXRvci5zZXRJbmRleChzbGlkZXIuY3VycmVudEluZGV4KVxufVxuXG5mdW5jdGlvbiBnZXRTbGlkZXJDaGFuZ2VIYW5kbGVyIChzbGlkZXIpIHtcbiAgaWYgKCFzbGlkZXIuX3NsaWRlckNoYW5nZUhhbmRsZXIpIHtcbiAgICBzbGlkZXIuX3NsaWRlckNoYW5nZUhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmNhcnJvdXNlbC5pdGVtcy5pbmRleFxuICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSBpbmRleFxuICAgICAgdXBkYXRlSW5kaWNhdG9ycyh0aGlzKVxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdjaGFuZ2UnLCB7IGluZGV4OiBpbmRleCB9KVxuICAgIH0uYmluZChzbGlkZXIpXG4gIH1cbiAgcmV0dXJuIHNsaWRlci5fc2xpZGVyQ2hhbmdlSGFuZGxlclxufVxuXG5mdW5jdGlvbiBkb1JlbmRlciAoc2xpZGVyKSB7XG4gIHNsaWRlci5jcmVhdGVDaGlsZHJlbigpXG4gIHNsaWRlci5vbkFwcGVuZCgpXG59XG5cbmNvbnN0IHByb3RvID0ge1xuICBjcmVhdGUgKCkge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnc2xpZGVyJylcbiAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJ1xuICAgIG5vZGUuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJ1xuICAgIHJldHVybiBub2RlXG4gIH0sXG5cbiAgY3JlYXRlQ2hpbGRyZW4gKCkge1xuICAgIGNvbnN0IGNvbXBvbmVudE1hbmFnZXIgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKVxuXG4gICAgLy8gcmVjcmVhdGUgc2xpZGVyIGNvbnRhaW5lci5cbiAgICBpZiAodGhpcy5zbGlkZXJDb250YWluZXIpIHtcbiAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNsaWRlckNvbnRhaW5lcilcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5kaWNhdG9yKSB7XG4gICAgICB0aGlzLmluZGljYXRvci5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5pbmRpY2F0b3Iubm9kZSlcbiAgICB9XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdXG5cbiAgICBjb25zdCBzbGlkZXJDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpXG4gICAgc2xpZGVyQ29udGFpbmVyLnN0eWxlLmxpc3RTdHlsZSA9ICdub25lJ1xuICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChzbGlkZXJDb250YWluZXIpXG4gICAgdGhpcy5zbGlkZXJDb250YWluZXIgPSBzbGlkZXJDb250YWluZXJcblxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5kYXRhLmNoaWxkcmVuXG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLmRhdGEuc2NhbGVcbiAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICAgIGxldCBpbmRpY2F0b3JEYXRhLCB3aWR0aCwgaGVpZ2h0XG4gICAgbGV0IGNoaWxkV2lkdGggPSAwXG4gICAgbGV0IGNoaWxkSGVpZ2h0ID0gMFxuXG4gICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGRcbiAgICAgICAgY2hpbGRyZW5baV0uc2NhbGUgPSB0aGlzLmRhdGEuc2NhbGVcbiAgICAgICAgY2hpbGRyZW5baV0uaW5zdGFuY2VJZCA9IHRoaXMuZGF0YS5pbnN0YW5jZUlkXG4gICAgICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAnaW5kaWNhdG9yJykge1xuICAgICAgICAgIGluZGljYXRvckRhdGEgPSBleHRlbmQoY2hpbGRyZW5baV0sIHtcbiAgICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgIGFtb3VudDogY2hpbGRyZW4ubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNoaWxkID0gY29tcG9uZW50TWFuYWdlci5jcmVhdGVFbGVtZW50KGNoaWxkcmVuW2ldLCAnbGknKVxuICAgICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZClcbiAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZC5ub2RlKVxuICAgICAgICAgIHdpZHRoID0gY2hpbGQuZGF0YS5zdHlsZS53aWR0aCB8fCAwXG4gICAgICAgICAgaGVpZ2h0ID0gY2hpbGQuZGF0YS5zdHlsZS5oZWlnaHQgfHwgMFxuICAgICAgICAgIHdpZHRoID4gY2hpbGRXaWR0aCAmJiAoY2hpbGRXaWR0aCA9IHdpZHRoKVxuICAgICAgICAgIGhlaWdodCA+IGNoaWxkSGVpZ2h0ICYmIChjaGlsZEhlaWdodCA9IGhlaWdodClcbiAgICAgICAgICBjaGlsZC5wYXJlbnRSZWYgPSB0aGlzLmRhdGEucmVmXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGFwcGVuZCBpbmRpY2F0b3JcbiAgICAgIGlmIChpbmRpY2F0b3JEYXRhKSB7XG4gICAgICAgIGluZGljYXRvckRhdGEuZXh0cmEud2lkdGggPSB0aGlzLmRhdGEuc3R5bGUud2lkdGggfHwgY2hpbGRXaWR0aFxuICAgICAgICBpbmRpY2F0b3JEYXRhLmV4dHJhLmhlaWdodCA9IHRoaXMuZGF0YS5zdHlsZS5oZWlnaHQgfHwgY2hpbGRIZWlnaHRcbiAgICAgICAgdGhpcy5pbmRpY2F0b3IgPSBjb21wb25lbnRNYW5hZ2VyLmNyZWF0ZUVsZW1lbnQoaW5kaWNhdG9yRGF0YSlcbiAgICAgICAgdGhpcy5pbmRpY2F0b3IucGFyZW50UmVmID0gdGhpcy5kYXRhLnJlZlxuICAgICAgICB0aGlzLmluZGljYXRvci5zbGlkZXIgPSB0aGlzXG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLmluZGljYXRvci5ub2RlKVxuICAgICAgfVxuXG4gICAgICBzbGlkZXJDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2NhbGUgKiB0aGlzLmRhdGEuc3R5bGUuaGVpZ2h0ICsgJ3B4J1xuICAgICAgc2xpZGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWdtZW50KVxuICAgIH1cbiAgfSxcblxuICBhcHBlbmRDaGlsZCAoZGF0YSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5kYXRhLmNoaWxkcmVuIHx8ICh0aGlzLmRhdGEuY2hpbGRyZW4gPSBbXSlcbiAgICBjaGlsZHJlbi5wdXNoKGRhdGEpXG4gICAgZG9SZW5kZXIodGhpcylcbiAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdXG4gICAgfVxuICB9LFxuXG4gIGluc2VydEJlZm9yZSAoY2hpbGQsIGJlZm9yZSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5kYXRhLmNoaWxkcmVuXG4gICAgbGV0IGNoaWxkSW5kZXggPSAtMVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0ucmVmID09PSBiZWZvcmUuZGF0YS5yZWYpIHtcbiAgICAgICAgY2hpbGRJbmRleCA9IGlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDAsIGNoaWxkLmRhdGEpXG4gICAgZG9SZW5kZXIodGhpcylcbiAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdXG4gICAgfVxuICB9LFxuXG4gIHJlbW92ZUNoaWxkIChjaGlsZCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5kYXRhLmNoaWxkcmVuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZC5kYXRhLnJlZiA9PT0gY2hpbGRyZW5baV0ucmVmKSB7XG4gICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDEpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkb1JlbmRlcih0aGlzKVxuICB9LFxuXG4gIG9uQXBwZW5kICgpIHtcbiAgICBpZiAodGhpcy5jYXJyb3VzZWwpIHtcbiAgICAgIHRoaXMuY2Fycm91c2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGdldFNsaWRlckNoYW5nZUhhbmRsZXIodGhpcykpXG4gICAgICB0aGlzLmNhcnJvdXNlbC5zdG9wKClcbiAgICAgIHRoaXMuY2Fycm91c2VsID0gbnVsbFxuICAgIH1cbiAgICBjb25zdCBDYXJyb3VzZWwgPSBsaWIuY2Fycm91c2VsXG4gICAgdGhpcy5jYXJyb3VzZWwgPSBuZXcgQ2Fycm91c2VsKHRoaXMuc2xpZGVyQ29udGFpbmVyLCB7XG4gICAgICBhdXRvcGxheTogdGhpcy5hdXRvUGxheSxcbiAgICAgIHVzZUdlc3R1cmU6IHRydWVcbiAgICB9KVxuXG4gICAgdGhpcy5jYXJyb3VzZWwucGxheUludGVydmFsID0gdGhpcy5pbnRlcnZhbFxuICAgIHRoaXMuY2Fycm91c2VsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGdldFNsaWRlckNoYW5nZUhhbmRsZXIodGhpcykpXG4gICAgdGhpcy5jdXJyZW50SW5kZXggPSAwXG5cbiAgICAvLyBwcmVsb2FkIGFsbCBpbWFnZXMgZm9yIHNsaWRlclxuICAgIC8vIGJlY2F1c2U6XG4gICAgLy8gMS4gbGliLWltZyBkb2Vzbid0IGxpc3RlbiB0byBldmVudCB0cmFuc2l0aW9uZW5kXG4gICAgLy8gMi4gZXZlbiBpZiB3ZSBmaXJlIGxhenkgbG9hZCBpbiBzbGlkZXIncyBjaGFuZ2UgZXZlbnQgaGFuZGxlcixcbiAgICAvLyAgICB0aGUgbmV4dCBpbWFnZSBzdGlsbCB3b24ndCBiZSBwcmVsb2FkZWQgdXRpbGwgdGhlIG1vbWVudCBpdFxuICAgIC8vICAgIHNsaWRlcyBpbnRvIHRoZSB2aWV3LCB3aGljaCBpcyB0b28gbGF0ZS5cbiAgICBpZiAodGhpcy5wcmVsb2FkSW1nc1RpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5wcmVsb2FkSW1nc1RpbWVyKVxuICAgIH1cbiAgICAvLyBUaGUgdGltZSBqdXN0IGJlZm9yZSB0aGUgc2Vjb25kIHNsaWRlIGFwcGVhciBhbmQgZW5vdWdoXG4gICAgLy8gZm9yIGFsbCBjaGlsZCBlbGVtZW50cyB0byBhcHBlbmQgaXMgb2suXG4gICAgY29uc3QgcHJlbG9hZFRpbWUgPSAwLjhcbiAgICB0aGlzLnByZWxvYWRJbWdzVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGltZ3MgPSB0aGlzLmNhcnJvdXNlbC5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy53ZWV4LWltZycpXG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGltZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGltZyA9IGltZ3NbaV1cbiAgICAgICAgY29uc3QgaUxhenlTcmMgPSBpbWcuZ2V0QXR0cmlidXRlKCdpLWxhenktc3JjJylcbiAgICAgICAgY29uc3QgaW1nU3JjID0gaW1nLmdldEF0dHJpYnV0ZSgnaW1nLXNyYycpXG4gICAgICAgIGlmIChpTGF6eVNyYykge1xuICAgICAgICAgIGltZy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKCcgKyBpTGF6eVNyYyArICcpJ1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGltZ1NyYykge1xuICAgICAgICAgIGltZy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKCcgKyBpbWdTcmMgKyAnKSdcbiAgICAgICAgfVxuICAgICAgICBpbWcucmVtb3ZlQXR0cmlidXRlKCdpLWxhenktc3JjJylcbiAgICAgICAgaW1nLnJlbW92ZUF0dHJpYnV0ZSgnaW1nLXNyYycpXG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpLCBwcmVsb2FkVGltZSAqIDEwMDApXG5cbiAgICAvLyBhdm9pZCBwYWdlIHNjcm9sbCB3aGVuIHBhbm5pbmdcbiAgICBsZXQgcGFubmluZyA9IGZhbHNlXG4gICAgdGhpcy5jYXJyb3VzZWwuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwYW5zdGFydCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIWUuaXNWZXJ0aWNhbCkge1xuICAgICAgICBwYW5uaW5nID0gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5jYXJyb3VzZWwuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwYW5lbmQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFlLmlzVmVydGljYWwpIHtcbiAgICAgICAgcGFubmluZyA9IGZhbHNlXG4gICAgICB9XG4gICAgfSlcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAocGFubmluZykge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG5cbiAgICBDb21wb25lbnQucHJvdG90eXBlLm9uQXBwZW5kLmNhbGwodGhpcylcbiAgfSxcblxuICBwbGF5ICgpIHtcbiAgICB0aGlzLmNhcnJvdXNlbC5wbGF5KClcbiAgfSxcblxuICBzdG9wICgpIHtcbiAgICB0aGlzLmNhcnJvdXNlbC5zdG9wKClcbiAgfSxcblxuICBzbGlkZVRvIChpbmRleCkge1xuICAgIGNvbnN0IG9mZnNldCA9IGluZGV4IC0gdGhpcy5jdXJyZW50SW5kZXhcbiAgICB0aGlzLmNhcnJvdXNlbC5pdGVtcy5zbGlkZShvZmZzZXQpXG4gIH1cbn1cblxuY29uc3QgYXR0ciA9IHtcbiAgaW50ZXJ2YWw6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLmludGVydmFsID0gcGFyc2VJbnQodmFsKSB8fCBERUZBVUxUX0lOVEVSVkFMXG4gICAgaWYgKHRoaXMuY2Fycm91c2VsKSB7XG4gICAgICB0aGlzLmNhcnJvdXNlbC5wbGF5SW50ZXJ2YWwgPSB0aGlzLmludGVydmFsXG4gICAgfVxuICB9LFxuXG4gIGluZGV4OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzXG4gICAgZnVuY3Rpb24gZG9TbGlkZSAoaW5kZXgpIHtcbiAgICAgIGluZGV4ID0gcGFyc2VJbnQoaW5kZXgpXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGlzTmFOKGluZGV4KSkge1xuICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0gaW52YWxpZCBpbmRleCAnLCBpbmRleClcbiAgICAgIH1cbiAgICAgIF90aGlzLnNsaWRlVG8oaW5kZXgpXG4gICAgICBpZiAoX3RoaXMuX3VwZGF0ZUluZGV4KSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW5kZXJlbmQnLCBfdGhpcy5fdXBkYXRlSW5kZXgpXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRG9tUmVuZGVyaW5nKSB7XG4gICAgICBjb25zdCBwcmUgPSAhIXRoaXMuX3VwZGF0ZUluZGV4XG4gICAgICB0aGlzLl91cGRhdGVJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuYXV0b1BsYXkgJiYgX3RoaXMuaXNQYWdlU2hvdyAmJiBfdGhpcy5wbGF5KClcbiAgICAgICAgZG9TbGlkZSh2YWwpXG4gICAgICB9XG4gICAgICAhcHJlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZW5kZXJlbmQnLCB0aGlzLl91cGRhdGVJbmRleClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBkb1NsaWRlKHZhbClcbiAgICB9XG4gIH0sXG5cbiAgcGxheXN0YXR1czogZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMucGxheXN0YXR1cyA9IHZhbCAmJiB2YWwgIT09ICdmYWxzZSdcbiAgICB0aGlzLmF1dG9QbGF5ID0gdGhpcy5wbGF5c3RhdHVzXG4gICAgaWYgKHRoaXMuY2Fycm91c2VsKSB7XG4gICAgICBpZiAodGhpcy5wbGF5c3RhdHVzKSB7XG4gICAgICAgIHRoaXMucGxheSgpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zdG9wKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gc3VwcG9ydCBwbGF5c3RhdHVzJyBhbGlhcyBhdXRvLXBsYXkgZm9yIGNvbXBhdGliaWxpdHlcbiAgYXV0b1BsYXk6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLmF0dHIucGxheXN0YXR1cy5jYWxsKHRoaXMsIHZhbClcbiAgfVxufVxuXG5jb25zdCBldmVudCA9IHtcbiAgY2hhbmdlOiB7XG4gICAgdXBkYXRvcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBpbmRleDogdGhpcy5jdXJyZW50SW5kZXhcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0IChXZWV4KSB7XG4gIENvbXBvbmVudCA9IFdlZXguQ29tcG9uZW50XG4gIGV4dGVuZCA9IFdlZXgudXRpbHMuZXh0ZW5kXG5cbiAgZnVuY3Rpb24gU2xpZGVyIChkYXRhKSB7XG4gICAgdGhpcy5hdXRvUGxheSA9IGZhbHNlICAvLyBkZWZhdWx0IHZhbHVlIGlzIGZhbHNlLlxuICAgIHRoaXMuaW50ZXJ2YWwgPSBERUZBVUxUX0lOVEVSVkFMXG4gICAgdGhpcy5kaXJlY3Rpb24gPSAncm93JyAvLyAnY29sdW1uJyBpcyBub3QgdGVtcG9yYXJpbHkgc3VwcG9ydGVkLlxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXVxuICAgIHRoaXMuaXNQYWdlU2hvdyA9IHRydWVcbiAgICB0aGlzLmlzRG9tUmVuZGVyaW5nID0gdHJ1ZVxuXG4gICAgLy8gYmluZCBldmVudCAncGFnZXNob3cnLCAncGFnZWhpZGUnIGFuZCAndmlzaWJpbGl0eWNoYW5nZScgb24gd2luZG93LlxuICAgIGlkbGVXaGVuUGFnZURpc2FwcGVhcih0aGlzKVxuICAgIC8vIGJpbmQgZXZlbnQgJ3JlbmRlckJlZ2luJyBhbmQgJ3JlbmRlckVuZCcgb24gd2luZG93LlxuICAgIGlkbGVXaGVuRG9tUmVuZGVyaW5nKHRoaXMpXG5cbiAgICBDb21wb25lbnQuY2FsbCh0aGlzLCBkYXRhKVxuICB9XG4gIFNsaWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbXBvbmVudC5wcm90b3R5cGUpXG4gIGV4dGVuZChTbGlkZXIucHJvdG90eXBlLCBwcm90bylcbiAgZXh0ZW5kKFNsaWRlci5wcm90b3R5cGUsIHsgYXR0ciB9KVxuICBleHRlbmQoU2xpZGVyLnByb3RvdHlwZSwgeyBldmVudCB9KVxuXG4gIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3NsaWRlcicsIFNsaWRlcilcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBpbml0IH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zbGlkZXIvaW5kZXguanNcbiAqKi8iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4ndXNlIHN0cmljdCdcblxuLy8gcmVxdWlyZSgnLi9nZXN0dXJlJylcbnJlcXVpcmUoJ2N1YmljYmV6aWVyJylcbnJlcXVpcmUoJ2FuaW1hdGlvbmpzJylcbnJlcXVpcmUoJy4vY2Fycm91c2VsLmNzcycpXG5cbnZhciBkb2MgPSB3aW5kb3cuZG9jdW1lbnRcbnZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50XG52YXIgRmlyZWZveCA9ICEhdWEubWF0Y2goL0ZpcmVmb3gvaSlcbnZhciBJRU1vYmlsZSA9ICEhdWEubWF0Y2goL0lFTW9iaWxlL2kpXG52YXIgY3NzUHJlZml4ID0gRmlyZWZveCA/ICctbW96LScgOiBJRU1vYmlsZSA/ICctbXMtJyA6ICctd2Via2l0LSdcbnZhciBzdHlsZVByZWZpeCA9IEZpcmVmb3ggPyAnTW96JyA6IElFTW9iaWxlID8gJ21zJyA6ICd3ZWJraXQnXG5cbnZhciB0aW1lciA9IHJlcXVpcmUoJy4vdGltZXInKVxudmFyIHNldFRpbWVvdXQgPSB0aW1lci5zZXRUaW1lb3V0XG52YXIgY2xlYXJUaW1lb3V0ID0gdGltZXIuY2xlYXJUaW1lb3V0XG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybU9mZnNldChlbGVtZW50KSB7XG4gIHZhciBvZmZzZXQgPSB7IHg6IDAsIHk6IDAgfVxuICB2YXIgdHJhbnNmb3JtID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtzdHlsZVByZWZpeCArICdUcmFuc2Zvcm0nXVxuICB2YXIgcmVnTWF0cml4M2QgPSBuZXcgUmVnRXhwKCdebWF0cml4M2RcXFxcKCg/OlstXFxcXGQuXSssXFxcXHMqKXsxMn0oWy1cXFxcZC5dKyksJ1xuICAgICsgJ1xcXFxzKihbLVxcXFxkLl0rKSg/OixcXFxccypbLVxcXFxkLl0rKXsyfVxcXFwpJylcbiAgdmFyIHJlZ01hdHJpeCA9IC9ebWF0cml4XFwoKD86Wy1cXGQuXSssXFxzKil7NH0oWy1cXGQuXSspLFxccyooWy1cXGQuXSspXFwpJC9cbiAgdmFyIG1hdGNoZWRcblxuICBpZiAodHJhbnNmb3JtICE9PSAnbm9uZScpIHtcbiAgICBpZiAoKG1hdGNoZWQgPSB0cmFuc2Zvcm0ubWF0Y2gocmVnTWF0cml4M2QpXG4gICAgICB8fCB0cmFuc2Zvcm0ubWF0Y2gocmVnTWF0cml4KSkpIHtcbiAgICAgIG9mZnNldC54ID0gcGFyc2VGbG9hdChtYXRjaGVkWzFdKSB8fCAwXG4gICAgICBvZmZzZXQueSA9IHBhcnNlRmxvYXQobWF0Y2hlZFsyXSkgfHwgMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRcbn1cblxudmFyIENTU01hdHJpeCA9IElFTW9iaWxlID8gJ01TQ1NTTWF0cml4JyA6ICdXZWJLaXRDU1NNYXRyaXgnXG52YXIgaGFzM2QgPSAhIUZpcmVmb3ggfHwgQ1NTTWF0cml4IGluIHdpbmRvdyAmJiAnbTExJyBpbiBuZXcgd2luZG93W0NTU01hdHJpeF0oKVxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRlKHgsIHkpIHtcbiAgeCA9IHBhcnNlRmxvYXQoeClcbiAgeSA9IHBhcnNlRmxvYXQoeSlcblxuICBpZiAoeCAhPSAwKSB7XG4gICAgeCArPSAncHgnXG4gIH1cblxuICBpZiAoeSAhPSAwKSB7XG4gICAgeSArPSAncHgnXG4gIH1cblxuICBpZiAoaGFzM2QpIHtcbiAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJywgJyArIHkgKyAnLCAwKSdcbiAgfVxuXG4gIHJldHVybiAndHJhbnNsYXRlKCcgKyB4ICsgJywgJyArIHkgKyAnKSdcbn1cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG5mdW5jdGlvbiBBcnJheUZyb20oYSkge1xuICByZXR1cm4gc2xpY2UuY2FsbChhKVxufVxuXG52YXIgaW5jSWQgPSAwXG5mdW5jdGlvbiBDYXJyb3VzZWwoZWxlbWVudCwgb3B0aW9ucykge1xuICB2YXIgdGhhdCA9IHRoaXNcbiAgdmFyIHZpZXdzID0gW11cbiAgdmFyIHBhZ2VzID0ge31cbiAgdmFyIGlkID0gRGF0ZS5ub3coKSArICctJyArICgrK2luY0lkKVxuICB2YXIgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICEoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1swXVxuICAgIGVsZW1lbnQgPSBudWxsXG4gIH1cblxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKVxuICAgIHJvb3QuYXBwZW5kQ2hpbGQoZWxlbWVudClcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWN0cmwtbmFtZScsICdjYXJyb3VzZWwnKVxuICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1jdHJsLWlkJywgaWQpXG5cbiAgZnVuY3Rpb24gZmlyZUV2ZW50KG5hbWUsIGV4dHJhKSB7XG4gICAgdmFyIGV2ID0gZG9jLmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJylcbiAgICBldi5pbml0RXZlbnQobmFtZSwgZmFsc2UsIGZhbHNlKVxuICAgIGlmIChleHRyYSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGV4dHJhKSB7XG4gICAgICAgIGV2W2tleV0gPSBleHRyYVtrZXldXG4gICAgICB9XG4gICAgfVxuICAgIHJvb3QuZGlzcGF0Y2hFdmVudChldilcbiAgfVxuXG4gIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnXG4gIGVsZW1lbnQuc3R5bGVbc3R5bGVQcmVmaXggKyAnVHJhbnNmb3JtJ10gPSBnZXRUcmFuc2xhdGUoMCwgMClcblxuICB2YXIgdHJhbnNmb3JtT2Zmc2V0ID0gMFxuICB2YXIgaXRlbXMgPSB7fVxuICB2YXIgaXRlbUxlbmd0aCA9IDBcbiAgdmFyIGl0ZW1TdGVwID0gb3B0aW9ucy5zdGVwIHx8IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcbiAgdmFyIGl0ZW1JbmRleCA9IDBcblxuICBpdGVtcy5hZGQgPSBmdW5jdGlvbiAoaHRtbCkge1xuICAgIHZhciBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJylcbiAgICBsaS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgbGkuc3R5bGUuZmxvYXQgPSAnbGVmdCdcbiAgICBsaS5pbmRleCA9IGl0ZW1MZW5ndGhcbiAgICBpZiAodHlwZW9mIGh0bWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsaS5pbm5lckhUTUwgPSBodG1sXG4gICAgfSBlbHNlIGlmIChodG1sIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIGxpLmFwcGVuZENoaWxkKGh0bWwpXG4gICAgfVxuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQobGkpXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaXRlbXMsIGl0ZW1MZW5ndGggKyAnJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsaVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpdGVtTGVuZ3RoKytcbiAgICByZXR1cm4gbGlcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUluZGV4KGluZGV4KSB7XG4gICAgd2hpbGUgKGluZGV4IDwgMCkge1xuICAgICAgaW5kZXggKz0gaXRlbUxlbmd0aFxuICAgIH1cblxuICAgIHdoaWxlIChpbmRleCA+PSBpdGVtTGVuZ3RoKSB7XG4gICAgICBpbmRleCAtPSBpdGVtTGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4XG4gIH1cblxuICBpdGVtcy5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gaXRlbXNbbm9ybWFsaXplSW5kZXgoaW5kZXgpXVxuICB9XG5cbiAgaXRlbXMuZ2V0Q2xvbmVkID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gbm9ybWFsaXplSW5kZXgoaW5kZXgpXG4gICAgdmFyIGl0ZW0gPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tjbG9uZWQ9XCJjbG9uZWQtJyArIGluZGV4ICsgJ1wiXScpXG4gICAgdmFyIG9yaWdpbmFsSXRlbSA9IGl0ZW1zW2luZGV4XVxuXG4gICAgLy8gSWYgdGhlcmUgYSBfbGlzdGVuZXJzIGF0dHJpYnV0ZSBvbiB0aGUgZG9tIGVsZW1lbnRcbiAgICAvLyB0aGVuIGNsb25lIHRoZSBfbGlzdGVuZXJzIGFzIHdlbGwgZm9yIHRoZSBldmVudHMnIGJpbmRpbmdcbiAgICBmdW5jdGlvbiBjbG9uZUV2ZW50cyhvcmlnaW4sIGNsb25lLCBkZWVwKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gb3JpZ2luLl9saXN0ZW5lcnNcbiAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgY2xvbmUuX2xpc3RlbmVycyA9IGxpc3RlbmVyc1xuICAgICAgICBmb3IgKHZhciB0eXBlIGluIGxpc3RlbmVycykge1xuICAgICAgICAgIGNsb25lLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW3R5cGVdKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVlcCAmJiBvcmlnaW4uY2hpbGRyZW4gJiYgb3JpZ2luLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9yaWdpbi5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjbG9uZUV2ZW50cyhvcmlnaW4uY2hpbGRyZW5baV0sIGNsb25lLmNoaWxkcmVuW2ldLCBkZWVwKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICBpdGVtID0gb3JpZ2luYWxJdGVtLmNsb25lTm9kZSh0cnVlKVxuICAgICAgY2xvbmVFdmVudHMob3JpZ2luYWxJdGVtLCBpdGVtLCB0cnVlKVxuXG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGl0ZW0pXG4gICAgICBpdGVtLnNldEF0dHJpYnV0ZSgnY2xvbmVkJywgJ2Nsb25lZC0nICsgaW5kZXgpXG4gICAgICBpdGVtLmluZGV4ID0gaW5kZXhcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbVxuICB9XG5cbiAgZnVuY3Rpb24gYWN0aXZhdGUoaW5kZXgpIHtcbiAgICBpZiAoaXRlbUxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGN1ckl0ZW0gPSBpdGVtcy5nZXQoaW5kZXgpXG4gICAgdmFyIHByZXZJdGVtXG4gICAgdmFyIG5leHRJdGVtXG5cbiAgICBpZiAoaXRlbUxlbmd0aCA+IDEpIHtcbiAgICAgIHByZXZJdGVtID0gaXRlbXMuZ2V0KGluZGV4IC0gMSlcblxuICAgICAgaWYgKGl0ZW1MZW5ndGggPT09IDIpIHtcbiAgICAgICAgbmV4dEl0ZW0gPSBpdGVtcy5nZXRDbG9uZWQoaW5kZXggKyAxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEl0ZW0gPSBpdGVtcy5nZXQoaW5kZXggKyAxKVxuICAgICAgfVxuXG4gICAgICBjdXJJdGVtLnN0eWxlLmxlZnQgPSAtdHJhbnNmb3JtT2Zmc2V0ICsgJ3B4J1xuICAgICAgcHJldkl0ZW0uc3R5bGUubGVmdCA9ICgtdHJhbnNmb3JtT2Zmc2V0IC0gaXRlbVN0ZXApICsgJ3B4J1xuICAgICAgbmV4dEl0ZW0uc3R5bGUubGVmdCA9ICgtdHJhbnNmb3JtT2Zmc2V0ICsgaXRlbVN0ZXApICsgJ3B4J1xuICAgIH1cblxuICAgIGl0ZW1JbmRleCA9IGN1ckl0ZW0uaW5kZXhcblxuICAgIGZpcmVFdmVudCgnY2hhbmdlJywge1xuICAgICAgcHJldkl0ZW06IHByZXZJdGVtLFxuICAgICAgY3VySXRlbTogY3VySXRlbSxcbiAgICAgIG5leHRJdGVtOiBuZXh0SXRlbVxuICAgIH0pXG4gIH1cblxuICBpdGVtcy5zbGlkZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIGlmIChpdGVtTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXRlbUxlbmd0aCA9PT0gMSkge1xuICAgICAgaW5kZXggPSAwXG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gZ2V0VHJhbnNmb3JtT2Zmc2V0KGVsZW1lbnQpLnhcbiAgICB2YXIgZW5kT2Zmc2V0ID0gdHJhbnNmb3JtT2Zmc2V0ICsgaXRlbVN0ZXAgKiAoLWluZGV4KVxuICAgIHZhciBpbnRlck9mZnNldCA9IGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0XG5cbiAgICBpZiAoaW50ZXJPZmZzZXQgPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBhbmltID0gbmV3IGxpYi5hbmltYXRpb24oXG4gICAgICA0MDAsXG4gICAgICBsaWIuY3ViaWNiZXppZXIuZWFzZSxcbiAgICAgIGZ1bmN0aW9uIChpMSwgaTIpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZVByZWZpeCArICdUcmFuc2Zvcm0nXVxuICAgICAgICAgID0gZ2V0VHJhbnNsYXRlKHN0YXJ0T2Zmc2V0ICsgaW50ZXJPZmZzZXQgKiBpMiwgMClcbiAgICAgIH0pLnBsYXkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJhbnNmb3JtT2Zmc2V0ID0gZW5kT2Zmc2V0XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVQcmVmaXggKyAnVHJhbnNmb3JtJ10gPSBnZXRUcmFuc2xhdGUoZW5kT2Zmc2V0LCAwKVxuICAgICAgICBpbmRleCAmJiBhY3RpdmF0ZShpdGVtSW5kZXggKyBpbmRleClcbiAgICAgIH0pXG4gIH1cblxuICBpdGVtcy5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGl0ZW1zLnNsaWRlKDEpXG4gIH1cblxuICBpdGVtcy5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgIGl0ZW1zLnNsaWRlKC0xKVxuICB9XG5cbiAgQXJyYXlGcm9tKGVsZW1lbnQuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgZWwuc3R5bGUudG9wID0gJzAnXG4gICAgZWwuc3R5bGUubGVmdCA9IGl0ZW1MZW5ndGggKiBpdGVtU3RlcCArICdweCdcbiAgICBlbC5zdHlsZS5mbG9hdCA9ICdsZWZ0J1xuICAgIGVsLmluZGV4ID0gaXRlbUxlbmd0aFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdGVtcywgaXRlbUxlbmd0aCArICcnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVsXG4gICAgICB9XG4gICAgfSlcblxuICAgIGl0ZW1MZW5ndGgrK1xuICB9KVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXRlbXMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaXRlbXNcbiAgICB9XG4gIH0pXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0ZW1zLCAnbGVuZ3RoJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGl0ZW1MZW5ndGhcbiAgICB9XG4gIH0pXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0ZW1zLCAnaW5kZXgnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaXRlbUluZGV4XG4gICAgfVxuICB9KVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdGVtcywgJ3N0ZXAnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaXRlbVN0ZXBcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgaXRlbVN0ZXAgPSB2XG4gICAgfVxuICB9KVxuXG4gIHZhciBzdGFydGluZyA9IGZhbHNlXG4gIHZhciBwbGF5aW5nID0gZmFsc2VcbiAgdmFyIGlzU2xpZGluZyA9IGZhbHNlXG4gIHRoaXMucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXN0YXJ0aW5nKSB7XG4gICAgICBzdGFydGluZyA9IHRydWVcbiAgICAgIHJldHVybiBhY3RpdmF0ZSgwKVxuICAgIH1cblxuICAgIGlmICghIXBsYXlpbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHBsYXlpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICBpc1NsaWRpbmcgPSB0cnVlXG4gICAgICBpdGVtcy5uZXh0KClcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpc1NsaWRpbmcgPSBmYWxzZVxuICAgICAgfSwgNTAwKVxuICAgICAgcGxheWluZyA9IHNldFRpbWVvdXQocGxheSwgNDAwICsgcGxheUludGVydmFsKVxuICAgIH0sIDQwMCArIHBsYXlJbnRlcnZhbClcbiAgfVxuXG4gIHRoaXMuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBsYXlpbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjbGVhclRpbWVvdXQocGxheWluZylcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHBsYXlpbmcgPSBmYWxzZVxuICAgIH0sIDUwMClcbiAgfVxuXG4gIHZhciBhdXRvcGxheSA9IGZhbHNlXG4gIHZhciByZWFkeVRvUGxheSA9IGZhbHNlXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYXV0b3BsYXknLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXV0b3BsYXlcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgIGF1dG9wbGF5ID0gISF2XG4gICAgICBpZiAocmVhZHlUb1BsYXkpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlYWR5VG9QbGF5KVxuICAgICAgICByZWFkeVRvUGxheSA9IGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAoYXV0b3BsYXkpIHtcbiAgICAgICAgcmVhZHlUb1BsYXkgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LnBsYXkoKVxuICAgICAgICB9LCAyMDAwKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhhdC5zdG9wKClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHRoaXMuYXV0b3BsYXkgPSAhIW9wdGlvbnMuYXV0b3BsYXlcblxuICB2YXIgcGxheUludGVydmFsID0gMTUwMFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3BsYXlJbnRlcnZhbCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwbGF5SW50ZXJ2YWxcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKG4pIHtcbiAgICAgIHBsYXlJbnRlcnZhbCA9IG5cbiAgICB9XG4gIH0pXG4gIHRoaXMucGxheUludGVydmFsID0gISFvcHRpb25zLnBsYXlJbnRlcnZhbCB8fCAxNTAwXG5cbiAgaWYgKG9wdGlvbnMudXNlR2VzdHVyZSkge1xuICAgIHZhciBwYW5uaW5nID0gZmFsc2VcbiAgICB2YXIgZGlzcGxhY2VtZW50XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwYW5zdGFydCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIWUuaXNWZXJ0aWNhbCAmJiAhKHBhbm5pbmcgJiYgaXNTbGlkaW5nKSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgICAgIGlmIChhdXRvcGxheSkge1xuICAgICAgICAgIHRoYXQuc3RvcCgpXG4gICAgICAgIH1cblxuICAgICAgICBkaXNwbGFjZW1lbnQgPSAwXG4gICAgICAgIHBhbm5pbmcgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGFubW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIWUuaXNWZXJ0aWNhbCAmJiBwYW5uaW5nKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgIGRpc3BsYWNlbWVudCA9IGUuZGlzcGxhY2VtZW50WFxuICAgICAgICBlbGVtZW50LnN0eWxlW3N0eWxlUHJlZml4ICsgJ1RyYW5zZm9ybSddXG4gICAgICAgICAgPSBnZXRUcmFuc2xhdGUodHJhbnNmb3JtT2Zmc2V0ICsgZGlzcGxhY2VtZW50LCAwKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BhbmVuZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIWUuaXNWZXJ0aWNhbCAmJiBwYW5uaW5nKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgIHBhbm5pbmcgPSBmYWxzZVxuICAgICAgICBpZiAoZS5pc1N3aXBlKSB7XG4gICAgICAgICAgaWYgKGRpc3BsYWNlbWVudCA8IDApIHtcbiAgICAgICAgICAgIGl0ZW1zLm5leHQoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtcy5wcmV2KClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRpc3BsYWNlbWVudCkgPCBpdGVtU3RlcCAvIDIpIHtcbiAgICAgICAgICAgIGl0ZW1zLnNsaWRlKDApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW1zLnNsaWRlKGRpc3BsYWNlbWVudCA8IDA/MTotMSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXV0b3BsYXkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQucGxheSgpXG4gICAgICAgICAgfSwgMjAwMClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGZhbHNlKVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzd2lwZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIWUuaXNWZXJ0aWNhbCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAobmFtZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIGZhbHNlKVxuICB9XG5cbiAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKG5hbWUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyLCBmYWxzZSlcbiAgfVxuXG4gIHRoaXMucm9vdCA9IHJvb3RcbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudFxufVxuXG4hbGliICYmIChsaWIgPSB7fSlcbmxpYi5jYXJyb3VzZWwgPSBDYXJyb3VzZWxcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NsaWRlci9jYXJyb3VzZWwuanNcbiAqKi8iLCIodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpICYmICh3aW5kb3cgPSB7Y3RybDoge30sIGxpYjoge319KTshd2luZG93LmN0cmwgJiYgKHdpbmRvdy5jdHJsID0ge30pOyF3aW5kb3cubGliICYmICh3aW5kb3cubGliID0ge30pOyFmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiLGMsZCl7ZnVuY3Rpb24gZShhKXtyZXR1cm4oMyprKmErMipsKSphK219ZnVuY3Rpb24gZihhKXtyZXR1cm4oKGsqYStsKSphK20pKmF9ZnVuY3Rpb24gZyhhKXtyZXR1cm4oKG4qYStvKSphK3ApKmF9ZnVuY3Rpb24gaChhKXtmb3IodmFyIGIsYyxkPWEsZz0wOzg+ZztnKyspe2lmKGM9ZihkKS1hLE1hdGguYWJzKGMpPGopcmV0dXJuIGQ7aWYoYj1lKGQpLE1hdGguYWJzKGIpPGopYnJlYWs7ZC09Yy9ifXZhciBoPTEsaT0wO2ZvcihkPWE7aD5pOyl7aWYoYz1mKGQpLWEsTWF0aC5hYnMoYyk8ailyZXR1cm4gZDtjPjA/aD1kOmk9ZCxkPShoK2kpLzJ9cmV0dXJuIGR9ZnVuY3Rpb24gaShhKXtyZXR1cm4gZyhoKGEpKX12YXIgaj0xZS02LGs9MyphLTMqYysxLGw9MypjLTYqYSxtPTMqYSxuPTMqYi0zKmQrMSxvPTMqZC02KmIscD0zKmI7cmV0dXJuIGl9Yi5jdWJpY2Jlemllcj1jLGIuY3ViaWNiZXppZXIubGluZWFyPWMoMCwwLDEsMSksYi5jdWJpY2Jlemllci5lYXNlPWMoLjI1LC4xLC4yNSwxKSxiLmN1YmljYmV6aWVyLmVhc2VJbj1jKC40MiwwLDEsMSksYi5jdWJpY2Jlemllci5lYXNlT3V0PWMoMCwwLC41OCwxKSxiLmN1YmljYmV6aWVyLmVhc2VJbk91dD1jKC40MiwwLC41OCwxKX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSk7O21vZHVsZS5leHBvcnRzID0gd2luZG93LmxpYlsnY3ViaWNiZXppZXInXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jdWJpY2Jlemllci9idWlsZC9jdWJpY2Jlemllci5jb21tb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIih0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgJiYgKHdpbmRvdyA9IHtjdHJsOiB7fSwgbGliOiB7fX0pOyF3aW5kb3cuY3RybCAmJiAod2luZG93LmN0cmwgPSB7fSk7IXdpbmRvdy5saWIgJiYgKHdpbmRvdy5saWIgPSB7fSk7IWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gc2V0VGltZW91dChhLGwpfWZ1bmN0aW9uIGQoYSl7Y2xlYXJUaW1lb3V0KGEpfWZ1bmN0aW9uIGUoKXt2YXIgYT17fSxiPW5ldyBtKGZ1bmN0aW9uKGIsYyl7YS5yZXNvbHZlPWIsYS5yZWplY3Q9Y30pO3JldHVybiBhLnByb21pc2U9YixhfWZ1bmN0aW9uIGYoYSxiKXtyZXR1cm5bXCJ0aGVuXCIsXCJjYXRjaFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGMpe2JbY109ZnVuY3Rpb24oKXtyZXR1cm4gYVtjXS5hcHBseShhLGFyZ3VtZW50cyl9fSksYn1mdW5jdGlvbiBnKGIpe3ZhciBjLGQsaD0hMTt0aGlzLnJlcXVlc3Q9ZnVuY3Rpb24oKXtoPSExO3ZhciBnPWFyZ3VtZW50cztyZXR1cm4gYz1lKCksZihjLnByb21pc2UsdGhpcyksZD1uKGZ1bmN0aW9uKCl7aHx8YyYmYy5yZXNvbHZlKGIuYXBwbHkoYSxnKSl9KSx0aGlzfSx0aGlzLmNhbmNlbD1mdW5jdGlvbigpe3JldHVybiBkJiYoaD0hMCxvKGQpLGMmJmMucmVqZWN0KFwiQ0FOQ0VMXCIpKSx0aGlzfSx0aGlzLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBnKGIpfX1mdW5jdGlvbiBoKGEsYil7XCJmdW5jdGlvblwiPT10eXBlb2YgYiYmKGI9ezA6Yn0pO2Zvcih2YXIgYz1hL2wsZD0xL2MsZT1bXSxmPU9iamVjdC5rZXlzKGIpLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gcGFyc2VJbnQoYSl9KSxoPTA7Yz5oO2grKyl7dmFyIGk9ZlswXSxqPWQqaDtpZihudWxsIT1pJiYxMDAqaj49aSl7dmFyIGs9YltcIlwiK2ldO2sgaW5zdGFuY2VvZiBnfHwoaz1uZXcgZyhrKSksZS5wdXNoKGspLGYuc2hpZnQoKX1lbHNlIGUubGVuZ3RoJiZlLnB1c2goZVtlLmxlbmd0aC0xXS5jbG9uZSgpKX1yZXR1cm4gZX1mdW5jdGlvbiBpKGEpe3ZhciBjO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBhfHxhIGluc3RhbmNlb2YgQXJyYXk/Yi5jdWJpY2Jlemllcj9cInN0cmluZ1wiPT10eXBlb2YgYT9iLmN1YmljYmV6aWVyW2FdJiYoYz1iLmN1YmljYmV6aWVyW2FdKTphIGluc3RhbmNlb2YgQXJyYXkmJjQ9PT1hLmxlbmd0aCYmKGM9Yi5jdWJpY2Jlemllci5hcHBseShiLmN1YmljYmV6aWVyLGEpKTpjb25zb2xlLmVycm9yKFwicmVxdWlyZSBsaWIuY3ViaWNiZXppZXJcIik6XCJmdW5jdGlvblwiPT10eXBlb2YgYSYmKGM9YSksY31mdW5jdGlvbiBqKGEsYixjKXt2YXIgZCxnPWgoYSxjKSxqPTEvKGEvbCksaz0wLG09aShiKTtpZighbSl0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4Y2VwdCB0aW1pbmcgZnVuY3Rpb25cIik7dmFyIG49ITE7dGhpcy5wbGF5PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe3ZhciBjPWoqKGsrMSkudG9GaXhlZCgxMCksZT1nW2tdO2UucmVxdWVzdChjLnRvRml4ZWQoMTApLGIoYykudG9GaXhlZCgxMCkpLnRoZW4oZnVuY3Rpb24oKXtuJiYoaz09PWcubGVuZ3RoLTE/KG49ITEsZCYmZC5yZXNvbHZlKFwiRklOSVNIXCIpLGQ9bnVsbCk6KGsrKyxhKCkpKX0sZnVuY3Rpb24oKXt9KX1pZighbilyZXR1cm4gbj0hMCxkfHwoZD1lKCksZihkLnByb21pc2UsdGhpcykpLGEoKSx0aGlzfSx0aGlzLnN0b3A9ZnVuY3Rpb24oKXtyZXR1cm4gbj8obj0hMSxnW2tdJiZnW2tdLmNhbmNlbCgpLHRoaXMpOnZvaWQgMH19dmFyIGs9NjAsbD0xZTMvayxtPWEuUHJvbWlzZXx8Yi5wcm9taXNlJiZiLnByb21pc2UuRVM2UHJvbWlzZSxuPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZXx8YyxvPXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZXx8d2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWV8fHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZXx8d2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lfHxkOyhuPT09Y3x8bz09PWQpJiYobj1jLG89ZCksYi5hbmltYXRpb249ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBuZXcgaihhLGIsYyl9LGIuYW5pbWF0aW9uLmZyYW1lPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgZyhhKX0sYi5hbmltYXRpb24ucmVxdWVzdEZyYW1lPWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBnKGEpO3JldHVybiBiLnJlcXVlc3QoKX19KHdpbmRvdyx3aW5kb3cubGlifHwod2luZG93LmxpYj17fSkpOzttb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5saWJbJ2FuaW1hdGlvbiddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2FuaW1hdGlvbmpzL2J1aWxkL2FuaW1hdGlvbi5jb21tb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vY2Fycm91c2VsLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9jYXJyb3VzZWwuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vY2Fycm91c2VsLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2xpZGVyL2NhcnJvdXNlbC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiW2RhdGEtY3RybC1uYW1lPVxcXCJjYXJyb3VzZWxcXFwiXSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWigxcHgpO1xcbiAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWigxcHgpO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDFweCk7XFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NsaWRlci9jYXJyb3VzZWwuY3NzXG4gKiogbW9kdWxlIGlkID0gMTY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIF9mYWxsYmFjayA9IGZhbHNlXG5cbnZhciByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbmlmICghcmFmKSB7XG4gIF9mYWxsYmFjayA9IHRydWVcbiAgcmFmID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIDE2KVxuICB9XG59XG52YXIgY2FmID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXG4gIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZVxuaWYgKCFjYWYgJiYgX2ZhbGxiYWNrKSB7XG4gIGNhZiA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpXG4gIH1cbn0gZWxzZSBpZiAoIWNhZikge1xuICBjYWYgPSBmdW5jdGlvbigpIHt9XG59XG5cbnZhciBNQVggPSAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgTWF0aC5wb3coMiwgNTMpIC0gMSkgLSAxXG5cbnZhciBfaWRNYXAgPSB7fVxudmFyIF9nbG9iYWxJZCA9IDBcblxuZnVuY3Rpb24gX2dldEdsb2JhbElkKCkge1xuICBfZ2xvYmFsSWQgPSAoX2dsb2JhbElkICsgMSkgJSBNQVhcbiAgaWYgKF9pZE1hcFtfZ2xvYmFsSWRdKSB7XG4gICAgcmV0dXJuIF9nZXRHbG9iYWxJZCgpXG4gIH1cbiAgcmV0dXJuIF9nbG9iYWxJZFxufVxuXG52YXIgdGltZXIgPSB7XG5cbiAgc2V0VGltZW91dDogZnVuY3Rpb24gKGNiLCBtcykge1xuICAgIHZhciBpZCA9IF9nZXRHbG9iYWxJZCgpXG4gICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgIF9pZE1hcFtpZF0gPSByYWYoZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgIGlmICghX2lkTWFwW2lkXSAmJiBfaWRNYXBbaWRdICE9PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGluZCA9IERhdGUubm93KCkgLSBzdGFydFxuICAgICAgaWYgKGluZCA8IG1zKSB7XG4gICAgICAgIF9pZE1hcFtpZF0gPSByYWYobG9vcClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBfaWRNYXBbaWRdXG4gICAgICAgIGNiKClcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBpZFxuICB9LFxuXG4gIGNsZWFyVGltZW91dDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIHRpZCA9IF9pZE1hcFtpZF1cbiAgICB0aWQgJiYgY2FmKHRpZClcbiAgICBkZWxldGUgX2lkTWFwW2lkXVxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0aW1lclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NsaWRlci90aW1lci5qc1xuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc2xpZGVyLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zbGlkZXIuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc2xpZGVyLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc2xpZGVyL3NsaWRlci5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnNsaWRlciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbi5zbGlkZXIgLmluZGljYXRvci1jb250YWluZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcXG4gIGJveC1hbGlnbjogY2VudGVyO1xcbiAgLXdlYmtpdC1hbGlnbi1pdGVtczogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcXG4gIGJveC1wYWNrOiBjZW50ZXI7XFxuICAtd2Via2l0LWp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBmb250LXNpemU6IDA7XFxufVxcbi5zbGlkZXIgLmluZGljYXRvci1jb250YWluZXIgLmluZGljYXRvciB7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxufVxcbi5zbGlkZXIgLmluZGljYXRvci1jb250YWluZXIucm93IHtcXG4gIC13ZWJraXQtYm94LW9yaWVudDogaG9yaXpvbnRhbDtcXG4gIGJveC1vcmllbnQ6IGhvcml6b250YWw7XFxuICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbn1cXG4uc2xpZGVyIC5pbmRpY2F0b3ItY29udGFpbmVyLmNvbHVtbiB7XFxuICAtd2Via2l0LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xcbiAgYm94LW9yaWVudDogdmVydGljYWw7XFxuICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zbGlkZXIvc2xpZGVyLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnJlcXVpcmUoJy4vaW5kaWNhdG9yLmNzcycpXG5cbmNvbnN0IERFRkFVTFRfSVRFTV9DT0xPUiA9ICcjOTk5J1xuY29uc3QgREVGQVVMVF9JVEVNX1NFTEVDVEVEX0NPTE9SID0gJyMwMDAwZmYnXG5jb25zdCBERUZBVUxUX0lURU1fU0laRSA9IDIwXG5jb25zdCBERUZBVUxUX01BUkdJTl9TSVpFID0gMTBcblxuZnVuY3Rpb24gcmVzZXRDb2xvciAoaW5kaWNhdG9yKSB7XG4gIGNvbnN0IGxlbiA9IGluZGljYXRvci5pdGVtcy5sZW5ndGhcbiAgaWYgKHR5cGVvZiBpbmRpY2F0b3IuaW5kZXggIT09ICd1bmRlZmluZWQnICYmIGxlbiA+IGluZGljYXRvci5pbmRleCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBpbmRpY2F0b3IuaXRlbXNbaV1cbiAgICAgIGlmIChpbmRpY2F0b3IuaW5kZXggPT09IGkpIHtcbiAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKVxuICAgICAgICBpdGVtLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGluZGljYXRvci5pdGVtU2VsZWN0ZWRDb2xvclxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGl0ZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gaW5kaWNhdG9yLml0ZW1Db2xvclxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDbGljayAoaW5kaWNhdG9yLCBpZHgsIGUpIHtcbiAgaW5kaWNhdG9yLnNsaWRlci5zbGlkZVRvKGlkeClcbn1cblxuY29uc3QgcHJvdG8gPSB7XG4gIGNyZWF0ZSAoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgbm9kZS5jbGFzc0xpc3QuYWRkKCd3ZWV4LWluZGljYXRvcnMnKVxuICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1lbGVtZW50JylcbiAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgIHRoaXMubm9kZSA9IG5vZGVcbiAgICB0aGlzLnN0eWxlLml0ZW1TaXplLmNhbGwodGhpcywgMClcbiAgICB0aGlzLnVwZGF0ZVN0eWxlKHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBpdGVtU2l6ZTogMFxuICAgIH0pXG4gICAgcmV0dXJuIG5vZGVcbiAgfSxcblxuICBjcmVhdGVDaGlsZHJlbiAoKSB7XG4gICAgY29uc3Qgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hbW91bnQ7IGkrKykge1xuICAgICAgY29uc3QgaW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIGluZGljYXRvci5jbGFzc0xpc3QuYWRkKCd3ZWV4LWluZGljYXRvcicpXG4gICAgICBpbmRpY2F0b3Iuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnXG4gICAgICBpbmRpY2F0b3Iuc3R5bGUubWFyZ2luID0gJzAgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAoREVGQVVMVF9NQVJHSU5fU0laRSAqIHRoaXMuZGF0YS5zY2FsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJ3B4J1xuICAgICAgaW5kaWNhdG9yLnN0eWxlLndpZHRoID0gdGhpcy5pdGVtU2l6ZSArICdweCdcbiAgICAgIGluZGljYXRvci5zdHlsZS5oZWlnaHQgPSB0aGlzLml0ZW1TaXplICsgJ3B4J1xuICAgICAgaW5kaWNhdG9yLnNldEF0dHJpYnV0ZSgnaW5kZXgnLCBpKVxuICAgICAgaWYgKHRoaXMuaW5kZXggPT09IGkpIHtcbiAgICAgICAgaW5kaWNhdG9yLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpXG4gICAgICAgIGluZGljYXRvci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLml0ZW1TZWxlY3RlZENvbG9yXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaW5kaWNhdG9yLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuaXRlbUNvbG9yXG4gICAgICB9XG4gICAgICBpbmRpY2F0b3IuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljay5iaW5kKG51bGwsIHRoaXMsIGkpKVxuICAgICAgdGhpcy5pdGVtc1tpXSA9IGluZGljYXRvclxuICAgICAgcm9vdC5hcHBlbmRDaGlsZChpbmRpY2F0b3IpXG4gICAgfVxuICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChyb290KVxuICB9LFxuXG4gIHNldEluZGV4IChpZHgpIHtcbiAgICBpZiAoaWR4ID49IHRoaXMuYW1vdW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgcHJldiA9IHRoaXMuaXRlbXNbdGhpcy5pbmRleF1cbiAgICBjb25zdCBjdXIgPSB0aGlzLml0ZW1zW2lkeF1cbiAgICBwcmV2LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpXG4gICAgcHJldi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLml0ZW1Db2xvclxuICAgIGN1ci5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKVxuICAgIGN1ci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLml0ZW1TZWxlY3RlZENvbG9yXG4gICAgdGhpcy5pbmRleCA9IGlkeFxuICB9XG59XG5cbmNvbnN0IHN0eWxlID0ge1xuICBpdGVtQ29sb3IgKHZhbCkge1xuICAgIHRoaXMuaXRlbUNvbG9yID0gdmFsIHx8IERFRkFVTFRfSVRFTV9DT0xPUlxuICAgIHJlc2V0Q29sb3IodGhpcylcbiAgfSxcblxuICBpdGVtU2VsZWN0ZWRDb2xvciAodmFsKSB7XG4gICAgdGhpcy5pdGVtU2VsZWN0ZWRDb2xvciA9IHZhbCB8fCBERUZBVUxUX0lURU1fU0VMRUNURURfQ09MT1JcbiAgICByZXNldENvbG9yKHRoaXMpXG4gIH0sXG5cbiAgaXRlbVNpemUgKHZhbCkge1xuICAgIHZhbCA9IHBhcnNlSW50KHZhbCkgKiB0aGlzLmRhdGEuc2NhbGVcbiAgICAgICAgICB8fCBERUZBVUxUX0lURU1fU0laRSAqIHRoaXMuZGF0YS5zY2FsZVxuICAgIHRoaXMuaXRlbVNpemUgPSB2YWxcbiAgICB0aGlzLm5vZGUuc3R5bGUuaGVpZ2h0ID0gdmFsICsgJ3B4J1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5pdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuaXRlbXNbaV0uc3R5bGUud2lkdGggPSB2YWwgKyAncHgnXG4gICAgICB0aGlzLml0ZW1zW2ldLnN0eWxlLmhlaWdodCA9IHZhbCArICdweCdcbiAgICB9XG4gIH0sXG5cbiAgd2lkdGggKHZhbCkge1xuICAgIHZhbCA9IHBhcnNlSW50KHZhbCkgKiB0aGlzLmRhdGEuc2NhbGUgfHwgcGFyc2VJbnQodGhpcy5zbGlkZXJXaWR0aClcbiAgICB0aGlzLnZpcnR1YWxXcmFwcGVyV2lkdGggPSB2YWxcbiAgfSxcblxuICBoZWlnaHQgKHZhbCkge1xuICAgIHZhbCA9IHBhcnNlSW50KHZhbCkgKiB0aGlzLmRhdGEuc2NhbGUgfHwgcGFyc2VJbnQodGhpcy5zbGlkZXJIZWlnaHQpXG4gICAgdGhpcy52aXJ0dWFsV3JhcHBlckhlaWdodCA9IHZhbFxuICB9LFxuXG4gIHRvcCAodmFsKSB7XG4gICAgdmFsID0gdGhpcy52aXJ0dWFsV3JhcHBlckhlaWdodCAvIDIgLSB0aGlzLml0ZW1TaXplIC8gMlxuICAgICAgICArIHZhbCAqIHRoaXMuZGF0YS5zY2FsZVxuICAgIHRoaXMubm9kZS5zdHlsZS5ib3R0b20gPSAnJ1xuICAgIHRoaXMubm9kZS5zdHlsZS50b3AgPSB2YWwgKyAncHgnXG4gIH0sXG5cbiAgYm90dG9tICh2YWwpIHtcbiAgICB2YWwgPSB0aGlzLnZpcnR1YWxXcmFwcGVySGVpZ2h0IC8gMiAtIHRoaXMuaXRlbVNpemUgLyAyXG4gICAgICAgICsgdmFsICogdGhpcy5kYXRhLnNjYWxlXG4gICAgdGhpcy5ub2RlLnN0eWxlLnRvcCA9ICcnXG4gICAgdGhpcy5ub2RlLnN0eWxlLmJvdHRvbSA9IHZhbCArICdweCdcbiAgfSxcblxuICBsZWZ0ICh2YWwpIHtcbiAgICB2YWwgPSB0aGlzLnZpcnR1YWxXcmFwcGVyV2lkdGggLyAyXG4gICAgICAgICAgLSAodGhpcy5pdGVtU2l6ZSArIDIgKiBERUZBVUxUX01BUkdJTl9TSVpFICogdGhpcy5kYXRhLnNjYWxlKVxuICAgICAgICAgICAgICAqIHRoaXMuYW1vdW50IC8gMlxuICAgICAgICAgICsgdmFsICogdGhpcy5kYXRhLnNjYWxlXG4gICAgdGhpcy5ub2RlLnN0eWxlLnJpZ2h0ID0gJydcbiAgICB0aGlzLm5vZGUuc3R5bGUubGVmdCA9IHZhbCArICdweCdcbiAgfSxcblxuICByaWdodCAodmFsKSB7XG4gICAgdmFsID0gdGhpcy52aXJ0dWFsV3JhcHBlcldpZHRoIC8gMlxuICAgICAgICAgIC0gKHRoaXMuaXRlbVNpemUgKyAyICogREVGQVVMVF9NQVJHSU5fU0laRSAqIHRoaXMuZGF0YS5zY2FsZSlcbiAgICAgICAgICAgICAgKiB0aGlzLmFtb3VudCAvIDJcbiAgICAgICAgICArIHZhbCAqIHRoaXMuZGF0YS5zY2FsZVxuICAgIHRoaXMubm9kZS5zdHlsZS5sZWZ0ID0gJydcbiAgICB0aGlzLm5vZGUuc3R5bGUucmlnaHQgPSB2YWwgKyAncHgnXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdCAoV2VleCkge1xuICBjb25zdCBBdG9taWMgPSBXZWV4LkF0b21pY1xuICBjb25zdCBleHRlbmQgPSBXZWV4LnV0aWxzLmV4dGVuZFxuXG4gIC8vIFN0eWxlIHN1cHBvcnRlZDpcbiAgLy8gICBwb3NpdGlvbjogKGRlZmF1bHQgLSBhYnNvbHV0ZSlcbiAgLy8gICBpdGVtQ29sb3I6IGNvbG9yIG9mIGluZGljYXRvciBkb3RzXG4gIC8vICAgaXRlbVNlbGVjdGVkQ29sb3I6IGNvbG9yIG9mIHRoZSBzZWxlY3RlZCBpbmRpY2F0b3IgZG90XG4gIC8vICAgaXRlbVNpemU6IHNpemUgb2YgaW5kaWNhdG9yc1xuICAvLyAgIG90aGVyIGxheW91dCBzdHlsZXNcbiAgZnVuY3Rpb24gSW5kaWNhdG9yIChkYXRhKSB7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSAncm93JyAvLyAnY29sdW1uJyBpcyBub3QgdGVtcG9yYXJpbHkgc3VwcG9ydGVkLlxuICAgIHRoaXMuYW1vdW50ID0gZGF0YS5leHRyYS5hbW91bnRcbiAgICB0aGlzLmluZGV4ID0gZGF0YS5leHRyYS5pbmRleFxuICAgIHRoaXMuc2xpZGVyV2lkdGggPSBkYXRhLmV4dHJhLndpZHRoXG4gICAgdGhpcy5zbGlkZXJIZWlnaHQgPSBkYXRhLmV4dHJhLmhlaWdodFxuICAgIGNvbnN0IHN0eWxlcyA9IGRhdGEuc3R5bGUgfHwge31cbiAgICB0aGlzLmRhdGEgPSBkYXRhXG4gICAgdGhpcy5zdHlsZS53aWR0aC5jYWxsKHRoaXMsIHN0eWxlcy53aWR0aClcbiAgICB0aGlzLnN0eWxlLmhlaWdodC5jYWxsKHRoaXMsIHN0eWxlcy5oZWlnaHQpXG4gICAgdGhpcy5pdGVtQ29sb3IgPSBzdHlsZXMuaXRlbUNvbG9yIHx8IERFRkFVTFRfSVRFTV9DT0xPUlxuICAgIHRoaXMuaXRlbVNlbGVjdGVkQ29sb3IgPSBzdHlsZXMuaXRlbVNlbGVjdGVkQ29sb3JcbiAgICAgIHx8IERFRkFVTFRfSVRFTV9TRUxFQ1RFRF9DT0xPUlxuICAgIHRoaXMuaXRlbXMgPSBbXVxuICAgIEF0b21pYy5jYWxsKHRoaXMsIGRhdGEpXG4gIH1cbiAgSW5kaWNhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXRvbWljLnByb3RvdHlwZSlcbiAgZXh0ZW5kKEluZGljYXRvci5wcm90b3R5cGUsIHByb3RvKVxuICBleHRlbmQoSW5kaWNhdG9yLnByb3RvdHlwZSwge1xuICAgIHN0eWxlOiBleHRlbmQoT2JqZWN0LmNyZWF0ZShBdG9taWMucHJvdG90eXBlLnN0eWxlKSwgc3R5bGUpXG4gIH0pXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnaW5kaWNhdG9yJywgSW5kaWNhdG9yKVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL2luZGljYXRvci9pbmRleC5qc1xuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW5kaWNhdG9yLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRpY2F0b3IuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW5kaWNhdG9yLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvaW5kaWNhdG9yL2luZGljYXRvci5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLndlZXgtaW5kaWNhdG9ycyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG4ud2VleC1pbmRpY2F0b3JzIC53ZWV4LWluZGljYXRvciB7XFxuICBmbG9hdDogbGVmdDtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvaW5kaWNhdG9yL2luZGljYXRvci5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG4vLyBUT0RPOiByZWZhY3RvciB0aGlzIHNjc3MgY29kZSBzaW5jZSB0aGlzIGlzIHN0cm9uZ2x5XG4vLyBkZXBlbmRlbnQgb24gbGliLmZsZXhpYmxlIG90aGVyIHRoYW4gdGhlIHZhbHVlIG9mXG4vLyBzY2FsZS5cbnJlcXVpcmUoJy4vdGFiaGVhZGVyLmNzcycpXG5cbmZ1bmN0aW9uIGluaXRGb2xkQnRuICh0YWJoZWFkZXIpIHtcbiAgY29uc3Qgbm9kZSA9IHRhYmhlYWRlci5ub2RlXG4gIGNvbnN0IGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICBidG4uY2xhc3NOYW1lID0gJ2ZvbGQtdG9nZ2xlIGljb25mb250J1xuICBidG4uaW5uZXJIVE1MID0gJyYjeGU2NjE7J1xuICBub2RlLmFwcGVuZENoaWxkKGJ0bilcblxuICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRhYmhlYWRlci51bmZvbGRpbmcpIHtcbiAgICAgIGZvbGRpbmcodGFiaGVhZGVyKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHVuZm9sZGluZyh0YWJoZWFkZXIpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBpbml0TWFzayAodGFiaGVhZGVyKSB7XG4gIGNvbnN0IG1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBtYXNrLmNsYXNzTmFtZSA9ICd0YWJoZWFkZXItbWFzaydcbiAgdGFiaGVhZGVyLm1hc2sgPSBtYXNrXG4gIC8vIHN0b3AgZGVmYXVsdCBiZWhhdmlvcjogcGFnZSBtb3ZpbmcuXG4gIG1hc2suYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gIH0pXG4gIC8vIGNsaWNrIHRvIHVuZm9sZC5cbiAgbWFzay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICBmb2xkaW5nKHRhYmhlYWRlcilcbiAgfSlcblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1hc2spXG59XG5cbmZ1bmN0aW9uIHVuZm9sZGluZyAodGFiaGVhZGVyKSB7XG4gIC8vIG1hcmsgdGhlIGluaXRpYWwgcG9zaWl0b24gb2YgdGFiaGVhZGVyXG4gIGlmICghdGFiaGVhZGVyLmZsYWcpIHtcbiAgICBjb25zdCBmbGFnID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgndGFiaGVhZGVyJylcbiAgICB0YWJoZWFkZXIuZmxhZyA9IGZsYWdcbiAgICB0YWJoZWFkZXIubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShmbGFnLCB0YWJoZWFkZXIubm9kZSlcbiAgfVxuICBpZiAoIXRhYmhlYWRlci5tYXNrKSB7XG4gICAgaW5pdE1hc2sodGFiaGVhZGVyKVxuICB9XG5cbiAgLy8gcmVjb3JkIHRoZSBzY3JvbGwgcG9zaXRpb24uXG4gIHRhYmhlYWRlci5fc2Nyb2xsVmFsID0gdGFiaGVhZGVyLl9ib2R5LnNjcm9sbExlZnRcbiAgLy8gcmVjb3JkIHRoZSBwb3NpdGlvbiBpbiBkb2N1bWVudC5cbiAgdGFiaGVhZGVyLl90b3BWYWwgPSB0YWJoZWFkZXIubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgdGFiaGVhZGVyLl9zdHlsZVRvcCA9IHRhYmhlYWRlci5ub2RlLnN0eWxlLnRvcFxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGFiaGVhZGVyLm5vZGUpXG4gIHRhYmhlYWRlci5ub2RlLmNsYXNzTGlzdC5hZGQoJ3VuZm9sZC1oZWFkZXInKVxuICB0YWJoZWFkZXIubm9kZS5zdHlsZS5oZWlnaHQgPSAnYXV0bydcbiAgLy8gcmVjYWxjIHRoZSBwb3NpdGlvbiB3aGVuIGl0IGlzIHVuZm9sZGVkLlxuICBjb25zdCB0aEhlaWdodCA9IHRhYmhlYWRlci5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuICBpZiAodGhIZWlnaHQgKyB0YWJoZWFkZXIuX3RvcFZhbCA+IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgIHRhYmhlYWRlci5fdG9wVmFsID0gdGFiaGVhZGVyLl90b3BWYWxcbiAgICAgICAgKyAod2luZG93LmlubmVySGVpZ2h0IC0gdGhIZWlnaHQgLSB0YWJoZWFkZXIuX3RvcFZhbClcbiAgfVxuXG4gIHRhYmhlYWRlci5ub2RlLnN0eWxlLnRvcCA9IHRhYmhlYWRlci5fdG9wVmFsICsgJ3B4J1xuICAvLyBwcm9jZXNzIG1hc2sgc3R5bGVcbiAgdGFiaGVhZGVyLm1hc2suY2xhc3NMaXN0LmFkZCgndW5mb2xkLWhlYWRlcicpXG4gIHRhYmhlYWRlci5tYXNrLnN0eWxlLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCArICdweCdcbiAgdGFiaGVhZGVyLnVuZm9sZGluZyA9IHRydWVcbn1cblxuZnVuY3Rpb24gZm9sZGluZyAodGFiaGVhZGVyKSB7XG4gIGlmICh0YWJoZWFkZXIudW5mb2xkaW5nICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB0YWJoZWFkZXIubWFzay5jbGFzc0xpc3QucmVtb3ZlKCd1bmZvbGQtaGVhZGVyJylcbiAgdGFiaGVhZGVyLm5vZGUuY2xhc3NMaXN0LnJlbW92ZSgndW5mb2xkLWhlYWRlcicpXG5cbiAgdGFiaGVhZGVyLm5vZGUuc3R5bGUuaGVpZ2h0ID0gJydcbiAgdGFiaGVhZGVyLm5vZGUuc3R5bGUudG9wID0gdGFiaGVhZGVyLl9zdHlsZVRvcFxuXG4gIC8vIHJlY292ZXIgdGhlIHBvc2l0aW9uIG9mIHRhYmhlYWRlci5cbiAgdGFiaGVhZGVyLmZsYWcucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGFiaGVhZGVyLm5vZGUsIHRhYmhlYWRlci5mbGFnKVxuICAvLyByZWNvdmVyIHRoZSBwb3NpdGlvbiBvZiBzY29sbGVyLlxuICB0YWJoZWFkZXIuX2JvZHkuc2Nyb2xsTGVmdCA9IHRhYmhlYWRlci5fc2Nyb2xsVmFsXG5cbiAgc2Nyb2xsVG9WaWV3KHRhYmhlYWRlcilcbiAgdGFiaGVhZGVyLnVuZm9sZGluZyA9IGZhbHNlXG59XG5cbmZ1bmN0aW9uIGluaXRFdmVudCAodGFiaGVhZGVyKSB7XG4gIGluaXRDbGlja0V2ZW50KHRhYmhlYWRlcilcbiAgaW5pdFNlbGVjdEV2ZW50KHRhYmhlYWRlcilcbn1cblxuLy8gaW5pdCBldmVudHMuXG5mdW5jdGlvbiBpbml0Q2xpY2tFdmVudCAodGFiaGVhZGVyKSB7XG4gIGNvbnN0IGJveCA9IHRhYmhlYWRlci5ib3hcblxuICBib3guYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgbGV0IHRhcmdldCA9IGV2dC50YXJnZXRcbiAgICBpZiAodGFyZ2V0Lm5vZGVOYW1lID09PSAnVUwnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0LnBhcmVudE5vZGUubm9kZU5hbWUgPT09ICdMSScpIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlXG4gICAgfVxuXG4gICAgY29uc3QgZmxvb3IgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWZsb29yJylcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgICBpZiAodGFiaGVhZGVyLmRhdGEuYXR0ci5zZWxlY3RlZEluZGV4ID09IGZsb29yKSB7XG4gICAgICAvLyBEdXBsaWNhdGVkIGNsaWNraW5nLCBub3QgdG8gdHJpZ2dlciBzZWxlY3QgZXZlbnQuXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cblxuICAgIGZpcmVFdmVudCh0YXJnZXQsICdzZWxlY3QnLCB7IGluZGV4OiBmbG9vciB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBpbml0U2VsZWN0RXZlbnQgKHRhYmhlYWRlcikge1xuICBjb25zdCBub2RlID0gdGFiaGVhZGVyLm5vZGVcbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3QnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgbGV0IGluZGV4XG4gICAgaWYgKGV2dC5pbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmRleCA9IGV2dC5pbmRleFxuICAgIH1cbiAgICBlbHNlIGlmIChldnQuZGF0YSAmJiBldnQuZGF0YS5pbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmRleCA9IGV2dC5kYXRhLmluZGV4XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRhYmhlYWRlci5hdHRyLnNlbGVjdGVkSW5kZXguY2FsbCh0YWJoZWFkZXIsIGluZGV4KVxuICB9KVxufVxuXG5mdW5jdGlvbiBzY3JvbGxUb1ZpZXcgKHRhYmhlYWRlciwgbm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICBjb25zdCBhdHRyID0gdGFiaGVhZGVyLmRhdGEuYXR0clxuICAgIG5vZGUgPSB0YWJoZWFkZXIubm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1mbG9vcj1cIicgKyBhdHRyLnNlbGVjdGVkSW5kZXggKyAnXCJdJylcbiAgfVxuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNvbnN0IGRlZmF1bHRWYWwgPSB0YWJoZWFkZXIuX2JvZHkuc2Nyb2xsTGVmdFxuICAvLyBjb25zdCBsZWZ0VmFsID0gZGVmYXVsdFZhbCAtIG5vZGUub2Zmc2V0TGVmdCArIDMwMFxuXG4gIGNvbnN0IHNjcm9sbFZhbCA9IGdldFNjcm9sbFZhbCh0YWJoZWFkZXIuX2JvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG5vZGUpXG4gIGRvU2Nyb2xsKHRhYmhlYWRlci5fYm9keSwgc2Nyb2xsVmFsKVxufVxuXG4vLyBzY3JvbGwgdGhlIHRhYmhlYWRlci5cbi8vIHBvc2l0aXZlIHZhbCBtZWFucyB0byBzY3JvbGwgcmlnaHQuXG4vLyBuZWdhdGl2ZSB2YWwgbWVhbnMgdG8gc2Nyb2xsIGxlZnQuXG5mdW5jdGlvbiBkb1Njcm9sbCAobm9kZSwgdmFsLCBmaW5pc2gpIHtcbiAgaWYgKCF2YWwpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoZmluaXNoID09PSB1bmRlZmluZWQpIHtcbiAgICBmaW5pc2ggPSBNYXRoLmFicyh2YWwpXG4gIH1cblxuICBpZiAoZmluaXNoIDw9IDApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICh2YWwgPiAwKSB7XG4gICAgICBub2RlLnNjcm9sbExlZnQgKz0gMlxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG5vZGUuc2Nyb2xsTGVmdCAtPSAyXG4gICAgfVxuICAgIGZpbmlzaCAtPSAyXG5cbiAgICBkb1Njcm9sbChub2RlLCB2YWwsIGZpbmlzaClcbiAgfSlcbn1cblxuLy8gZ2V0IHNjcm9sbCBkaXN0YW5jZS5cbmZ1bmN0aW9uIGdldFNjcm9sbFZhbCAocmVjdCwgbm9kZSkge1xuICBjb25zdCBsZWZ0ID0gbm9kZS5wcmV2aW91c1NpYmxpbmdcbiAgY29uc3QgcmlnaHQgPSBub2RlLm5leHRTaWJsaW5nXG4gIGxldCBzY3JvbGxWYWxcblxuICAvLyBwcm9jZXNzIGxlZnQtc2lkZSBlbGVtZW50IGZpcnN0LlxuICBpZiAobGVmdCkge1xuICAgIGNvbnN0IGxlZnRSZWN0ID0gbGVmdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIC8vIG9ubHkgbmVlZCB0byBjb21wYXJlIHRoZSB2YWx1ZSBvZiBsZWZ0LlxuICAgIGlmIChsZWZ0UmVjdC5sZWZ0IDwgcmVjdC5sZWZ0KSB7XG4gICAgICBzY3JvbGxWYWwgPSBsZWZ0UmVjdC5sZWZ0XG4gICAgICByZXR1cm4gc2Nyb2xsVmFsXG4gICAgfVxuICB9XG5cbiAgaWYgKHJpZ2h0KSB7XG4gICAgY29uc3QgcmlnaHRSZWN0ID0gcmlnaHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAvLyBjb21wYXJlIHRoZSB2YWx1ZSBvZiByaWdodC5cbiAgICBpZiAocmlnaHRSZWN0LnJpZ2h0ID4gcmVjdC5yaWdodCkge1xuICAgICAgc2Nyb2xsVmFsID0gcmlnaHRSZWN0LnJpZ2h0IC0gcmVjdC5yaWdodFxuICAgICAgcmV0dXJuIHNjcm9sbFZhbFxuICAgIH1cbiAgfVxuXG4gIC8vIHByb2Nlc3MgY3VycmVudCBub2RlLCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gIGNvbnN0IG5vZGVSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBpZiAobm9kZVJlY3QubGVmdCA8IHJlY3QubGVmdCkge1xuICAgIHNjcm9sbFZhbCA9IG5vZGVSZWN0LmxlZnRcbiAgfVxuICBlbHNlIGlmIChub2RlUmVjdC5yaWdodCA+IHJlY3QucmlnaHQpIHtcbiAgICBzY3JvbGxWYWwgPSBub2RlUmVjdC5yaWdodCAtIHJlY3QucmlnaHRcbiAgfVxuXG4gIHJldHVybiBzY3JvbGxWYWxcbn1cblxuLy8gdHJpZ2dlciBhbmQgYnJvYWRjYXN0IGV2ZW50cy5cbmZ1bmN0aW9uIGZpcmVFdmVudCAoZWxlbWVudCwgdHlwZSwgZGF0YSkge1xuICBjb25zdCBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKVxuICBldnQuZGF0YSA9IGRhdGFcbiAgZm9yIChjb25zdCBrIGluIGRhdGEpIHtcbiAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgZXZ0W2tdID0gZGF0YVtrXVxuICAgIH1cbiAgfVxuICAvLyBuZWVkIGJ1YmJsZS5cbiAgZXZ0LmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKVxuXG4gIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldnQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhpZ2hsaWdodEljb24gKGNvZGUpIHtcbiAgY29uc3QgaHRtbCA9ICc8aSBjbGFzcz1cImhsLWljb24gaWNvbmZvbnRcIj4nICsgJyYjeGU2NTAnICsgJzwvaT4nXG4gIHJldHVybiBodG1sXG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRDb2xvciAoY29sb3IpIHtcbiAgaWYgKCFjb2xvcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGNvbG9yLmNoYXJBdCgwKSAhPT0gJyMnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoY29sb3IubGVuZ3RoICE9PSA3KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBwcm90byA9IHtcbiAgY3JlYXRlICgpIHtcbiAgICAvLyBvdXRzaWRlIGNvbnRhaW5lci5cbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBub2RlLmNsYXNzTmFtZSA9ICd0YWItaGVhZGVyJ1xuICAgIC8vIHRpcCBvbiB0aGUgdG9wLlxuICAgIGNvbnN0IGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgYmFyLmNsYXNzTmFtZSA9ICdoZWFkZXItYmFyJ1xuICAgIGJhci50ZXh0Q29udGVudCA9ICdDSEFOR0UgRkxPT1InXG4gICAgLy8gbWlkZGxlIGxheWVyLlxuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIGJvZHkuY2xhc3NOYW1lID0gJ2hlYWRlci1ib2R5J1xuICAgIGNvbnN0IGJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJylcbiAgICBib3guY2xhc3NOYW1lID0gJ3RhYmhlYWRlcidcblxuICAgIGJvZHkuYXBwZW5kQ2hpbGQoYm94KVxuICAgIG5vZGUuYXBwZW5kQ2hpbGQoYmFyKVxuICAgIG5vZGUuYXBwZW5kQ2hpbGQoYm9keSlcbiAgICB0aGlzLl9iYXIgPSBiYXJcbiAgICB0aGlzLl9ib2R5ID0gYm9keVxuICAgIHRoaXMuYm94ID0gYm94XG4gICAgdGhpcy5ub2RlID0gbm9kZVxuICAgIC8vIGluaXQgZXZlbnRzLlxuICAgIGluaXRGb2xkQnRuKHRoaXMpXG4gICAgaW5pdEV2ZW50KHRoaXMpXG4gICAgcmV0dXJuIG5vZGVcbiAgfVxufVxuXG5jb25zdCBhdHRyID0ge1xuICBoaWdobGlnaHRJY29uICgpIHtcbiAgICByZXR1cm4gY3JlYXRlSGlnaGxpZ2h0SWNvbigpXG4gIH0sXG5cbiAgZGF0YSAoKSB7XG4gICAgY29uc3QgYXR0ciA9IHRoaXMuZGF0YS5hdHRyXG4gICAgLy8gRW5zdXJlIHRoZXJlIGlzIGEgZGVmYXVsdCBzZWxlY3RlZCB2YWx1ZS5cbiAgICBpZiAoYXR0ci5zZWxlY3RlZEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGF0dHIuc2VsZWN0ZWRJbmRleCA9IDBcbiAgICB9XG5cbiAgICBjb25zdCBsaXN0ID0gYXR0ci5kYXRhIHx8IFtdXG4gICAgY29uc3QgY3VySXRlbSA9IGF0dHIuc2VsZWN0ZWRJbmRleFxuXG4gICAgY29uc3QgcmV0ID0gW11cbiAgICBjb25zdCBpdGVtVG1wbCA9ICc8bGkgY2xhc3M9XCJ0aC1pdGVtXCIgZGF0YS1mbG9vcj1cInt7Zmxvb3J9fVwiPidcbiAgICAgICAgKyAne3tobEljb259fXt7Zmxvb3JOYW1lfX08L2xpPidcblxuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaWR4KSB7XG4gICAgICBsZXQgaHRtbCA9IGl0ZW1UbXBsLnJlcGxhY2UoJ3t7Zmxvb3J9fScsIGlkeClcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuICAgICAgaWYgKGN1ckl0ZW0gPT0gaWR4KSB7XG4gICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoJ3t7aGxJY29ufX0nLCBjcmVhdGVIaWdobGlnaHRJY29uKCkpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgne3tobEljb259fScsICcnKVxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cblxuICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgne3tmbG9vck5hbWV9fScsIGl0ZW0pXG5cbiAgICAgIHJldC5wdXNoKGh0bWwpXG4gICAgfSwgdGhpcylcblxuICAgIHRoaXMuYm94LmlubmVySFRNTCA9IHJldC5qb2luKCcnKVxuICB9LFxuXG4gIHNlbGVjdGVkSW5kZXggKHZhbCkge1xuICAgIGNvbnN0IGF0dHIgPSB0aGlzLmRhdGEuYXR0clxuXG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWwgPSAwXG4gICAgfVxuXG4gICAgLy8gaWYgKHZhbCA9PSBhdHRyLnNlbGVjdGVkSW5kZXgpIHtcbiAgICAvLyAgIHJldHVyblxuICAgIC8vIH1cblxuICAgIGF0dHIuc2VsZWN0ZWRJbmRleCA9IHZhbFxuXG4gICAgdGhpcy5hdHRyLmRhdGEuY2FsbCh0aGlzKVxuXG4gICAgZm9sZGluZyh0aGlzKVxuICAgIHRoaXMuc3R5bGUudGV4dEhpZ2hsaWdodENvbG9yLmNhbGwodGhpcywgdGhpcy50ZXh0SGlnaGxpZ2h0Q29sb3IpXG4gIH1cbn1cblxuY29uc3Qgc3R5bGUgPSB7XG4gIG9wYWNpdHkgKHZhbCkge1xuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPCAwIHx8IHZhbCA+IDEpIHtcbiAgICAgIHZhbCA9IDFcbiAgICB9XG5cbiAgICB0aGlzLm5vZGUuc3R5bGUub3BhY2l0eSA9IHZhbFxuICB9LFxuXG4gIHRleHRDb2xvciAodmFsKSB7XG4gICAgaWYgKCFpc1ZhbGlkQ29sb3IodmFsKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5ub2RlLnN0eWxlLmNvbG9yID0gdmFsXG4gIH0sXG5cbiAgdGV4dEhpZ2hsaWdodENvbG9yICh2YWwpIHtcbiAgICBpZiAoIWlzVmFsaWRDb2xvcih2YWwpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy50ZXh0SGlnaGxpZ2h0Q29sb3IgPSB2YWxcbiAgICBjb25zdCBhdHRyID0gdGhpcy5kYXRhLmF0dHJcblxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGUucXVlcnlTZWxlY3RvcignW2RhdGEtZmxvb3I9XCInXG4gICAgICAgICsgYXR0ci5zZWxlY3RlZEluZGV4ICsgJ1wiXScpXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIG5vZGUuc3R5bGUuY29sb3IgPSB2YWxcbiAgICAgIHNjcm9sbFRvVmlldyh0aGlzLCBub2RlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0IChXZWV4KSB7XG4gIGNvbnN0IEF0b21pYyA9IFdlZXguQXRvbWljXG4gIGNvbnN0IGV4dGVuZCA9IFdlZXgudXRpbHMuZXh0ZW5kXG5cbiAgZnVuY3Rpb24gVGFiSGVhZGVyIChkYXRhKSB7XG4gICAgQXRvbWljLmNhbGwodGhpcywgZGF0YSlcbiAgfVxuICBUYWJIZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBdG9taWMucHJvdG90eXBlKVxuICBleHRlbmQoVGFiSGVhZGVyLnByb3RvdHlwZSwgcHJvdG8pXG4gIGV4dGVuZChUYWJIZWFkZXIucHJvdG90eXBlLCB7IGF0dHIgfSlcbiAgZXh0ZW5kKFRhYkhlYWRlci5wcm90b3R5cGUsIHtcbiAgICBzdHlsZTogZXh0ZW5kKE9iamVjdC5jcmVhdGUoQXRvbWljLnByb3RvdHlwZS5zdHlsZSksIHN0eWxlKVxuICB9KVxuXG4gIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3RhYkhlYWRlcicsIFRhYkhlYWRlcilcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBpbml0IH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy90YWJoZWFkZXIvaW5kZXguanNcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3RhYmhlYWRlci5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vdGFiaGVhZGVyLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3RhYmhlYWRlci5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3RhYmhlYWRlci90YWJoZWFkZXIuY3NzXG4gKiogbW9kdWxlIGlkID0gMTc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi50YWItaGVhZGVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHdpZHRoOiAxMHJlbTtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGNvbG9yOiAjMzMzO1xcbn1cXG4udGFiLWhlYWRlciAuaGVhZGVyLWJhciB7XFxuICBoZWlnaHQ6IDEuMTdyZW07XFxuICBsaW5lLWhlaWdodDogMS4xN3JlbTtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBjb2xvcjogIzk5OTtcXG4gIHBhZGRpbmctbGVmdDogMC40cmVtO1xcbn1cXG4udGFiLWhlYWRlciAuaGVhZGVyLWJvZHkge1xcbiAgbWFyZ2luLXJpZ2h0OiAxLjA3cmVtO1xcbiAgb3ZlcmZsb3cteDogYXV0bztcXG4gIG92ZXJmbG93LXk6IGhpZGRlbjtcXG59XFxuLnRhYi1oZWFkZXIgLmhlYWRlci1ib2R5Ojotd2Via2l0LXNjcm9sbGJhciB7XFxuICB3aWR0aDogMDtcXG4gIGhlaWdodDogMDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcbi50YWItaGVhZGVyIC5mb2xkLXRvZ2dsZSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDAuNTlyZW07XFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcXG4gIHJpZ2h0OiAwLjI5cmVtO1xcbiAgd2lkdGg6IDAuNDhyZW07XFxuICBoZWlnaHQ6IDAuNDhyZW07XFxuICBsaW5lLWhlaWdodDogMC40OHJlbTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHotaW5kZXg6IDk5O1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG4udGFiLWhlYWRlci51bmZvbGQtaGVhZGVyIHtcXG4gIHBvc2l0aW9uOiBmaXhlZCAhaW1wb3J0YW50O1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbi50YWJoZWFkZXIge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICBoZWlnaHQ6IDEuMTdyZW07XFxuICBsaW5lLWhlaWdodDogMS4xN3JlbTtcXG59XFxuLnRhYmhlYWRlciAudGgtaXRlbSB7XFxuICBwYWRkaW5nLWxlZnQ6IDAuNzJyZW07XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcbi50YWJoZWFkZXIgLmhsLWljb24ge1xcbiAgd2lkdGg6IDAuNHJlbTtcXG4gIGhlaWdodDogMC40cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDAuNHJlbTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNTAlO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxuICBsZWZ0OiAwLjI0cmVtO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG5cXG4udW5mb2xkLWhlYWRlciAuaGVhZGVyLWJhciB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLnVuZm9sZC1oZWFkZXIgLmZvbGQtdG9nZ2xlIHtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpIHJvdGF0ZSgxODBkZWcpO1xcbn1cXG4udW5mb2xkLWhlYWRlciAuaGVhZGVyLWJvZHkge1xcbiAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgcGFkZGluZzogMC4yNHJlbTtcXG59XFxuLnVuZm9sZC1oZWFkZXIgLnRhYmhlYWRlciB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGhlaWdodDogYXV0bztcXG59XFxuLnVuZm9sZC1oZWFkZXIgLnRoLWl0ZW0ge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgd2lkdGg6IDMzLjMzMzMlO1xcbiAgaGVpZ2h0OiAxLjAxcmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuMDFyZW07XFxufVxcbi51bmZvbGQtaGVhZGVyIC5obC1pY29uIHtcXG4gIG1hcmdpbi1yaWdodDogMDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuLnVuZm9sZC1oZWFkZXIudGFiaGVhZGVyLW1hc2sge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC42KTtcXG59XFxuXFxuLnRhYmhlYWRlci1tYXNrIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiAwO1xcbn1cXG5cXG5AZm9udC1mYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiaWNvbmZvbnRcXFwiO1xcbiAgc3JjOiB1cmwoXFxcImRhdGE6YXBwbGljYXRpb24veC1mb250LXR0ZjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxBQUVBQUFBUEFJQUFBd0J3UmtaVVRYQkQ5OFVBQUFEOEFBQUFIRTlUTHpKWEwxeklBQUFCR0FBQUFHQmpiV0Z3czZJSGJnQUFBWGdBQUFGYVkzWjBJQXlWL3N3QUFBcFFBQUFBSkdad1oyMHc5NTZWQUFBS2RBQUFDWlpuWVhOd0FBQUFFQUFBQ2tnQUFBQUlaMng1WnV4b1BGSUFBQUxVQUFBRVdHaGxZV1FIQTVoM0FBQUhMQUFBQURab2FHVmhCeklEY2dBQUIyUUFBQUFrYUcxMGVBczJBVzBBQUFlSUFBQUFHR3h2WTJFRGNBUWVBQUFIb0FBQUFCQnRZWGh3QVNrS0t3QUFCN0FBQUFBZ2JtRnRaUWwvM2hnQUFBZlFBQUFDTG5CdmMzVG03ZjBiQUFBS0FBQUFBRWh3Y21Wd3BibStaZ0FBRkF3QUFBQ1ZBQUFBQVFBQUFBRE1QYUxQQUFBQUFOSURLbm9BQUFBQTBnTXFld0FFQS9vQjlBQUZBQUFDbVFMTUFBQUFqd0taQXN3QUFBSHJBRE1CQ1FBQUFnQUdBd0FBQUFBQUFBQUFBQUVRQUFBQUFBQUFBQUFBQUFCUVprVmtBTUFBZU9iZUF5ei9MQUJjQXhnQWxBQUFBQUVBQUFBQUF4Z0FBQUFBQUNBQUFRQUFBQU1BQUFBREFBQUFIQUFCQUFBQUFBQlVBQU1BQVFBQUFCd0FCQUE0QUFBQUNnQUlBQUlBQWdCNDVsRG1ZZWJlLy84QUFBQjQ1bERtWWViZS8vLy9peG0wR2FRWktBQUJBQUFBQUFBQUFBQUFBQUFBQVFZQUFBRUFBQUFBQUFBQUFRSUFBQUFDQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0FDSUFBQUV5QXFvQUF3QUhBQ2xBSmdBQUFBTUNBQU5YQUFJQkFRSkxBQUlDQVU4RUFRRUNBVU1BQUFjR0JRUUFBd0FERVFVUEt6TVJJUkVuTXhFaklnRVE3c3pNQXFyOVZpSUNaZ0FBQUFVQUxQL2hBN3dER0FBV0FEQUFPZ0JTQUY0QmQwdXdFMUJZUUVvQ0FRQU5EZzBBRG1ZQUF3NEJEZ05lQUFFSUNBRmNFQUVKQ0FvR0NWNFJBUXdHQkFZTVhnQUxCQXRwRHdFSUFBWU1DQVpZQUFvSEJRSUVDd29FV1JJQkRnNE5VUUFORFFvT1FodExzQmRRV0VCTEFnRUFEUTROQUE1bUFBTU9BUTREWGdBQkNBZ0JYQkFCQ1FnS0NBa0taaEVCREFZRUJneGVBQXNFQzJrUEFRZ0FCZ3dJQmxnQUNnY0ZBZ1FMQ2dSWkVnRU9EZzFSQUEwTkNnNUNHMHV3R0ZCWVFFd0NBUUFORGcwQURtWUFBdzRCRGdOZUFBRUlDQUZjRUFFSkNBb0lDUXBtRVFFTUJnUUdEQVJtQUFzRUMya1BBUWdBQmd3SUJsZ0FDZ2NGQWdRTENnUlpFZ0VPRGcxUkFBME5DZzVDRzBCT0FnRUFEUTROQUE1bUFBTU9BUTREQVdZQUFRZ09BUWhrRUFFSkNBb0lDUXBtRVFFTUJnUUdEQVJtQUFzRUMya1BBUWdBQmd3SUJsZ0FDZ2NGQWdRTENnUlpFZ0VPRGcxUkFBME5DZzVDV1ZsWlFDaFRVenM3TWpFWEYxTmVVMTViV0R0U08xSkxRemMxTVRveU9oY3dGekJSRVRFWUVTZ1ZRQk1XS3dFR0t3RWlEZ0lkQVNFMU5DWTFOQzRDS3dFVklRVVZGQllVRGdJakJpWXJBU2NoQnlzQklpY2lMZ0k5QVJjaUJoUVdNekkyTkNZWEJnY09BeDRCT3dZeU5pY3VBU2NtSndFMU5ENENPd0V5RmgwQkFSa2JHbE1TSlJ3U0E1QUJDaGduSG9YK1NnS2lBUlVmSXc0T0h3NGdMZjVKTEIwaUZCa1pJQk1JZHd3U0Vnd05FaEtNQ0FZRkN3UUNCQThPSlVOUlVFQWtGeFlKQlFrRkJRYitwQVVQR2hXOEh5a0NId0VNR1NjYVRDa1FIQVFOSUJzU1lZZzBGem82SlJjSkFRR0FnQUVUR3lBT3B6OFJHaEVSR2hGOEdoWVRKQTRRRFFnWUdnMGpFUk1VQVhma0N4Z1REQjBtNHdBQUFnQ2cvMndEWUFMc0FCSUFHZ0FoUUI0QUFBQURBZ0FEV1FBQ0FRRUNUUUFDQWdGUkFBRUNBVVVURmprUUJCSXJBQ0FHRlJRZUF4Y1dPd0V5UHdFU05UUUFJaVkwTmpJV0ZBS1MvdHpPUkZWdk1SQUpEZ0VPQ1czYi91S0VYbDZFWGdMc3pwSTFsWHlKTmhFS0MzMEJESXlTL3M1ZWhGNWVoQUFBQUFFQWdnQkpBNFFCNkFBZEFCdEFHQklSQWdFQUFVQUZBUUErQUFBQkFHZ0FBUUZmRXg4Q0VDc0JKZ2NHQndrQkxnRUdCd1lVRndFd014Y1ZGakkzQVQ0RExnSURlaEVXQXdQK3VQNjBCaEVRQmdvS0FXRUJBUW9hQ1FGZUF3UUNBUUVDQkFIaEVnMERBdjYxQVVrSEJBVUdDUnNKL3FJQkFRa0pBV0lDQndZSENBWUdBQUVBZndDTEE0RUNKd0FoQUIxQUdoWVBBZ0VBQVVBRkFRQStBQUFCQUdnQ0FRRUJYeVF1RXdNUkt5VUJNQ2NqTlNZSEJnY0JEZ0VVRmhjZUFqTXlOd2tCRmpNeU5qYytBaTRCQTNmK253RUJFaFVFQXY2aUJRVUZCUU1IQ0FRT0NRRklBVXdLRFFZTUJRTUZBUUVGd3dGZUFRRVJEUUlEL3A4RkRBd01CQU1FQWdrQlMvNjJDUVVGQXdvSkNna0FBQUVBQUFBQkFBQUxJeW5vWHc4ODlRQUxCQUFBQUFBQTBnTXFld0FBQUFEU0F5cDdBQ0wvYkFPOEF4Z0FBQUFJQUFJQUFBQUFBQUFBQVFBQUF4ai9iQUJjQkFBQUFBQUFBN3dBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQVVCZGdBaUFBQUFBQUZWQUFBRDZRQXNCQUFBb0FDQ0FIOEFBQUFvQUNnQUtBRmtBYUlCNUFJc0FBRUFBQUFIQUY4QUJRQUFBQUFBQWdBbUFEUUFiQUFBQUlvSmxnQUFBQUFBQUFBTUFKWUFBUUFBQUFBQUFRQUlBQUFBQVFBQUFBQUFBZ0FHQUFnQUFRQUFBQUFBQXdBa0FBNEFBUUFBQUFBQUJBQUlBRElBQVFBQUFBQUFCUUJHQURvQUFRQUFBQUFBQmdBSUFJQUFBd0FCQkFrQUFRQVFBSWdBQXdBQkJBa0FBZ0FNQUpnQUF3QUJCQWtBQXdCSUFLUUFBd0FCQkFrQUJBQVFBT3dBQXdBQkJBa0FCUUNNQVB3QUF3QUJCQWtBQmdBUUFZaHBZMjl1Wm05dWRFMWxaR2wxYlVadmJuUkdiM0puWlNBeUxqQWdPaUJwWTI5dVptOXVkQ0E2SURJMkxUZ3RNakF4TldsamIyNW1iMjUwVm1WeWMybHZiaUF4TGpBZ095QjBkR1poZFhSdmFHbHVkQ0FvZGpBdU9UUXBJQzFzSURnZ0xYSWdOVEFnTFVjZ01qQXdJQzE0SURFMElDMTNJQ0pISWlBdFppQXRjMmxqYjI1bWIyNTBBR2tBWXdCdkFHNEFaZ0J2QUc0QWRBQk5BR1VBWkFCcEFIVUFiUUJHQUc4QWJnQjBBRVlBYndCeUFHY0FaUUFnQURJQUxnQXdBQ0FBT2dBZ0FHa0FZd0J2QUc0QVpnQnZBRzRBZEFBZ0FEb0FJQUF5QURZQUxRQTRBQzBBTWdBd0FERUFOUUJwQUdNQWJ3QnVBR1lBYndCdUFIUUFWZ0JsQUhJQWN3QnBBRzhBYmdBZ0FERUFMZ0F3QUNBQU93QWdBSFFBZEFCbUFHRUFkUUIwQUc4QWFBQnBBRzRBZEFBZ0FDZ0FkZ0F3QUM0QU9RQTBBQ2tBSUFBdEFHd0FJQUE0QUNBQUxRQnlBQ0FBTlFBd0FDQUFMUUJIQUNBQU1nQXdBREFBSUFBdEFIZ0FJQUF4QURRQUlBQXRBSGNBSUFBaUFFY0FJZ0FnQUMwQVpnQWdBQzBBY3dCcEFHTUFid0J1QUdZQWJ3QnVBSFFBQUFBQ0FBQUFBQUFBLzRNQU1nQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWNBQUFBQkFBSUFXd0VDQVFNQkJBZDFibWxGTmpVd0IzVnVhVVUyTmpFSGRXNXBSVFpFUlFBQkFBSC8vd0FQQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUF5QURJREdQL2hBeGovYkFNWS8rRURHUDlzc0FBc3NDQmdaaTJ3QVN3Z1pDQ3d3RkN3QkNaYXNBUkZXMWdoSXlFYmlsZ2dzRkJRV0NHd1FGa2JJTEE0VUZnaHNEaFpXU0N3Q2tWaFpMQW9VRmdoc0FwRklMQXdVRmdoc0RCWkd5Q3d3RkJZSUdZZ2lvcGhJTEFLVUZoZ0d5Q3dJRkJZSWJBS1lCc2dzRFpRV0NHd05tQWJZRmxaV1J1d0FDdFpXU093QUZCWVpWbFpMYkFDTENCRklMQUVKV0ZrSUxBRlExQllzQVVqUXJBR0kwSWJJU0Zac0FGZ0xiQURMQ01oSXlFZ1pMRUZZa0lnc0FZalFySUtBQUlxSVNDd0JrTWdpaUNLc0FBcnNUQUZKWXBSV0dCUUcyRlNXVmdqV1NFZ3NFQlRXTEFBS3hzaHNFQlpJN0FBVUZobFdTMndCQ3l3Q0NOQ3NBY2pRckFBSTBLd0FFT3dCME5SV0xBSVF5dXlBQUVBUTJCQ3NCWmxIRmt0c0FVc3NBQkRJRVVnc0FKRlk3QUJSV0pnUkMyd0JpeXdBRU1nUlNDd0FDc2pzUVFFSldBZ1JZb2pZU0JrSUxBZ1VGZ2hzQUFic0RCUVdMQWdHN0JBV1ZranNBQlFXR1Zac0FNbEkyRkVSQzJ3Qnl5eEJRVkZzQUZoUkMyd0NDeXdBV0FnSUxBS1EwcXdBRkJZSUxBS0kwSlpzQXREU3JBQVVsZ2dzQXNqUWxrdHNBa3NJTGdFQUdJZ3VBUUFZNG9qWWJBTVEyQWdpbUFnc0F3alFpTXRzQW9zUzFSWXNRY0JSRmtrc0ExbEkzZ3RzQXNzUzFGWVMxTllzUWNCUkZrYklWa2tzQk5sSTNndHNBd3NzUUFOUTFWWXNRME5RN0FCWVVLd0NTdFpzQUJEc0FJbFFySUFBUUJEWUVLeENnSWxRckVMQWlWQ3NBRVdJeUN3QXlWUVdMQUFRN0FFSlVLS2lpQ0tJMkd3Q0NvaEk3QUJZU0NLSTJHd0NDb2hHN0FBUTdBQ0pVS3dBaVZoc0FncUlWbXdDa05Ic0F0RFIyQ3dnR0lnc0FKRlk3QUJSV0pnc1FBQUV5TkVzQUZEc0FBK3NnRUJBVU5nUWkyd0RTeXhBQVZGVkZnQXNBMGpRaUJnc0FGaHRRNE9BUUFNQUVKQ2ltQ3hEQVFyc0dzckd5SlpMYkFPTExFQURTc3RzQThzc1FFTkt5MndFQ3l4QWcwckxiQVJMTEVERFNzdHNCSXNzUVFOS3kyd0V5eXhCUTByTGJBVUxMRUdEU3N0c0JVc3NRY05LeTJ3Rml5eENBMHJMYkFYTExFSkRTc3RzQmdzc0FjcnNRQUZSVlJZQUxBTkkwSWdZTEFCWWJVT0RnRUFEQUJDUW9wZ3NRd0VLN0JyS3hzaVdTMndHU3l4QUJnckxiQWFMTEVCR0NzdHNCc3NzUUlZS3kyd0hDeXhBeGdyTGJBZExMRUVHQ3N0c0I0c3NRVVlLeTJ3SHl5eEJoZ3JMYkFnTExFSEdDc3RzQ0Vzc1FnWUt5MndJaXl4Q1JnckxiQWpMQ0Jnc0E1Z0lFTWpzQUZnUTdBQ0piQUNKVkZZSXlBOHNBRmdJN0FTWlJ3YklTRlpMYkFrTExBaks3QWpLaTJ3SlN3Z0lFY2dJTEFDUldPd0FVVmlZQ05oT0NNZ2lsVllJRWNnSUxBQ1JXT3dBVVZpWUNOaE9Cc2hXUzJ3Sml5eEFBVkZWRmdBc0FFV3NDVXFzQUVWTUJzaVdTMndKeXl3Qnl1eEFBVkZWRmdBc0FFV3NDVXFzQUVWTUJzaVdTMndLQ3dnTmJBQllDMndLU3dBc0FORlk3QUJSV0t3QUN1d0FrVmpzQUZGWXJBQUs3QUFGclFBQUFBQUFFUStJeml4S0FFVktpMndLaXdnUENCSElMQUNSV093QVVWaVlMQUFRMkU0TGJBckxDNFhQQzJ3TEN3Z1BDQkhJTEFDUldPd0FVVmlZTEFBUTJHd0FVTmpPQzJ3TFN5eEFnQVdKU0F1SUVld0FDTkNzQUlsU1lxS1J5TkhJMkVnV0dJYklWbXdBU05Dc2l3QkFSVVVLaTJ3TGl5d0FCYXdCQ1d3QkNWSEkwY2pZYkFHUlN0bGlpNGpJQ0E4aWpndHNDOHNzQUFXc0FRbHNBUWxJQzVISTBjallTQ3dCQ05Dc0FaRkt5Q3dZRkJZSUxCQVVWaXpBaUFESUJ1ekFpWURHbGxDUWlNZ3NBbERJSW9qUnlOSEkyRWpSbUN3QkVPd2dHSmdJTEFBS3lDS2ltRWdzQUpEWUdRanNBTkRZV1JRV0xBQ1EyRWJzQU5EWUZtd0F5V3dnR0poSXlBZ3NBUW1JMFpoT0JzanNBbERSckFDSmJBSlEwY2pSeU5oWUNDd0JFT3dnR0pnSXlDd0FDc2pzQVJEWUxBQUs3QUZKV0d3QlNXd2dHS3dCQ1poSUxBRUpXQmtJN0FESldCa1VGZ2hHeU1oV1NNZ0lMQUVKaU5HWVRoWkxiQXdMTEFBRmlBZ0lMQUZKaUF1UnlOSEkyRWpQRGd0c0RFc3NBQVdJTEFKSTBJZ0lDQkdJMGV3QUNzallUZ3RzRElzc0FBV3NBTWxzQUlsUnlOSEkyR3dBRlJZTGlBOEl5RWJzQUlsc0FJbFJ5TkhJMkVnc0FVbHNBUWxSeU5ISTJHd0JpV3dCU1ZKc0FJbFliQUJSV01qSUZoaUd5RlpZN0FCUldKZ0l5NGpJQ0E4aWpnaklWa3RzRE1zc0FBV0lMQUpReUF1UnlOSEkyRWdZTEFnWUdhd2dHSWpJQ0E4aWpndHNEUXNJeUF1UnJBQ0pVWlNXQ0E4V1M2eEpBRVVLeTJ3TlN3aklDNUdzQUlsUmxCWUlEeFpMckVrQVJRckxiQTJMQ01nTGthd0FpVkdVbGdnUEZraklDNUdzQUlsUmxCWUlEeFpMckVrQVJRckxiQTNMTEF1S3lNZ0xrYXdBaVZHVWxnZ1BGa3VzU1FCRkNzdHNEZ3NzQzhyaWlBZ1BMQUVJMEtLT0NNZ0xrYXdBaVZHVWxnZ1BGa3VzU1FCRkN1d0JFTXVzQ1FyTGJBNUxMQUFGckFFSmJBRUppQXVSeU5ISTJHd0JrVXJJeUE4SUM0ak9MRWtBUlFyTGJBNkxMRUpCQ1ZDc0FBV3NBUWxzQVFsSUM1SEkwY2pZU0N3QkNOQ3NBWkZLeUN3WUZCWUlMQkFVVml6QWlBRElCdXpBaVlER2xsQ1FpTWdSN0FFUTdDQVltQWdzQUFySUlxS1lTQ3dBa05nWkNPd0EwTmhaRkJZc0FKRFlSdXdBME5nV2JBREpiQ0FZbUd3QWlWR1lUZ2pJRHdqT0JzaElDQkdJMGV3QUNzallUZ2hXYkVrQVJRckxiQTdMTEF1S3k2eEpBRVVLeTJ3UEN5d0x5c2hJeUFnUExBRUkwSWpPTEVrQVJRcnNBUkRMckFrS3kyd1BTeXdBQlVnUjdBQUkwS3lBQUVCRlJRVExyQXFLaTJ3UGl5d0FCVWdSN0FBSTBLeUFBRUJGUlFUTHJBcUtpMndQeXl4QUFFVUU3QXJLaTJ3UUN5d0xTb3RzRUVzc0FBV1JTTWdMaUJHaWlOaE9MRWtBUlFyTGJCQ0xMQUpJMEt3UVNzdHNFTXNzZ0FBT2lzdHNFUXNzZ0FCT2lzdHNFVXNzZ0VBT2lzdHNFWXNzZ0VCT2lzdHNFY3NzZ0FBT3lzdHNFZ3NzZ0FCT3lzdHNFa3NzZ0VBT3lzdHNFb3NzZ0VCT3lzdHNFc3NzZ0FBTnlzdHNFd3NzZ0FCTnlzdHNFMHNzZ0VBTnlzdHNFNHNzZ0VCTnlzdHNFOHNzZ0FBT1NzdHNGQXNzZ0FCT1NzdHNGRXNzZ0VBT1NzdHNGSXNzZ0VCT1NzdHNGTXNzZ0FBUENzdHNGUXNzZ0FCUENzdHNGVXNzZ0VBUENzdHNGWXNzZ0VCUENzdHNGY3NzZ0FBT0NzdHNGZ3NzZ0FCT0NzdHNGa3NzZ0VBT0NzdHNGb3NzZ0VCT0NzdHNGc3NzREFyTHJFa0FSUXJMYkJjTExBd0s3QTBLeTJ3WFN5d01DdXdOU3N0c0Y0c3NBQVdzREFyc0RZckxiQmZMTEF4S3k2eEpBRVVLeTJ3WUN5d01TdXdOQ3N0c0dFc3NERXJzRFVyTGJCaUxMQXhLN0EyS3kyd1l5eXdNaXN1c1NRQkZDc3RzR1Fzc0RJcnNEUXJMYkJsTExBeUs3QTFLeTJ3Wml5d01pdXdOaXN0c0djc3NETXJMckVrQVJRckxiQm9MTEF6SzdBMEt5MndhU3l3TXl1d05Tc3RzR29zc0RNcnNEWXJMYkJyTEN1d0NHV3dBeVJRZUxBQkZUQXRBQUJMdUFESVVsaXhBUUdPV2JrSUFBZ0FZeUN3QVNORUlMQURJM0N3RGtVZ0lFdTRBQTVSUzdBR1UxcFlzRFFic0NoWllHWWdpbFZZc0FJbFliQUJSV01qWXJBQ0kwU3pDZ2tGQkN1ekNnc0ZCQ3V6RGc4RkJDdFpzZ1FvQ1VWU1JMTUtEUVlFSzdFR0FVU3hKQUdJVVZpd1FJaFlzUVlEUkxFbUFZaFJXTGdFQUloWXNRWUJSRmxaV1ZtNEFmK0ZzQVNOc1FVQVJBQUFBQT09XFxcIikgZm9ybWF0KFxcXCJ0cnVldHlwZVxcXCIpO1xcbn1cXG4uaWNvbmZvbnQge1xcbiAgZm9udC1mYW1pbHk6IGljb25mb250ICFpbXBvcnRhbnQ7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gIC13ZWJraXQtdGV4dC1zdHJva2Utd2lkdGg6IDAuMnB4O1xcbiAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTtcXG59XFxuXFxuW2RhdGEtZHByPVxcXCIyXFxcIl0gLnRhYi1oZWFkZXIge1xcbiAgZm9udC1zaXplOiAyOHB4O1xcbn1cXG5cXG5bZGF0YS1kcHI9XFxcIjNcXFwiXSAudGFiLWhlYWRlciB7XFxuICBmb250LXNpemU6IDQycHg7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiMlxcXCJdIC50YWJoZWFkZXIgLmhsLWljb24ge1xcbiAgZm9udC1zaXplOiAyOHB4O1xcbn1cXG5cXG5bZGF0YS1kcHI9XFxcIjNcXFwiXSAudGFiaGVhZGVyIC5obC1pY29uIHtcXG4gIGZvbnQtc2l6ZTogNDJweDtcXG59XFxuXFxuW2RhdGEtZHByPVxcXCIyXFxcIl0gLnRhYi1oZWFkZXIgLmZvbGQtdG9nZ2xlIHtcXG4gIGZvbnQtc2l6ZTogMjhweDtcXG59XFxuXFxuW2RhdGEtZHByPVxcXCIzXFxcIl0gLnRhYi1oZWFkZXIgLmZvbGQtdG9nZ2xlIHtcXG4gIGZvbnQtc2l6ZTogNDJweDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvdGFiaGVhZGVyL3RhYmhlYWRlci5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5sZXQgYXBwZW5kU3R5bGVcblxuY29uc3QgYXZhaWxhYmxlVHlwZXMgPSBbJ3RleHQnLCAncGFzc3dvcmQnLCAndGVsJywgJ2VtYWlsJywgJ3VybCddXG5jb25zdCBERUZBVUxUX1RZUEUgPSAndGV4dCdcblxuZnVuY3Rpb24gc2V0UGxhY2Vob2xkZXJDb2xvciAoaW5wdXQsIHBsYWNlaG9sZGVyQ29sb3IpIHtcbiAgaWYgKCFwbGFjZWhvbGRlckNvbG9yKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgdmVuZG9ycyA9IFtcbiAgICAnOjotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVyJyxcbiAgICAnOi1tb3otcGxhY2Vob2xkZXInLFxuICAgICc6Oi1tb3otcGxhY2Vob2xkZXInLFxuICAgICc6LW1zLWlucHV0LXBsYWNlaG9sZGVyJyxcbiAgICAnOnBsYWNlaG9sZGVyLXNob3duJ1xuICBdXG4gIGxldCBjc3MgPSAnJ1xuICBjb25zdCBjc3NSdWxlID0gJ2NvbG9yOiAnICsgcGxhY2Vob2xkZXJDb2xvciArICc7J1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHZlbmRvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY3NzICs9ICcuJyArIGlucHV0LmNsYXNzTmFtZSArIHZlbmRvcnNbaV0gKyAneydcbiAgICAgICAgICAgKyBjc3NSdWxlICsgJ30nXG4gIH1cbiAgYXBwZW5kU3R5bGUoY3NzLCBpbnB1dC5zdHlsZUlkLCB0cnVlKVxufVxuXG5jb25zdCBwcm90byA9IHtcbiAgY3JlYXRlICgpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgIGNvbnN0IHV1aWQgPSBNYXRoLmZsb29yKDEwMDAwMDAwMDAwMDAwICogTWF0aC5yYW5kb20oKSkgKyBEYXRlLm5vdygpXG4gICAgdGhpcy5jbGFzc05hbWUgPSAnd2VleC1pcHQtJyArIHV1aWRcbiAgICB0aGlzLnN0eWxlSWQgPSAnd2VleC1zdHlsZS0nICsgdXVpZFxuICAgIG5vZGUuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZSlcbiAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtZWxlbWVudCcpXG4gICAgdGhpcy5wbGFjZWhvbGRlciAmJiAobm9kZS5wbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXIpXG4gICAgcmV0dXJuIG5vZGVcbiAgfVxufVxuXG4vLyB1cGRhdGFibGUgYXR0cmlidXRlc1xuY29uc3QgYXR0ciA9IHtcbiAgZGlzYWJsZWQgKHZhbCkge1xuICAgIHRoaXMubm9kZS5kaXNhYmxlZCA9ICEhdmFsXG4gIH0sXG5cbiAgcGxhY2Vob2xkZXIgKHZhbCkge1xuICAgIHRoaXMubm9kZS5wbGFjZWhvbGRlciA9IHZhbCB8fCAnJ1xuICB9LFxuXG4gIHZhbHVlICh2YWwpIHtcbiAgICB0aGlzLm5vZGUudmFsdWUgPSB2YWwgfHwgJydcbiAgfSxcblxuICBhdXRvZm9jdXMgKHZhbCkge1xuICAgIHRoaXMubm9kZS5hdXRvZm9jdXMgPSAhIXZhbFxuICB9LFxuXG4gIHR5cGUgKHZhbCkge1xuICAgIHRoaXMubm9kZS50eXBlID0gYXZhaWxhYmxlVHlwZXMuaW5kZXhPZih2YWwpICE9PSAtMVxuICAgICAgPyB2YWxcbiAgICAgIDogREVGQVVMVF9UWVBFXG4gIH1cbn1cblxuLy8gdXBkYXRhYmxlIHN0eWxlc1xuY29uc3Qgc3R5bGUgPSB7XG4gIHBsYWNlaG9sZGVyQ29sb3I6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBzZXRQbGFjZWhvbGRlckNvbG9yKHRoaXMsIHZhbClcbiAgfVxufVxuXG4vLyBldmVudHMgY29uZmlndXJhdGlvbnNcbmNvbnN0IGV2ZW50ID0ge1xuICBpbnB1dDoge1xuICAgIHVwZGF0b3IgKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICB2YWx1ZTogdGhpcy5ub2RlLnZhbHVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGV4dHJhICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB0aGlzLm5vZGUudmFsdWUsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjaGFuZ2U6IHtcbiAgICB1cGRhdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHZhbHVlOiB0aGlzLm5vZGUudmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZXh0cmE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB0aGlzLm5vZGUudmFsdWUsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0IChXZWV4KSB7XG4gIGNvbnN0IEF0b21pYyA9IFdlZXguQXRvbWljXG4gIGNvbnN0IGV4dGVuZCA9IFdlZXgudXRpbHMuZXh0ZW5kXG4gIGFwcGVuZFN0eWxlID0gV2VleC51dGlscy5hcHBlbmRTdHlsZVxuXG4gIC8vIGF0dHJzOlxuICAvLyAgIC0gdHlwZTogdGV4dHxwYXNzd29yZHx0ZWx8ZW1haWx8dXJsXG4gIC8vICAgLSB2YWx1ZVxuICAvLyAgIC0gcGxhY2Vob2xkZXJcbiAgLy8gICAtIGRpc2FibGVkXG4gIC8vICAgLSBhdXRvZm9jdXNcbiAgZnVuY3Rpb24gSW5wdXQgKGRhdGEpIHtcbiAgICBBdG9taWMuY2FsbCh0aGlzLCBkYXRhKVxuICB9XG4gIElucHV0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXRvbWljLnByb3RvdHlwZSlcbiAgZXh0ZW5kKElucHV0LnByb3RvdHlwZSwgcHJvdG8pXG4gIGV4dGVuZChJbnB1dC5wcm90b3R5cGUsIHsgYXR0ciB9KVxuICBleHRlbmQoSW5wdXQucHJvdG90eXBlLCB7XG4gICAgc3R5bGU6IGV4dGVuZChPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUuc3R5bGUpLCBzdHlsZSlcbiAgfSlcbiAgZXh0ZW5kKElucHV0LnByb3RvdHlwZSwgeyBldmVudCB9KVxuXG4gIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ2lucHV0JywgSW5wdXQpXG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgaW5pdCB9XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvaW5wdXQuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxucmVxdWlyZSgnLi92aWRlby5jc3MnKVxuXG5mdW5jdGlvbiBnZXRQcm90byAoV2VleCkge1xuICBjb25zdCBBdG9taWMgPSBXZWV4LkF0b21pY1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZSAoKSB7XG4gICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKVxuICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCd3ZWV4LXZpZGVvJywgJ3dlZXgtZWxlbWVudCcpXG4gICAgICBub2RlLmNvbnRyb2xzID0gdHJ1ZVxuICAgICAgbm9kZS5hdXRvcGxheSA9IHRoaXMuYXV0b1BsYXlcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdwbGF5LXN0YXR1cycsIHRoaXMucGxheVN0YXR1cylcbiAgICAgIHRoaXMubm9kZSA9IG5vZGVcbiAgICAgIGlmICh0aGlzLmF1dG9QbGF5ICYmIHRoaXMucGxheVN0YXR1cyA9PT0gJ3BsYXknKSB7XG4gICAgICAgIHRoaXMucGxheSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZVxuICAgIH0sXG5cbiAgICBiaW5kRXZlbnRzIChldnRzKSB7XG4gICAgICBBdG9taWMucHJvdG90eXBlLmJpbmRFdmVudHMuY2FsbCh0aGlzLCBldnRzKVxuXG4gICAgICAvLyBjb252ZXJ0IHczYy12aWRlbyBldmVudHMgdG8gd2VleC12aWRlbyBldmVudHMuXG4gICAgICBjb25zdCBldnRzTWFwID0ge1xuICAgICAgICBzdGFydDogJ3BsYXknLFxuICAgICAgICBmaW5pc2g6ICdlbmRlZCcsXG4gICAgICAgIGZhaWw6ICdlcnJvcidcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgZXZ0TmFtZSBpbiBldnRzTWFwKSB7XG4gICAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dHNNYXBbZXZ0TmFtZV0sIGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHR5cGUsIGUuZGF0YSlcbiAgICAgICAgfS5iaW5kKHRoaXMsIGV2dE5hbWUpKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwbGF5ICgpIHtcbiAgICAgIGxldCBzcmMgPSB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKCdzcmMnKVxuICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgc3JjID0gdGhpcy5ub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKVxuICAgICAgICBzcmMgJiYgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgnc3JjJywgc3JjKVxuICAgICAgfVxuICAgICAgdGhpcy5ub2RlLnBsYXkoKVxuICAgIH0sXG5cbiAgICBwYXVzZSAoKSB7XG4gICAgICB0aGlzLm5vZGUucGF1c2UoKVxuICAgIH0sXG5cbiAgICBzdG9wICgpIHtcbiAgICAgIHRoaXMubm9kZS5wYXVzZSgpXG4gICAgICB0aGlzLm5vZGUuYXV0b3BsYXkgPSBmYWxzZVxuICAgICAgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1zcmMnLCB0aGlzLm5vZGUuc3JjKVxuICAgICAgdGhpcy5ub2RlLnNyYyA9ICcnXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGF0dHIgPSB7XG4gIHBsYXlTdGF0dXMgKHZhbCkge1xuICAgIGlmICh2YWwgIT09ICdwbGF5JyAmJiB2YWwgIT09ICdzdG9wJyAmJiB2YWwgIT09ICdwYXVzZScpIHtcbiAgICAgIHZhbCA9ICdwYXVzZSdcbiAgICB9XG4gICAgaWYgKHRoaXMucGxheVN0YXR1cyA9PT0gdmFsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5wbGF5U3RhdHVzID0gdmFsXG4gICAgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgncGxheS1zdGF0dXMnLCB2YWwpXG4gICAgdGhpc1t0aGlzLnBsYXlTdGF0dXNdKClcbiAgfSxcblxuICBhdXRvUGxheSAodmFsKSB7XG4gICAgLy8gRE8gTk9USElOR1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXQgKFdlZXgpIHtcbiAgY29uc3QgQXRvbWljID0gV2VleC5BdG9taWNcbiAgY29uc3QgZXh0ZW5kID0gV2VleC51dGlscy5leHRlbmRcblxuICAvLyBhdHRyczpcbiAgLy8gICAtIGF1dG9QbGF5OiB0cnVlIHwgZmFsc2UgKGRlZmF1bHQ6IGZhbHNlKVxuICAvLyAgIC0gcGxheVN0YXR1czogcGxheSB8IHBhdXNlIHwgc3RvcFxuICAvLyAgIC0gc3JjOiB7c3RyaW5nfVxuICAvLyAgIC0gcG9zdGVyOiB7c3RyaW5nfVxuICAvLyAgIC0gbG9vcDogdHJ1ZSB8IGZhbHNlIChkZWZhdWx0OiBmYWxzZSlcbiAgLy8gICAtIG11dGVkOiB0cnVlIHwgZmFsc2UgKGRlZmF1bHQ6IGZhbHNlKVxuICAvLyBldmVudHM6XG4gIC8vICAgLSBzdGFydFxuICAvLyAgIC0gcGF1c2VcbiAgLy8gICAtIGZpbmlzaFxuICAvLyAgIC0gZmFpbFxuICBmdW5jdGlvbiBWaWRlbyAoZGF0YSkge1xuICAgIGNvbnN0IGF1dG9QbGF5ID0gZGF0YS5hdHRyLmF1dG9QbGF5XG4gICAgY29uc3QgcGxheVN0YXR1cyA9IGRhdGEuYXR0ci5wbGF5U3RhdHVzXG4gICAgdGhpcy5hdXRvUGxheSA9IGF1dG9QbGF5ID09PSB0cnVlIHx8IGF1dG9QbGF5ID09PSAndHJ1ZSdcbiAgICBpZiAocGxheVN0YXR1cyAhPT0gJ3BsYXknXG4gICAgICAgICYmIHBsYXlTdGF0dXMgIT09ICdzdG9wJ1xuICAgICAgICAmJiBwbGF5U3RhdHVzICE9PSAncGF1c2UnKSB7XG4gICAgICB0aGlzLnBsYXlTdGF0dXMgPSAncGF1c2UnXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5wbGF5U3RhdHVzID0gcGxheVN0YXR1c1xuICAgIH1cbiAgICBBdG9taWMuY2FsbCh0aGlzLCBkYXRhKVxuICB9XG4gIFZpZGVvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXRvbWljLnByb3RvdHlwZSlcbiAgZXh0ZW5kKFZpZGVvLnByb3RvdHlwZSwgZ2V0UHJvdG8oV2VleCkpXG4gIGV4dGVuZChWaWRlby5wcm90b3R5cGUsIHsgYXR0ciB9KVxuXG4gIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3ZpZGVvJywgVmlkZW8pXG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgaW5pdCB9XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy92aWRlby9pbmRleC5qc1xuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vdmlkZW8uY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3ZpZGVvLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3ZpZGVvLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvdmlkZW8vdmlkZW8uY3NzXG4gKiogbW9kdWxlIGlkID0gMTc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi53ZWV4LXZpZGVvIHtcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwO1xcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy92aWRlby92aWRlby5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5yZXF1aXJlKCcuL3N3aXRjaC5jc3MnKVxuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgY29sb3I6ICcjNjRiZDYzJyxcbiAgc2Vjb25kYXJ5Q29sb3I6ICcjZGZkZmRmJyxcbiAgamFja0NvbG9yOiAnI2ZmZicsXG4gIGphY2tTZWNvbmRhcnlDb2xvcjogbnVsbCxcbiAgY2xhc3NOYW1lOiAnd2VleC1zd2l0Y2gnLFxuICBkaXNhYmxlZE9wYWNpdHk6IDAuNSxcbiAgc3BlZWQ6ICcwLjRzJyxcbiAgd2lkdGg6IDEwMCxcbiAgaGVpZ2h0OiA2MCxcbiAgLy8gaXMgd2lkdGggYW5kIGhlaWdodCBzY2FsYWJsZSA/XG4gIHNjYWxhYmxlOiBmYWxzZVxufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uaXplIChlbGVtZW50LCBwcm9wcykge1xuICBjb25zdCB0cmFuc2l0aW9ucyA9IFtdXG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgdHJhbnNpdGlvbnMucHVzaChrZXkgKyAnICcgKyBwcm9wc1trZXldKVxuICB9XG4gIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25zLmpvaW4oJywgJylcbiAgZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbnMuam9pbignLCAnKVxufVxuXG5mdW5jdGlvbiBzZXRTaXplIChjb21wKSB7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKGNvbXAud2lkdGgsIGNvbXAuaGVpZ2h0KVxuICBjb25zdCBtYXggPSBNYXRoLm1heChjb21wLndpZHRoLCBjb21wLmhlaWdodClcbiAgY29tcC5ub2RlLnN0eWxlLndpZHRoID0gbWF4ICsgJ3B4J1xuICBjb21wLm5vZGUuc3R5bGUuaGVpZ2h0ID0gbWluICsgJ3B4J1xuICBjb21wLm5vZGUuc3R5bGUuYm9yZGVyUmFkaXVzID0gbWluIC8gMiArICdweCdcbiAgY29tcC5qYWNrLnN0eWxlLndpZHRoXG4gICAgICA9IGNvbXAuamFjay5zdHlsZS5oZWlnaHRcbiAgICAgID0gbWluICsgJ3B4J1xufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGlvbiAoY29tcCwgY2xpY2tlZCkge1xuICBsZXQgY2hlY2tlZCA9IGNvbXAuY2hlY2tlZFxuICBjb25zdCBub2RlID0gY29tcC5ub2RlXG4gIGNvbnN0IGphY2sgPSBjb21wLmphY2tcblxuICBpZiAoY2xpY2tlZCAmJiBjaGVja2VkKSB7XG4gICAgY2hlY2tlZCA9IGZhbHNlXG4gIH1cbiAgZWxzZSBpZiAoY2xpY2tlZCAmJiAhY2hlY2tlZCkge1xuICAgIGNoZWNrZWQgPSB0cnVlXG4gIH1cblxuICBpZiAoY2hlY2tlZCA9PT0gdHJ1ZSkge1xuICAgIGNvbXAuY2hlY2tlZCA9IHRydWVcblxuICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgamFjay5zdHlsZS5sZWZ0ID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSkud2lkdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAtIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGphY2spLndpZHRoKSArICdweCdcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBqYWNrLnN0eWxlLmxlZnQgPSBwYXJzZUludChub2RlLmN1cnJlbnRTdHlsZVsnd2lkdGgnXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gcGFyc2VJbnQoamFjay5jdXJyZW50U3R5bGVbJ3dpZHRoJ10pICsgJ3B4J1xuICAgIH1cblxuICAgIGNvbXAub3B0aW9ucy5jb2xvciAmJiBjb2xvcml6ZShjb21wKVxuICAgIHNldFNwZWVkKGNvbXApXG4gIH1cbiAgZWxzZSB7XG4gICAgY29tcC5jaGVja2VkID0gZmFsc2VcbiAgICBqYWNrLnN0eWxlLmxlZnQgPSAwXG4gICAgbm9kZS5zdHlsZS5ib3hTaGFkb3cgPSAnaW5zZXQgMCAwIDAgMCAnICsgY29tcC5vcHRpb25zLnNlY29uZGFyeUNvbG9yXG4gICAgbm9kZS5zdHlsZS5ib3JkZXJDb2xvciA9IGNvbXAub3B0aW9ucy5zZWNvbmRhcnlDb2xvclxuICAgIG5vZGUuc3R5bGUuYmFja2dyb3VuZENvbG9yXG4gICAgICAgID0gKGNvbXAub3B0aW9ucy5zZWNvbmRhcnlDb2xvciAhPT0gZGVmYXVsdHMuc2Vjb25kYXJ5Q29sb3IpXG4gICAgICAgICAgPyBjb21wLm9wdGlvbnMuc2Vjb25kYXJ5Q29sb3JcbiAgICAgICAgICA6ICcjZmZmJ1xuICAgIGphY2suc3R5bGUuYmFja2dyb3VuZENvbG9yXG4gICAgICAgID0gKGNvbXAub3B0aW9ucy5qYWNrU2Vjb25kYXJ5Q29sb3IgIT09IGNvbXAub3B0aW9ucy5qYWNrQ29sb3IpXG4gICAgICAgICAgPyBjb21wLm9wdGlvbnMuamFja1NlY29uZGFyeUNvbG9yXG4gICAgICAgICAgOiBjb21wLm9wdGlvbnMuamFja0NvbG9yXG4gICAgc2V0U3BlZWQoY29tcClcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRTcGVlZCAoY29tcCkge1xuICBsZXQgc3dpdGNoZXJQcm9wID0ge31cbiAgY29uc3QgamFja1Byb3AgPSB7XG4gICAgJ2JhY2tncm91bmQtY29sb3InOiBjb21wLm9wdGlvbnMuc3BlZWQsXG4gICAgbGVmdDogY29tcC5vcHRpb25zLnNwZWVkLnJlcGxhY2UoL1thLXpdLywgJycpIC8gMiArICdzJ1xuICB9XG5cbiAgaWYgKGNvbXAuY2hlY2tlZCkge1xuICAgIHN3aXRjaGVyUHJvcCA9IHtcbiAgICAgIGJvcmRlcjogY29tcC5vcHRpb25zLnNwZWVkLFxuICAgICAgJ2JveC1zaGFkb3cnOiBjb21wLm9wdGlvbnMuc3BlZWQsXG4gICAgICAnYmFja2dyb3VuZC1jb2xvcic6IGNvbXAub3B0aW9ucy5zcGVlZC5yZXBsYWNlKC9bYS16XS8sICcnKSAqIDMgKyAncydcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgc3dpdGNoZXJQcm9wID0ge1xuICAgICAgYm9yZGVyOiBjb21wLm9wdGlvbnMuc3BlZWQsXG4gICAgICAnYm94LXNoYWRvdyc6IGNvbXAub3B0aW9ucy5zcGVlZFxuICAgIH1cbiAgfVxuXG4gIHRyYW5zaXRpb25pemUoY29tcC5ub2RlLCBzd2l0Y2hlclByb3ApXG4gIHRyYW5zaXRpb25pemUoY29tcC5qYWNrLCBqYWNrUHJvcClcbn1cblxuZnVuY3Rpb24gY29sb3JpemUgKGNvbXApIHtcbiAgY29uc3Qgbm9kZUhlaWdodCA9IGNvbXAubm9kZS5vZmZzZXRIZWlnaHQgLyAyXG5cbiAgY29tcC5ub2RlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbXAub3B0aW9ucy5jb2xvclxuICBjb21wLm5vZGUuc3R5bGUuYm9yZGVyQ29sb3IgPSBjb21wLm9wdGlvbnMuY29sb3JcbiAgY29tcC5ub2RlLnN0eWxlLmJveFNoYWRvdyA9ICdpbnNldCAwIDAgMCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIG5vZGVIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJ3B4ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgY29tcC5vcHRpb25zLmNvbG9yXG4gIGNvbXAuamFjay5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb21wLm9wdGlvbnMuamFja0NvbG9yXG59XG5cbmZ1bmN0aW9uIGdldENsaWNrSGFuZGxlciAoY29tcCkge1xuICBpZiAoIWNvbXAuX2NsaWNrSGFuZGxlcikge1xuICAgIGNvbXAuX2NsaWNrSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFBvc2l0aW9uKGNvbXAsIHRydWUpXG4gICAgICBjb21wLmRpc3BhdGNoRXZlbnQoJ2NoYW5nZScsIHtcbiAgICAgICAgdmFsdWU6IGNvbXAuY2hlY2tlZFxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXAuX2NsaWNrSGFuZGxlclxufVxuXG5jb25zdCBwcm90byA9IHtcbiAgY3JlYXRlICgpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gICAgdGhpcy5qYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc21hbGwnKVxuICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5qYWNrKVxuICAgIG5vZGUuY2xhc3NOYW1lID0gdGhpcy5vcHRpb25zLmNsYXNzTmFtZVxuICAgIHRoaXMubm9kZSA9IG5vZGVcbiAgICB0aGlzLmF0dHIuZGlzYWJsZWQuY2FsbCh0aGlzLCB0aGlzLmRhdGEuYXR0ci5kaXNhYmxlZClcbiAgICByZXR1cm4gbm9kZVxuICB9LFxuXG4gIG9uQXBwZW5kICgpIHtcbiAgICBzZXRTaXplKHRoaXMpXG4gICAgc2V0UG9zaXRpb24odGhpcylcbiAgfSxcblxuICBlbmFibGUgKCkge1xuICAgIHRoaXMuZGlzYWJsZWQgJiYgKHRoaXMuZGlzYWJsZWQgPSBmYWxzZSlcbiAgICB0aGlzLm5vZGUuc3R5bGUub3BhY2l0eSA9IDFcbiAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBnZXRDbGlja0hhbmRsZXIodGhpcykpXG4gIH0sXG5cbiAgZGlzYWJsZSAoKSB7XG4gICAgIXRoaXMuZGlzYWJsZWQgJiYgKHRoaXMuZGlzYWJsZWQgPSB0cnVlKVxuICAgIHRoaXMubm9kZS5zdHlsZS5vcGFjaXR5ID0gZGVmYXVsdHMuZGlzYWJsZWRPcGFjaXR5XG4gICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZ2V0Q2xpY2tIYW5kbGVyKHRoaXMpKVxuICB9XG59XG5cbmNvbnN0IGF0dHIgPSB7XG4gIGRpc2FibGVkOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdGhpcy5kaXNhYmxlZCA9IHZhbCAmJiB2YWwgIT09ICdmYWxzZSdcbiAgICB0aGlzLmRpc2FibGVkID8gdGhpcy5kaXNhYmxlKCkgOiB0aGlzLmVuYWJsZSgpXG4gIH1cbn1cblxuY29uc3Qgc3R5bGUgPSB7XG4gIHdpZHRoOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2NhbGFibGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbClcbiAgICBpZiAoaXNOYU4odmFsKSB8fCB2YWwgPCAwKSB7XG4gICAgICB2YWwgPSB0aGlzLm9wdGlvbnMud2lkdGhcbiAgICB9XG4gICAgdGhpcy53aWR0aCA9IHZhbCAqIHRoaXMuZGF0YS5zY2FsZVxuICAgIHRoaXMuc2V0U2l6ZSgpXG4gIH0sXG5cbiAgaGVpZ2h0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2NhbGFibGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbClcbiAgICBpZiAoaXNOYU4odmFsKSB8fCB2YWwgPCAwKSB7XG4gICAgICB2YWwgPSB0aGlzLm9wdGlvbnMuaGVpZ2h0XG4gICAgfVxuICAgIHRoaXMuaGVpZ2h0ID0gdmFsICogdGhpcy5kYXRhLnNjYWxlXG4gICAgdGhpcy5zZXRTaXplKClcbiAgfVxufVxuXG5jb25zdCBldmVudCA9IHtcbiAgY2hhbmdlOiB7XG4gICAgdXBkYXRvciAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGNoZWNrZWQ6IHRoaXMuY2hlY2tlZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBleHRyYSAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdGhpcy5jaGVja2VkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXQgKFdlZXgpIHtcbiAgY29uc3QgQXRvbWljID0gV2VleC5BdG9taWNcbiAgY29uc3QgZXh0ZW5kID0gV2VleC51dGlscy5leHRlbmRcblxuICAvLyBhdHRyczpcbiAgLy8gICAtIGNoZWNrZWQ6IGlmIGlzIGNoZWNrZWQuXG4gIC8vICAgLSBkaXNhYmxlZDogaWYgdHJ1ZSwgdGhpcyBjb21wb25lbnQgaXMgbm90IGF2YWlsYWJsZSBmb3IgaW50ZXJhY3Rpb24uXG4gIGZ1bmN0aW9uIFN3aXRjaCAoZGF0YSkge1xuICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMpXG4gICAgdGhpcy5jaGVja2VkID0gZGF0YS5hdHRyLmNoZWNrZWRcbiAgICAgICAgJiYgZGF0YS5hdHRyLmNoZWNrZWQgIT09ICdmYWxzZSdcbiAgICB0aGlzLmRhdGEgPSBkYXRhXG4gICAgdGhpcy53aWR0aCA9IHRoaXMub3B0aW9ucy53aWR0aCAqIGRhdGEuc2NhbGVcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMub3B0aW9ucy5oZWlnaHQgKiBkYXRhLnNjYWxlXG4gICAgQXRvbWljLmNhbGwodGhpcywgZGF0YSlcbiAgfVxuICBTd2l0Y2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBdG9taWMucHJvdG90eXBlKVxuICBleHRlbmQoU3dpdGNoLnByb3RvdHlwZSwgcHJvdG8pXG4gIGV4dGVuZChTd2l0Y2gucHJvdG90eXBlLCB7IGF0dHIgfSlcbiAgZXh0ZW5kKFN3aXRjaC5wcm90b3R5cGUsIHtcbiAgICBzdHlsZTogZXh0ZW5kKE9iamVjdC5jcmVhdGUoQXRvbWljLnByb3RvdHlwZS5zdHlsZSksIHN0eWxlKVxuICB9KVxuICBleHRlbmQoU3dpdGNoLnByb3RvdHlwZSwgeyBldmVudCB9KVxuXG4gIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3N3aXRjaCcsIFN3aXRjaClcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBpbml0IH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zd2l0Y2gvaW5kZXguanNcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3N3aXRjaC5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3dpdGNoLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3N3aXRjaC5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3N3aXRjaC9zd2l0Y2guY3NzXG4gKiogbW9kdWxlIGlkID0gMTgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIHN3aXRjaCBkZWZhdWx0cy4gKi9cXG4ud2VleC1zd2l0Y2gge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNkZmRmZGY7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcbiAgYmFja2dyb3VuZC1jbGlwOiBjb250ZW50LWJveDtcXG59XFxuXFxuLndlZXgtc3dpdGNoID4gc21hbGwge1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIGJvcmRlci1yYWRpdXM6IDEwMCU7XFxuICBib3gtc2hhZG93OiAwIDFweCAzcHggcmdiYSgwLCAwLCAwLCAwLjQpO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9zd2l0Y2gvc3dpdGNoLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmZ1bmN0aW9uIGdldFByb3RvIChXZWV4KSB7XG4gIGNvbnN0IENvbXBvbmVudCA9IFdlZXguQ29tcG9uZW50XG4gIHJldHVybiB7XG4gICAgY3JlYXRlICgpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1jb250YWluZXInKVxuICAgICAgbm9kZS5zdHlsZS50ZXh0RGVjb3JhdGlvbiA9ICdub25lJ1xuICAgICAgcmV0dXJuIG5vZGVcbiAgICB9LFxuXG4gICAgYmluZEV2ZW50cyAoZXZ0cykge1xuICAgICAgLy8gZXZlbnQgaGFuZGxlciBmb3IgY2xpY2sgZXZlbnQgd2lsbCBiZSBwcm9jZXNzZWRcbiAgICAgIC8vIGJlZm9yZSB0aGUgdXJsIHJlZGlyZWN0aW9uLlxuICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5iaW5kRXZlbnRzLmNhbGwodGhpcywgZXZ0cylcbiAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgaWYgKGV2dC5fYWxyZWFkeUZpcmVkICYmIGV2dC50YXJnZXQgIT09IHRoaXMubm9kZSkge1xuICAgICAgICAgIC8vIGlmIHRoZSBldmVudCB0YXJnZXQgaXMgdGhpcy5ub2RlLCB0aGVuIHRoaXMgaXNcbiAgICAgICAgICAvLyBqdXN0IGFub3RoZXIgY2xpY2sgZXZlbnQgaGFuZGxlciBmb3IgdGhlIHNhbWVcbiAgICAgICAgICAvLyB0YXJnZXQsIG5vdCBhIGhhbmRsZXIgZm9yIGEgYnViYmxpbmcgdXAgZXZlbnQsXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IGlzIGEgYnViYmxpbmcgdXAgZXZlbnQsIGFuZCBpdFxuICAgICAgICAgIC8vIHNob3VsZCBiZSBkaXNyZWdhcmRlZC5cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBldnQuX2FscmVhZHlGaXJlZCA9IHRydWVcbiAgICAgICAgbG9jYXRpb24uaHJlZiA9IHRoaXMuaHJlZlxuICAgICAgfS5iaW5kKHRoaXMpKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBhdHRyID0ge1xuICBocmVmOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKCF2YWwpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ1t3ZWItcmVuZGVyXSBocmVmIG9mIDxhPiBzaG91bGQgbm90IGJlIGEgbnVsbCB2YWx1ZS4nKVxuICAgIH1cbiAgICB0aGlzLmhyZWYgPSB2YWxcbiAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLWhyZWYnLCB2YWwpXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdCAoV2VleCkge1xuICBjb25zdCBDb21wb25lbnQgPSBXZWV4LkNvbXBvbmVudFxuICBjb25zdCBleHRlbmQgPSBXZWV4LnV0aWxzLmV4dGVuZFxuXG4gIC8vIGF0dHJzOlxuICAvLyAgIC0gaHJlZlxuICBmdW5jdGlvbiBBIChkYXRhKSB7XG4gICAgQ29tcG9uZW50LmNhbGwodGhpcywgZGF0YSlcbiAgfVxuXG4gIEEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlKVxuICBleHRlbmQoQS5wcm90b3R5cGUsIGdldFByb3RvKFdlZXgpKVxuICBleHRlbmQoQS5wcm90b3R5cGUsIHsgYXR0ciB9KVxuXG4gIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ2EnLCBBKVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvYS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBJRF9QUkVGSVggPSAnd2VleF9lbWJlZF8nXG5cbmxldCBnZXRSYW5kb21cblxuZnVuY3Rpb24gX2dlbmVyYXRlSWQgKCkge1xuICByZXR1cm4gSURfUFJFRklYICsgZ2V0UmFuZG9tKDEwKVxufVxuXG5jb25zdCBwcm90byA9IHtcbiAgY3JlYXRlICgpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBub2RlLmlkID0gdGhpcy5pZFxuICAgIG5vZGUuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJ1xuICAgIHJldHVybiBub2RlXG4gIH0sXG5cbiAgaW5pdFdlZXggKCkge1xuICAgIHRoaXMuaWQgPSBfZ2VuZXJhdGVJZCgpXG4gICAgdGhpcy5ub2RlLmlkID0gdGhpcy5pZFxuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIGFwcElkOiB0aGlzLmlkLFxuICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgIGJ1bmRsZVVybDogdGhpcy5zb3VyY2UsXG4gICAgICBsb2FkZXI6IHRoaXMubG9hZGVyLFxuICAgICAganNvbnBDYWxsYmFjazogdGhpcy5qc29ucENhbGxiYWNrLFxuICAgICAgd2lkdGg6IHRoaXMubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCxcbiAgICAgIHJvb3RJZDogdGhpcy5pZCxcbiAgICAgIGVtYmVkOiB0cnVlXG4gICAgfVxuICAgIHdpbmRvdy53ZWV4LmluaXQoY29uZmlnKVxuICB9LFxuXG4gIGRlc3Ryb3lXZWV4ICgpIHtcbiAgICB0aGlzLmlkICYmIHdpbmRvdy5kZXN0cm95SW5zdGFuY2UodGhpcy5pZClcbiAgICAvLyBUT0RPOiB1bmJpbmQgZXZlbnRzIGFuZCBjbGVhciBkb21zLlxuICAgIHRoaXMubm9kZS5pbm5lckhUTUwgPSAnJ1xuICB9LFxuXG4gIHJlbG9hZFdlZXggKCkge1xuICAgIGlmICh0aGlzLmlkKSB7XG4gICAgICB0aGlzLmRlc3Ryb3lXZWV4KClcbiAgICAgIHRoaXMuaWQgPSBudWxsXG4gICAgICB0aGlzLm5vZGUuaWQgPSBudWxsXG4gICAgICB0aGlzLm5vZGUuaW5uZXJIVE1MID0gJydcbiAgICB9XG4gICAgdGhpcy5pbml0V2VleCgpXG4gIH1cbn1cblxuLy8gbm90IHJlY29tbWVuZGVkLCBiZWNhdXNlIG9mIHRoZSBsZWFrIG9mIG1lbW9yeS5cbmNvbnN0IGF0dHIgPSB7XG4gIHNyYzogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSB2YWx1ZVxuICAgIHRoaXMucmVsb2FkV2VleCgpXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdCAoV2VleCkge1xuICBjb25zdCBDb21wb25lbnQgPSBXZWV4LkNvbXBvbmVudFxuICBjb25zdCBleHRlbmQgPSBXZWV4LnV0aWxzLmV4dGVuZFxuICBnZXRSYW5kb20gPSBXZWV4LnV0aWxzLmdldFJhbmRvbVxuXG4gIGZ1bmN0aW9uIEVtYmVkIChkYXRhLCBub2RlVHlwZSkge1xuICAgIGNvbnN0IGF0dHIgPSBkYXRhLmF0dHJcbiAgICBpZiAoYXR0cikge1xuICAgICAgdGhpcy5zb3VyY2UgPSBhdHRyLnNyY1xuICAgICAgdGhpcy5sb2FkZXIgPSBhdHRyLmxvYWRlciB8fCAneGhyJ1xuICAgICAgdGhpcy5qc29ucENhbGxiYWNrID0gYXR0ci5qc29ucENhbGxiYWNrXG4gICAgfVxuICAgIENvbXBvbmVudC5jYWxsKHRoaXMsIGRhdGEsIG5vZGVUeXBlKVxuICB9XG5cbiAgRW1iZWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlKVxuICBleHRlbmQoRW1iZWQucHJvdG90eXBlLCBwcm90bylcbiAgZXh0ZW5kKEVtYmVkLnByb3RvdHlwZSwgeyBhdHRyIH0pXG5cbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnZW1iZWQnLCBFbWJlZClcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBpbml0IH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy9lbWJlZC5qc1xuICoqLyIsIi8qIGdsb2JhbCBDU1NSdWxlICovXG5cbid1c2Ugc3RyaWN0J1xuXG5yZXF1aXJlKCcuL3NwaW5uZXIuY3NzJylcblxubGV0IGxvb3BBcnJheSwgZ2V0UmdiXG5cbmZ1bmN0aW9uIGdldFN0eWxlU2hlZXQgKHNwaW5uZXIpIHtcbiAgaWYgKHNwaW5uZXIuc3R5bGVTaGVldCkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHN0eWxlcyA9IGRvY3VtZW50LnN0eWxlU2hlZXRzXG4gIGxldCBpLCBsLCBqLCBtXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWxhYmVscyAqL1xuICBvdXRlcjogZm9yIChpID0gMCwgbCA9IHN0eWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBydWxlcyA9IHN0eWxlc1tpXS5ydWxlc1xuICAgIGZvciAoaiA9IDAsIG0gPSBydWxlcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBydWxlcy5pdGVtKGopXG4gICAgICBpZiAoXG4gICAgICAgIChpdGVtLnR5cGUgPT09IENTU1J1bGUuS0VZRlJBTUVTX1JVTEVcbiAgICAgICAgICB8fCBpdGVtLnR5cGUgPT09IENTU1J1bGUuV0VCS0lUX0tFWUZSQU1FU19SVUxFKVxuICAgICAgICAmJiBpdGVtLm5hbWUgPT09ICdzcGlubmVyJykge1xuICAgICAgICBicmVhayBvdXRlclxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWxhYmVscyAqL1xuICBzcGlubmVyLnN0eWxlU2hlZXQgPSBzdHlsZXNbaV1cbn1cblxuZnVuY3Rpb24gc2V0S2V5ZnJhbWVDb2xvciAoc3Bpbm5lciwgdmFsKSB7XG4gIGdldFN0eWxlU2hlZXQoc3Bpbm5lcilcbiAgY29uc3Qga2V5ZnJhbWVSdWxlcyA9IGNvbXB1dGVLZXlGcmFtZVJ1bGVzKHZhbClcbiAgY29uc3QgcnVsZXMgPSBzcGlubmVyLnN0eWxlU2hlZXQucnVsZXNcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBydWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBpdGVtID0gcnVsZXMuaXRlbShpKVxuICAgIGlmICgoaXRlbS50eXBlID09PSBDU1NSdWxlLktFWUZSQU1FU19SVUxFXG4gICAgICAgICAgfHwgaXRlbS50eXBlID09PSBDU1NSdWxlLldFQktJVF9LRVlGUkFNRVNfUlVMRSlcbiAgICAgICAgJiYgaXRlbS5uYW1lID09PSAnc3Bpbm5lcicpIHtcbiAgICAgIGNvbnN0IGNzc1J1bGVzID0gaXRlbS5jc3NSdWxlc1xuICAgICAgZm9yIChsZXQgaiA9IDAsIG0gPSBjc3NSdWxlcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgICAgY29uc3Qga2V5ZnJhbWUgPSBjc3NSdWxlc1tqXVxuICAgICAgICBpZiAoa2V5ZnJhbWUudHlwZSA9PT0gQ1NTUnVsZS5LRVlGUkFNRV9SVUxFXG4gICAgICAgICAgfHwga2V5ZnJhbWUudHlwZSA9PT0gQ1NTUnVsZS5XRUJLSVRfS0VZRlJBTUVfUlVMRSkge1xuICAgICAgICAgIGtleWZyYW1lLnN0eWxlLmJveFNoYWRvdyA9IGtleWZyYW1lUnVsZXNbal1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlS2V5RnJhbWVSdWxlcyAocmdiKSB7XG4gIGlmICghcmdiKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3Qgc2NhbGVBcnIgPSBbXG4gICAgJzBlbSAtMi42ZW0gMGVtIDBlbScsXG4gICAgJzEuOGVtIC0xLjhlbSAwIDBlbScsXG4gICAgJzIuNWVtIDBlbSAwIDBlbScsXG4gICAgJzEuNzVlbSAxLjc1ZW0gMCAwZW0nLFxuICAgICcwZW0gMi41ZW0gMCAwZW0nLFxuICAgICctMS44ZW0gMS44ZW0gMCAwZW0nLFxuICAgICctMi42ZW0gMGVtIDAgMGVtJyxcbiAgICAnLTEuOGVtIC0xLjhlbSAwIDBlbSddXG4gIGNvbnN0IGNvbG9yQXJyID0gW1xuICAgICcxJyxcbiAgICAnMC4yJyxcbiAgICAnMC4yJyxcbiAgICAnMC4yJyxcbiAgICAnMC4yJyxcbiAgICAnMC4yJyxcbiAgICAnMC41JyxcbiAgICAnMC43J10ubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gJ3JnYmEoJyArIHJnYi5yICsgJywnICsgcmdiLmcgKyAnLCcgKyByZ2IuYiArICcsJyArIGUgKyAnKSdcbiAgICB9KVxuICBjb25zdCBydWxlcyA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2NhbGVBcnIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0bXBDb2xvckFyciA9IGxvb3BBcnJheShjb2xvckFyciwgaSwgJ3InKVxuICAgIHJ1bGVzLnB1c2goc2NhbGVBcnIubWFwKGZ1bmN0aW9uIChzY2FsZVN0ciwgaSkge1xuICAgICAgcmV0dXJuIHNjYWxlU3RyICsgJyAnICsgdG1wQ29sb3JBcnJbaV1cbiAgICB9KS5qb2luKCcsICcpKVxuICB9XG4gIHJldHVybiBydWxlc1xufVxuXG5jb25zdCBwcm90byA9IHtcbiAgY3JlYXRlICgpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtY29udGFpbmVyJywgJ3dlZXgtc3Bpbm5lci13cmFwJylcbiAgICB0aGlzLnNwaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMuc3Bpbm5lci5jbGFzc0xpc3QuYWRkKCd3ZWV4LWVsZW1lbnQnLCAnd2VleC1zcGlubmVyJylcbiAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuc3Bpbm5lcilcbiAgICByZXR1cm4gbm9kZVxuICB9XG59XG5cbmNvbnN0IHN0eWxlID0ge1xuICBjb2xvcjogZnVuY3Rpb24gKHZhbCkge1xuICAgIGNvbnN0IHJnYiA9IGdldFJnYih2YWwpXG4gICAgaWYgKCFyZ2IpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdbd2ViLXJlbmRlcl0gaW52YWxpZCBjb2xvciB2YWx1ZTonLCB2YWwpXG4gICAgfVxuICAgIHNldEtleWZyYW1lQ29sb3IodGhpcywgcmdiKVxuICB9XG59XG5cbi8vIFNwaW5uZXIucHJvdG90eXBlLnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4vLyAgIEF0b21pYy5wcm90b3R5cGUudXBkYXRlU3R5bGUuY2FsbCh0aGlzLCBzdHlsZSlcbi8vICAgaWYgKHN0eWxlICYmIHN0eWxlLmNvbG9yKSB7XG4vLyAgICAgdGhpcy5zZXRLZXlmcmFtZUNvbG9yKGdsb2JhbC53ZWV4LnV0aWxzLmdldFJnYih0aGlzLm5vZGUuc3R5bGUuY29sb3IpKVxuLy8gICB9XG4vLyB9XG5cbmZ1bmN0aW9uIGluaXQgKFdlZXgpIHtcbiAgY29uc3QgQXRvbWljID0gV2VleC5BdG9taWNcbiAgY29uc3QgZXh0ZW5kID0gV2VleC51dGlscy5leHRlbmRcbiAgZ2V0UmdiID0gV2VleC51dGlscy5nZXRSZ2JcbiAgbG9vcEFycmF5ID0gV2VleC51dGlscy5sb29wQXJyYXlcblxuICBmdW5jdGlvbiBTcGlubmVyIChkYXRhKSB7XG4gICAgQXRvbWljLmNhbGwodGhpcywgZGF0YSlcbiAgfVxuICBTcGlubmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXRvbWljLnByb3RvdHlwZSlcbiAgZXh0ZW5kKFNwaW5uZXIucHJvdG90eXBlLCBwcm90bylcbiAgZXh0ZW5kKFNwaW5uZXIucHJvdG90eXBlLCB7XG4gICAgc3R5bGU6IGV4dGVuZChPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUuc3R5bGUpLCBzdHlsZSlcbiAgfSlcblxuICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdzcGlubmVyJywgU3Bpbm5lcilcbiAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnbG9hZGluZy1pbmRpY2F0b3InLCBTcGlubmVyKVxufVxuXG5leHBvcnQgZGVmYXVsdCB7IGluaXQgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NwaW5uZXIvaW5kZXguanNcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3NwaW5uZXIuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3NwaW5uZXIuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3Bpbm5lci5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9jb21wb25lbnRzL3NwaW5uZXIvc3Bpbm5lci5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLndlZXgtc3Bpbm5lci13cmFwIHtcXG4gIHdpZHRoOiAxLjAxMzMzM3JlbTsgLyogNzZweCAqL1xcbiAgaGVpZ2h0OiAxLjAxMzMzM3JlbTtcXG4gIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XFxuICAtd2Via2l0LWFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xcbiAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxufVxcblxcbi53ZWV4LXNwaW5uZXIge1xcbiAgZm9udC1zaXplOiAwLjE2cmVtOyAvKiAxMnB4ICovXFxuICB3aWR0aDogMWVtO1xcbiAgaGVpZ2h0OiAxZW07XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB0ZXh0LWluZGVudDogLTk5OTllbTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uOiBzcGlubmVyIDEuMXMgaW5maW5pdGUgZWFzZTtcXG4gIGFuaW1hdGlvbjogc3Bpbm5lciAxLjFzIGluZmluaXRlIGVhc2U7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcXG4gIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XFxufVxcbkAtd2Via2l0LWtleWZyYW1lcyBzcGlubmVyIHtcXG4gIDAlLFxcbiAgMTAwJSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSAjZmZmZmZmLCAxLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpO1xcbiAgfVxcbiAgMTIuNSUge1xcbiAgICBib3gtc2hhZG93OiAwZW0gLTIuNmVtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAxLjhlbSAtMS44ZW0gMCAwZW0gI2ZmZmZmZiwgMi41ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMS43NWVtIDEuNzVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDBlbSAyLjVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAxLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0yLjZlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcXG4gIH1cXG4gIDI1JSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIDIuNWVtIDBlbSAwIDBlbSAjZmZmZmZmLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgfVxcbiAgMzcuNSUge1xcbiAgICBib3gtc2hhZG93OiAwZW0gLTIuNmVtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAxLjc1ZW0gMS43NWVtIDAgMGVtICNmZmZmZmYsIDBlbSAyLjVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAxLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0yLjZlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXG4gIH1cXG4gIDUwJSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDIuNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIDEuNzVlbSAxLjc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAwZW0gMi41ZW0gMCAwZW0gI2ZmZmZmZiwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgfVxcbiAgNjIuNSUge1xcbiAgICBib3gtc2hhZG93OiAwZW0gLTIuNmVtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSwgLTEuOGVtIDEuOGVtIDAgMGVtICNmZmZmZmYsIC0yLjZlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXG4gIH1cXG4gIDc1JSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDIuNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuNzVlbSAxLjc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwZW0gMi41ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpLCAtMS44ZW0gMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAtMi42ZW0gMGVtIDAgMGVtICNmZmZmZmYsIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgfVxcbiAgODcuNSUge1xcbiAgICBib3gtc2hhZG93OiAwZW0gLTIuNmVtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIC0xLjhlbSAtMS44ZW0gMCAwZW0gI2ZmZmZmZjtcXG4gIH1cXG59XFxuQGtleWZyYW1lcyBzcGlubmVyIHtcXG4gIDAlLFxcbiAgMTAwJSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSAjZmZmZmZmLCAxLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpO1xcbiAgfVxcbiAgMTIuNSUge1xcbiAgICBib3gtc2hhZG93OiAwZW0gLTIuNmVtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAxLjhlbSAtMS44ZW0gMCAwZW0gI2ZmZmZmZiwgMi41ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMS43NWVtIDEuNzVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDBlbSAyLjVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAxLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0yLjZlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcXG4gIH1cXG4gIDI1JSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIDIuNWVtIDBlbSAwIDBlbSAjZmZmZmZmLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgfVxcbiAgMzcuNSUge1xcbiAgICBib3gtc2hhZG93OiAwZW0gLTIuNmVtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAxLjc1ZW0gMS43NWVtIDAgMGVtICNmZmZmZmYsIDBlbSAyLjVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAxLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0yLjZlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXG4gIH1cXG4gIDUwJSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDIuNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIDEuNzVlbSAxLjc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAwZW0gMi41ZW0gMCAwZW0gI2ZmZmZmZiwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgfVxcbiAgNjIuNSUge1xcbiAgICBib3gtc2hhZG93OiAwZW0gLTIuNmVtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSwgLTEuOGVtIDEuOGVtIDAgMGVtICNmZmZmZmYsIC0yLjZlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXG4gIH1cXG4gIDc1JSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDIuNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuNzVlbSAxLjc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwZW0gMi41ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpLCAtMS44ZW0gMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAtMi42ZW0gMGVtIDAgMGVtICNmZmZmZmYsIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgfVxcbiAgODcuNSUge1xcbiAgICBib3gtc2hhZG93OiAwZW0gLTIuNmVtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIC0xLjhlbSAtMS44ZW0gMCAwZW0gI2ZmZmZmZjtcXG4gIH1cXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2NvbXBvbmVudHMvc3Bpbm5lci9zcGlubmVyLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmxldCBpc0FycmF5XG5cbmZ1bmN0aW9uIGhhbmRsZU1zZyAod2ViLCBldnQpIHtcbiAgbGV0IG1zZyA9IGV2dC5kYXRhXG4gIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBtc2cgPSBKU09OLnBhcnNlKG1zZylcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHt9XG4gIH1cbiAgaWYgKCFtc2cpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAobXNnLnR5cGUgPT09ICd3ZWV4Jykge1xuICAgIGlmICghaXNBcnJheShtc2cuY29udGVudCkpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSB3ZWV4IG1zZyByZWNlaXZlZCBieSB3ZWIgY29tcG9uZW50LidcbiAgICAgICAgKyAnIG1zZy5jb250ZW50IHNob3VsZCBiZSBhIGFycmF5OicsIG1zZy5jb250ZW50KVxuICAgIH1cbiAgICBjYWxsTmF0aXZlKHdlYi5nZXRDb21wb25lbnRNYW5hZ2VyKCkuaW5zdGFuY2VJZCwgbXNnLmNvbnRlbnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvdG8gKFdlZXgpIHtcbiAgY29uc3QgQXRvbWljID0gV2VleC5BdG9taWNcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGUgKCkge1xuICAgICAgLy8gSWZyYW1lJ3MgZGVmZWN0OiBjYW4ndCB1c2UgcG9zaXRpb246YWJzb2x1dGUgYW5kIHRvcCwgbGVmdCwgcmlnaHQsXG4gICAgICAvLyBib3R0b20gYWxsIHNldHRpbmcgdG8gemVybyBhbmQgdXNlIG1hcmdpbiB0byBsZWF2ZSBzcGVjaWZpZWRcbiAgICAgIC8vIGhlaWdodCBmb3IgYSBibGFuayBhcmVhLCBhbmQgaGF2ZSB0byB1c2UgMTAwJSB0byBmaWxsIHRoZSBwYXJlbnRcbiAgICAgIC8vIGNvbnRhaW5lciwgb3RoZXJ3aXNlIGl0IHdpbGwgdXNlIGEgdW53YW50ZWQgZGVmYXVsdCBzaXplIGluc3RlYWQuXG4gICAgICAvLyBUaGVyZWZvcmUgYSBkaXYgYXMgYSBpZnJhbWUgd3JhcHBlciBpcyBuZWVkZWQgaGVyZS5cbiAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCd3ZWV4LWNvbnRhaW5lcicpXG4gICAgICB0aGlzLndlYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpXG4gICAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMud2ViKVxuICAgICAgdGhpcy53ZWIuY2xhc3NMaXN0LmFkZCgnd2VleC1lbGVtZW50JylcbiAgICAgIHRoaXMud2ViLnN0eWxlLndpZHRoID0gJzEwMCUnXG4gICAgICB0aGlzLndlYi5zdHlsZS5oZWlnaHQgPSAnMTAwJSdcbiAgICAgIHRoaXMud2ViLnN0eWxlLmJvcmRlciA9ICdub25lJ1xuICAgICAgcmV0dXJuIG5vZGVcbiAgICB9LFxuXG4gICAgYmluZEV2ZW50cyAoZXZ0cykge1xuICAgICAgQXRvbWljLnByb3RvdHlwZS5iaW5kRXZlbnRzLmNhbGwodGhpcywgZXZ0cylcbiAgICAgIGNvbnN0IHRoYXQgPSB0aGlzXG4gICAgICB0aGlzLndlYi5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhhdC5kaXNwYXRjaEV2ZW50KCdwYWdlZmluaXNoJywge1xuICAgICAgICAgIHVybDogdGhhdC53ZWIuc3JjXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVNc2cuYmluZChudWxsLCB0aGlzKSlcbiAgICB9LFxuXG4gICAgZ29CYWNrICgpIHtcbiAgICAgIHRoaXMud2ViLmNvbnRlbnRXaW5kb3cuaGlzdG9yeS5iYWNrKClcbiAgICB9LFxuXG4gICAgZ29Gb3J3YXJkICgpIHtcbiAgICAgIHRoaXMud2ViLmNvbnRlbnRXaW5kb3cuaGlzdG9yeS5mb3J3YXJkKClcbiAgICB9LFxuXG4gICAgcmVsb2FkICgpIHtcbiAgICAgIHRoaXMud2ViLmNvbnRlbnRXaW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgYXR0ciA9IHtcbiAgc3JjOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdGhpcy53ZWIuc3JjID0gdmFsXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3BhZ2VzdGFydCcsIHsgdXJsOiB2YWwgfSlcbiAgICB9LmJpbmQodGhpcyksIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdCAoV2VleCkge1xuICBjb25zdCBBdG9taWMgPSBXZWV4LkF0b21pY1xuICBjb25zdCBleHRlbmQgPSBXZWV4LnV0aWxzLmV4dGVuZFxuICBpc0FycmF5ID0gV2VleC51dGlscy5pc0FycmF5XG5cbiAgLy8gQSBjb21wb25lbnQgdG8gaW1wb3J0IHdlYiBwYWdlcywgd2hpY2ggd29ya3MgbGlrZVxuICAvLyBhIGlmcmFtZSBlbGVtZW50IG9yIGEgd2Vidmlldy5cbiAgLy8gYXR0cnM6XG4gIC8vICAgLSBzcmNcbiAgLy8gZXZlbnRzOlxuICAvLyAgIC0gcGFnZXN0YXJ0XG4gIC8vICAgLSBwYWdlZmluaXNoXG4gIC8vICAgLSBlcnJvclxuICBmdW5jdGlvbiBXZWIgKGRhdGEpIHtcbiAgICBBdG9taWMuY2FsbCh0aGlzLCBkYXRhKVxuICB9XG4gIFdlYi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUpXG4gIGV4dGVuZChXZWIucHJvdG90eXBlLCBnZXRQcm90byhXZWV4KSlcbiAgZXh0ZW5kKFdlYi5wcm90b3R5cGUsIHsgYXR0ciB9KVxuXG4gIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3dlYicsIFdlYilcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBpbml0IH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvY29tcG9uZW50cy93ZWIuanNcbiAqKi8iLCJpbXBvcnQgZXZlbnQgZnJvbSAnLi9ldmVudCdcbmltcG9ydCBwYWdlSW5mbyBmcm9tICcuL3BhZ2VJbmZvJ1xuaW1wb3J0IHN0cmVhbSBmcm9tICcuL3N0cmVhbSdcbmltcG9ydCBtb2RhbCBmcm9tICcuL21vZGFsJ1xuaW1wb3J0IGFuaW1hdGlvbiBmcm9tICcuL2FuaW1hdGlvbidcbmltcG9ydCB3ZWJ2aWV3IGZyb20gJy4vd2Vidmlldydcbi8vIGltcG9ydCB0aW1lciBmcm9tICcuL3RpbWVyJ1xuaW1wb3J0IG5hdmlnYXRvciBmcm9tICcuL25hdmlnYXRvcidcbmltcG9ydCBzdG9yYWdlIGZyb20gJy4vc3RvcmFnZSdcbmltcG9ydCBjbGlwYm9hcmQgZnJvbSAnLi9jbGlwYm9hcmQnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogZnVuY3Rpb24gKFdlZXgpIHtcbiAgICBXZWV4Lmluc3RhbGwoZXZlbnQpXG4gICAgV2VleC5pbnN0YWxsKHBhZ2VJbmZvKVxuICAgIFdlZXguaW5zdGFsbChzdHJlYW0pXG4gICAgV2VleC5pbnN0YWxsKG1vZGFsKVxuICAgIFdlZXguaW5zdGFsbChhbmltYXRpb24pXG4gICAgV2VleC5pbnN0YWxsKHdlYnZpZXcpXG4gICAgLy8gV2VleC5pbnN0YWxsKHRpbWVyKVxuICAgIFdlZXguaW5zdGFsbChuYXZpZ2F0b3IpXG4gICAgV2VleC5pbnN0YWxsKHN0b3JhZ2UpXG4gICAgV2VleC5pbnN0YWxsKGNsaXBib2FyZClcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZXZlbnQgPSB7XG4gIC8qKlxuICAgKiBvcGVuVXJsXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdXJsXG4gICAqL1xuICBvcGVuVVJMOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgbG9jYXRpb24uaHJlZiA9IHVybFxuICB9XG5cbn1cblxuY29uc3QgbWV0YSA9IHtcbiAgZXZlbnQ6IFt7XG4gICAgbmFtZTogJ29wZW5VUkwnLFxuICAgIGFyZ3M6IFsnc3RyaW5nJ11cbiAgfV1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBmdW5jdGlvbiAoV2VleCkge1xuICAgIFdlZXgucmVnaXN0ZXJBcGlNb2R1bGUoJ2V2ZW50JywgZXZlbnQsIG1ldGEpXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvYXBpL2V2ZW50LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHBhZ2VJbmZvID0ge1xuXG4gIHNldFRpdGxlOiBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICB0aXRsZSA9IHRpdGxlIHx8ICdXZWV4IEhUTUw1J1xuICAgIHRyeSB7XG4gICAgICB0aXRsZSA9IGRlY29kZVVSSUNvbXBvbmVudCh0aXRsZSlcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHt9XG4gICAgZG9jdW1lbnQudGl0bGUgPSB0aXRsZVxuICB9XG59XG5cbmNvbnN0IG1ldGEgPSB7XG4gIHBhZ2VJbmZvOiBbe1xuICAgIG5hbWU6ICdzZXRUaXRsZScsXG4gICAgYXJnczogWydzdHJpbmcnXVxuICB9XVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGZ1bmN0aW9uIChXZWV4KSB7XG4gICAgV2VleC5yZWdpc3RlckFwaU1vZHVsZSgncGFnZUluZm8nLCBwYWdlSW5mbywgbWV0YSlcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvcGFnZUluZm8uanNcbiAqKi8iLCIvKiBnbG9iYWwgbGliLCBYTUxIdHRwUmVxdWVzdCAqL1xuLyogZGVwczogaHR0cHVybCAqL1xuXG4ndXNlIHN0cmljdCdcblxubGV0IHV0aWxzXG5cbmltcG9ydCAnaHR0cHVybCdcblxubGV0IGpzb25wQ250ID0gMFxuY29uc3QgRVJST1JfU1RBVEUgPSAtMVxuXG5jb25zdCBUWVBFX0pTT04gPSAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04J1xuY29uc3QgVFlQRV9GT1JNID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcblxuY29uc3QgUkVHX0ZPUk0gPSAvXig/OlteJj1dKz1bXiY9XSspKD86JlteJj1dKz1bXiY9XSspKiQvXG5cbmZ1bmN0aW9uIF9qc29ucCAoY29uZmlnLCBjYWxsYmFjaywgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICBjb25zdCBjYk5hbWUgPSAnanNvbnBfJyArICgrK2pzb25wQ250KVxuICBsZXQgdXJsXG5cbiAgaWYgKCFjb25maWcudXJsKSB7XG4gICAgY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0gY29uZmlnLnVybCBzaG91bGQgYmUgc2V0IGluIF9qc29ucCBmb3IgXFwnZmV0Y2hcXCcgQVBJLicpXG4gIH1cblxuICBnbG9iYWxbY2JOYW1lXSA9IChmdW5jdGlvbiAoY2IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICBjYWxsYmFjayhyZXNwb25zZSlcbiAgICAgIGRlbGV0ZSBnbG9iYWxbY2JdXG4gICAgfVxuICB9KShjYk5hbWUpXG5cbiAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgdHJ5IHtcbiAgICB1cmwgPSBsaWIuaHR0cHVybChjb25maWcudXJsKVxuICB9XG4gIGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSBpbnZhbGlkIGNvbmZpZy51cmwgaW4gX2pzb25wIGZvciBcXCdmZXRjaFxcJyBBUEk6ICdcbiAgICAgICsgY29uZmlnLnVybClcbiAgfVxuICB1cmwucGFyYW1zLmNhbGxiYWNrID0gY2JOYW1lXG4gIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCdcbiAgc2NyaXB0LnNyYyA9IHVybC50b1N0cmluZygpXG4gIC8vIHNjcmlwdC5vbmVycm9yIGlzIG5vdCB3b3JraW5nIG9uIElFIG9yIHNhZmFyaS5cbiAgLy8gYnV0IHRoZXkgYXJlIG5vdCBjb25zaWRlcmVkIGhlcmUuXG4gIHNjcmlwdC5vbmVycm9yID0gKGZ1bmN0aW9uIChjYikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSB1bmV4cGVjdGVkIGVycm9yIGluIF9qc29ucCBmb3IgXFwnZmV0Y2hcXCcgQVBJJywgZXJyKVxuICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgZGVsZXRlIGdsb2JhbFtjYl1cbiAgICB9XG4gIH0pKGNiTmFtZSlcbiAgY29uc3QgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF1cbiAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBudWxsKVxufVxuXG5mdW5jdGlvbiBfeGhyIChjb25maWcsIGNhbGxiYWNrLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gIHhoci5yZXNwb25zZVR5cGUgPSBjb25maWcudHlwZVxuICB4aHIub3Blbihjb25maWcubWV0aG9kLCBjb25maWcudXJsLCB0cnVlKVxuXG4gIGNvbnN0IGhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fVxuICBmb3IgKGNvbnN0IGsgaW4gaGVhZGVycykge1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGssIGhlYWRlcnNba10pXG4gIH1cblxuICB4aHIub25sb2FkID0gZnVuY3Rpb24gKHJlcykge1xuICAgIGNhbGxiYWNrKHtcbiAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgIG9rOiB4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwLFxuICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICBkYXRhOiB4aHIucmVzcG9uc2UsXG4gICAgICBoZWFkZXJzOiB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgaGVhZGVyU3RyKSB7XG4gICAgICAgICAgY29uc3QgaGVhZGVyQXJyID0gaGVhZGVyU3RyLm1hdGNoKC8oLispOiAoLispLylcbiAgICAgICAgICBpZiAoaGVhZGVyQXJyKSB7XG4gICAgICAgICAgICBvYmpbaGVhZGVyQXJyWzFdXSA9IGhlYWRlckFyclsyXVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgIH0sIHt9KVxuICAgIH0pXG4gIH1cblxuICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgIHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHByb2dyZXNzQ2FsbGJhY2soe1xuICAgICAgICByZWFkeVN0YXRlOiB4aHIucmVhZHlTdGF0ZSxcbiAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICBsZW5ndGg6IGUubG9hZGVkLFxuICAgICAgICB0b3RhbDogZS50b3RhbCxcbiAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgnXFxuJylcbiAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChvYmosIGhlYWRlclN0cikge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyQXJyID0gaGVhZGVyU3RyLm1hdGNoKC8oLispOiAoLispLylcbiAgICAgICAgICAgIGlmIChoZWFkZXJBcnIpIHtcbiAgICAgICAgICAgICAgb2JqW2hlYWRlckFyclsxXV0gPSBoZWFkZXJBcnJbMl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgICB9LCB7fSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0gdW5leHBlY3RlZCBlcnJvciBpbiBfeGhyIGZvciBcXCdmZXRjaFxcJyBBUEknLCBlcnIpXG4gICAgY2FsbGJhY2soe1xuICAgICAgc3RhdHVzOiBFUlJPUl9TVEFURSxcbiAgICAgIG9rOiBmYWxzZSxcbiAgICAgIHN0YXR1c1RleHQ6ICcnLFxuICAgICAgZGF0YTogJycsXG4gICAgICBoZWFkZXJzOiB7fVxuICAgIH0pXG4gIH1cblxuICB4aHIuc2VuZChjb25maWcuYm9keSlcbn1cblxuY29uc3Qgc3RyZWFtID0ge1xuXG4gIC8qKlxuICAgKiBzZW5kSHR0cFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBOb3RlOiBUaGlzIEFQSSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHN0cmVhbS5mZXRjaCBpbnN0ZWFkLlxuICAgKiBzZW5kIGEgaHR0cCByZXF1ZXN0IHRocm91Z2ggWEhSLlxuICAgKiBAcGFyYW0gIHtvYmp9IHBhcmFtc1xuICAgKiAgLSBtZXRob2Q6ICdHRVQnIHwgJ1BPU1QnIHwgJ1BVVCcgfCAnREVMRVRFJyB8ICdIRUFEJyB8ICdQQVRDSCcsXG4gICAqICAtIHVybDogdXJsIHJlcXVlc3RlZFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNhbGxiYWNrSWRcbiAgICovXG4gIHNlbmRIdHRwOiBmdW5jdGlvbiAocGFyYW0sIGNhbGxiYWNrSWQpIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyYW0gPSBKU09OLnBhcnNlKHBhcmFtKVxuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFyYW0gIT09ICdvYmplY3QnIHx8ICFwYXJhbS51cmwpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFxuICAgICAgICAnW2g1LXJlbmRlcl0gaW52YWxpZCBjb25maWcgb3IgaW52YWxpZCBjb25maWcudXJsIGZvciBzZW5kSHR0cCBBUEknKVxuICAgIH1cblxuICAgIGNvbnN0IHNlbmRlciA9IHRoaXMuc2VuZGVyXG4gICAgY29uc3QgbWV0aG9kID0gcGFyYW0ubWV0aG9kIHx8ICdHRVQnXG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcbiAgICB4aHIub3BlbihtZXRob2QsIHBhcmFtLnVybCwgdHJ1ZSlcbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCB0aGlzLnJlc3BvbnNlVGV4dClcbiAgICB9XG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSB1bmV4cGVjdGVkIGVycm9yIGluIHNlbmRIdHRwIEFQSScsIGVycm9yKVxuICAgICAgLy8gc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhcbiAgICAgIC8vICAgY2FsbGJhY2tJZCxcbiAgICAgIC8vICAgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGVycm9yIGluIHNlbmRIdHRwIEFQSScpXG4gICAgICAvLyApXG4gICAgfVxuICAgIHhoci5zZW5kKClcbiAgfSxcblxuICAvKipcbiAgICogZmV0Y2hcbiAgICogdXNlIHN0cmVhbS5mZXRjaCB0byByZXF1ZXN0IGZvciBhIGpzb24gZmlsZSwgYSBwbGFpbiB0ZXh0IGZpbGUgb3JcbiAgICogYSBhcnJheWJ1ZmZlciBmb3IgYSBmaWxlIHN0cmVhbS4gKFlvdSBjYW4gdXNlIEJsb2IgYW5kIEZpbGVSZWFkZXJcbiAgICogQVBJIGltcGxlbWVudGVkIGJ5IG1vc3QgbW9kZXJuIGJyb3dzZXJzIHRvIHJlYWQgYSBhcnJheWJ1ZmZlci4pXG4gICAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBjb25maWcgb3B0aW9uc1xuICAgKiAgIC0gbWV0aG9kOiAnR0VUJyB8ICdQT1NUJyB8ICdQVVQnIHwgJ0RFTEVURScgfCAnSEVBRCcgfCAnUEFUQ0gnXG4gICAqICAgLSBoZWFkZXJzIHtvYmp9XG4gICAqICAgLSB1cmwge3N0cmluZ31cbiAgICogICAtIG1vZGUge3N0cmluZ30gJ2NvcnMnIHwgJ25vLWNvcnMnIHwgJ3NhbWUtb3JpZ2luJyB8ICduYXZpZ2F0ZSdcbiAgICogICAtIGJvZHlcbiAgICogICAtIHR5cGUge3N0cmluZ30gJ2pzb24nIHwgJ2pzb25wJyB8ICd0ZXh0J1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNhbGxiYWNrSWRcbiAgICogQHBhcmFtICB7c3RyaW5nfSBwcm9ncmVzc0NhbGxiYWNrSWRcbiAgICovXG4gIGZldGNoOiBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2tJZCwgcHJvZ3Jlc3NDYWxsYmFja0lkKSB7XG4gICAgY29uc3QgREVGQVVMVF9NRVRIT0QgPSAnR0VUJ1xuICAgIGNvbnN0IERFRkFVTFRfTU9ERSA9ICdjb3JzJ1xuICAgIGNvbnN0IERFRkFVTFRfVFlQRSA9ICd0ZXh0J1xuXG4gICAgY29uc3QgbWV0aG9kT3B0aW9ucyA9IFsnR0VUJywgJ1BPU1QnLCAnUFVUJywgJ0RFTEVURScsICdIRUFEJywgJ1BBVENIJ11cbiAgICBjb25zdCBtb2RlT3B0aW9ucyA9IFsnY29ycycsICduby1jb3JzJywgJ3NhbWUtb3JpZ2luJywgJ25hdmlnYXRlJ11cbiAgICBjb25zdCB0eXBlT3B0aW9ucyA9IFsndGV4dCcsICdqc29uJywgJ2pzb25wJywgJ2FycmF5YnVmZmVyJ11cblxuICAgIC8vIGNvbnN0IGZhbGxiYWNrID0gZmFsc2UgIC8vIGZhbGxiYWNrIGZyb20gJ2ZldGNoJyBBUEkgdG8gWEhSLlxuICAgIGNvbnN0IHNlbmRlciA9IHRoaXMuc2VuZGVyXG5cbiAgICBjb25zdCBjb25maWcgPSB1dGlscy5leHRlbmQoe30sIG9wdGlvbnMpXG5cbiAgICAvLyB2YWxpZGF0ZSBvcHRpb25zLm1ldGhvZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm1ldGhvZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbmZpZy5tZXRob2QgPSBERUZBVUxUX01FVEhPRFxuICAgICAgY29uc29sZS53YXJuKCdbaDUtcmVuZGVyXSBvcHRpb25zLm1ldGhvZCBmb3IgXFwnZmV0Y2hcXCcgQVBJIGhhcyBiZWVuIHNldCB0byAnXG4gICAgICAgICsgJ2RlZmF1bHQgdmFsdWUgXFwnJyArIGNvbmZpZy5tZXRob2QgKyAnXFwnJylcbiAgICB9XG4gICAgZWxzZSBpZiAobWV0aG9kT3B0aW9ucy5pbmRleE9mKChjb25maWcubWV0aG9kICsgJycpXG4gICAgICAgIC50b1VwcGVyQ2FzZSgpKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSBvcHRpb25zLm1ldGhvZCBcXCcnXG4gICAgICAgICsgY29uZmlnLm1ldGhvZFxuICAgICAgICArICdcXCcgZm9yIFxcJ2ZldGNoXFwnIEFQSSBzaG91bGQgYmUgb25lIG9mICdcbiAgICAgICAgKyBtZXRob2RPcHRpb25zICsgJy4nKVxuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnMudXJsXG4gICAgaWYgKCFjb25maWcudXJsKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0gb3B0aW9ucy51cmwgc2hvdWxkIGJlIHNldCBmb3IgXFwnZmV0Y2hcXCcgQVBJLicpXG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgb3B0aW9ucy5tb2RlXG4gICAgaWYgKHR5cGVvZiBjb25maWcubW9kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbmZpZy5tb2RlID0gREVGQVVMVF9NT0RFXG4gICAgfVxuICAgIGVsc2UgaWYgKG1vZGVPcHRpb25zLmluZGV4T2YoKGNvbmZpZy5tb2RlICsgJycpLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ1toNS1yZW5kZXJdIG9wdGlvbnMubW9kZSBcXCcnXG4gICAgICAgICsgY29uZmlnLm1vZGVcbiAgICAgICAgKyAnXFwnIGZvciBcXCdmZXRjaFxcJyBBUEkgc2hvdWxkIGJlIG9uZSBvZiAnXG4gICAgICAgICsgbW9kZU9wdGlvbnMgKyAnLicpXG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgb3B0aW9ucy50eXBlXG4gICAgaWYgKHR5cGVvZiBjb25maWcudHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbmZpZy50eXBlID0gREVGQVVMVF9UWVBFXG4gICAgICBjb25zb2xlLndhcm4oJ1toNS1yZW5kZXJdIG9wdGlvbnMudHlwZSBmb3IgXFwnZmV0Y2hcXCcgQVBJIGhhcyBiZWVuIHNldCB0byAnXG4gICAgICAgICsgJ2RlZmF1bHQgdmFsdWUgXFwnJyArIGNvbmZpZy50eXBlICsgJ1xcJy4nKVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlT3B0aW9ucy5pbmRleE9mKChjb25maWcudHlwZSArICcnKS50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdbaDUtcmVuZGVyXSBvcHRpb25zLnR5cGUgXFwnJ1xuICAgICAgICAgICsgY29uZmlnLnR5cGVcbiAgICAgICAgICArICdcXCcgZm9yIFxcJ2ZldGNoXFwnIEFQSSBzaG91bGQgYmUgb25lIG9mICdcbiAgICAgICAgICArIHR5cGVPcHRpb25zICsgJy4nKVxuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnMuaGVhZGVyc1xuICAgIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge31cbiAgICBpZiAoIXV0aWxzLmlzUGxhaW5PYmplY3QoY29uZmlnLmhlYWRlcnMpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcignW2g1LXJlbmRlcl0gb3B0aW9ucy5oZWFkZXJzIHNob3VsZCBiZSBhIHBsYWluIG9iamVjdCcpXG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgb3B0aW9ucy5ib2R5XG4gICAgY29uc3QgYm9keSA9IGNvbmZpZy5ib2R5XG4gICAgaWYgKCFjb25maWcuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gJiYgYm9keSkge1xuICAgICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QoYm9keSkpIHtcbiAgICAgICAgLy8gaXMgYSBqc29uIGRhdGFcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25maWcuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gICAgICAgICAgY29uZmlnLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gVFlQRV9KU09OXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh1dGlscy5nZXRUeXBlKGJvZHkpID09PSAnc3RyaW5nJyAmJiBib2R5Lm1hdGNoKFJFR19GT1JNKSkge1xuICAgICAgICAvLyBpcyBmb3JtLWRhdGFcbiAgICAgICAgY29uZmlnLmJvZHkgPSBlbmNvZGVVUkkoYm9keSlcbiAgICAgICAgY29uZmlnLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gVFlQRV9GT1JNXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgb3B0aW9ucy50aW1lb3V0XG4gICAgY29uZmlnLnRpbWVvdXQgPSBwYXJzZUludChjb25maWcudGltZW91dCwgMTApIHx8IDI1MDBcblxuICAgIGNvbnN0IF9jYWxsQXJncyA9IFtjb25maWcsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwgcmVzKVxuICAgIH1dXG4gICAgaWYgKHByb2dyZXNzQ2FsbGJhY2tJZCkge1xuICAgICAgX2NhbGxBcmdzLnB1c2goZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAvLyBTZXQgJ2tlZXBBbGl2ZScgdG8gdHJ1ZSBmb3Igc2VuZGluZyBjb250aW51b3VzIGNhbGxiYWNrc1xuICAgICAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKHByb2dyZXNzQ2FsbGJhY2tJZCwgcmVzLCB0cnVlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLnR5cGUgPT09ICdqc29ucCcpIHtcbiAgICAgIF9qc29ucC5hcHBseSh0aGlzLCBfY2FsbEFyZ3MpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgX3hoci5hcHBseSh0aGlzLCBfY2FsbEFyZ3MpXG4gICAgfVxuICB9XG5cbn1cblxuY29uc3QgbWV0YSA9IHtcbiAgc3RyZWFtOiBbe1xuICAgIG5hbWU6ICdzZW5kSHR0cCcsXG4gICAgYXJnczogWydvYmplY3QnLCAnZnVuY3Rpb24nXVxuICB9LCB7XG4gICAgbmFtZTogJ2ZldGNoJyxcbiAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbicsICdmdW5jdGlvbiddXG4gIH1dXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogZnVuY3Rpb24gKFdlZXgpIHtcbiAgICB1dGlscyA9IFdlZXgudXRpbHNcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCdzdHJlYW0nLCBzdHJlYW0sIG1ldGEpXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvYXBpL3N0cmVhbS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgbW9kYWwgZnJvbSAnbW9kYWxzJ1xuXG5jb25zdCBtc2cgPSB7XG5cbiAgLy8gZHVyYXRpb246IGRlZmF1bHQgaXMgMC44IHNlY29uZHMuXG4gIHRvYXN0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgbW9kYWwudG9hc3QoY29uZmlnLm1lc3NhZ2UsIGNvbmZpZy5kdXJhdGlvbilcbiAgfSxcblxuICAvLyBjb25maWc6XG4gIC8vICAtIG1lc3NhZ2U6IHN0cmluZ1xuICAvLyAgLSBva1RpdGxlOiB0aXRsZSBvZiBvayBidXR0b25cbiAgLy8gIC0gY2FsbGJhY2tcbiAgYWxlcnQ6IGZ1bmN0aW9uIChjb25maWcsIGNhbGxiYWNrSWQpIHtcbiAgICBjb25zdCBzZW5kZXIgPSB0aGlzLnNlbmRlclxuICAgIGNvbmZpZy5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZClcbiAgICB9XG4gICAgbW9kYWwuYWxlcnQoY29uZmlnKVxuICB9LFxuXG4gIC8vIGNvbmZpZzpcbiAgLy8gIC0gbWVzc2FnZTogc3RyaW5nXG4gIC8vICAtIG9rVGl0bGU6IHRpdGxlIG9mIG9rIGJ1dHRvblxuICAvLyAgLSBjYW5jZWxUaXRsZTogdGl0bGUgb2YgY2FuY2VsIGJ1dHRvblxuICAvLyAgLSBjYWxsYmFja1xuICBjb25maXJtOiBmdW5jdGlvbiAoY29uZmlnLCBjYWxsYmFja0lkKSB7XG4gICAgY29uc3Qgc2VuZGVyID0gdGhpcy5zZW5kZXJcbiAgICBjb25maWcuY2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQsIHZhbClcbiAgICB9XG4gICAgbW9kYWwuY29uZmlybShjb25maWcpXG4gIH0sXG5cbiAgLy8gY29uZmlnOlxuICAvLyAgLSBtZXNzYWdlOiBzdHJpbmdcbiAgLy8gIC0gb2tUaXRsZTogdGl0bGUgb2Ygb2sgYnV0dG9uXG4gIC8vICAtIGNhbmNlbFRpdGxlOiB0aXRsZSBvZiBjYW5jZWwgYnV0dG9uXG4gIC8vICAtIGNhbGxiYWNrXG4gIHByb21wdDogZnVuY3Rpb24gKGNvbmZpZywgY2FsbGJhY2tJZCkge1xuICAgIGNvbnN0IHNlbmRlciA9IHRoaXMuc2VuZGVyXG4gICAgY29uZmlnLmNhbGxiYWNrID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCB2YWwpXG4gICAgfVxuICAgIG1vZGFsLnByb21wdChjb25maWcpXG4gIH1cbn1cblxuY29uc3QgbWV0YSA9IHtcbiAgbW9kYWw6IFt7XG4gICAgbmFtZTogJ3RvYXN0JyxcbiAgICBhcmdzOiBbJ29iamVjdCddXG4gIH0sIHtcbiAgICBuYW1lOiAnYWxlcnQnLFxuICAgIGFyZ3M6IFsnb2JqZWN0JywgJ2Z1bmN0aW9uJ11cbiAgfSwge1xuICAgIG5hbWU6ICdjb25maXJtJyxcbiAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbiddXG4gIH0sIHtcbiAgICBuYW1lOiAncHJvbXB0JyxcbiAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbiddXG4gIH1dXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogZnVuY3Rpb24gKFdlZXgpIHtcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCdtb2RhbCcsIG1zZywgbWV0YSlcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9odG1sNS9icm93c2VyL2V4dGVuZC9hcGkvbW9kYWwuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIEFsZXJ0ID0gcmVxdWlyZSgnLi9hbGVydCcpXG52YXIgQ29uZmlybSA9IHJlcXVpcmUoJy4vY29uZmlybScpXG52YXIgUHJvbXB0ID0gcmVxdWlyZSgnLi9wcm9tcHQnKVxudmFyIHRvYXN0ID0gcmVxdWlyZSgnLi90b2FzdCcpXG5cbnZhciBtb2RhbCA9IHtcblxuICB0b2FzdDogZnVuY3Rpb24gKG1zZywgZHVyYXRpb24pIHtcbiAgICB0b2FzdC5wdXNoKG1zZywgZHVyYXRpb24pXG4gIH0sXG5cbiAgYWxlcnQ6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICBuZXcgQWxlcnQoY29uZmlnKS5zaG93KClcbiAgfSxcblxuICBwcm9tcHQ6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICBuZXcgUHJvbXB0KGNvbmZpZykuc2hvdygpXG4gIH0sXG5cbiAgY29uZmlybTogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIG5ldyBDb25maXJtKGNvbmZpZykuc2hvdygpXG4gIH1cblxufVxuXG4hd2luZG93LmxpYiAmJiAod2luZG93LmxpYiA9IHt9KVxud2luZG93LmxpYi5tb2RhbCA9IG1vZGFsXG5cbm1vZHVsZS5leHBvcnRzID0gbW9kYWxcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9tb2RhbHMvc3JjL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIE1vZGFsID0gcmVxdWlyZSgnLi9tb2RhbCcpXG5yZXF1aXJlKCcuLi9zdHlsZXMvYWxlcnQuY3NzJylcblxudmFyIENPTlRFTlRfQ0xBU1MgPSAnY29udGVudCdcbnZhciBNU0dfQ0xBU1MgPSAnY29udGVudC1tc2cnXG52YXIgQlVUVE9OX0dST1VQX0NMQVNTID0gJ2J0bi1ncm91cCdcbnZhciBCVVRUT05fQ0xBU1MgPSAnYnRuJ1xuXG5mdW5jdGlvbiBBbGVydChjb25maWcpIHtcbiAgdGhpcy5tc2cgPSBjb25maWcubWVzc2FnZSB8fCAnJ1xuICB0aGlzLmNhbGxiYWNrID0gY29uZmlnLmNhbGxiYWNrXG4gIHRoaXMub2tUaXRsZSA9IGNvbmZpZy5va1RpdGxlIHx8ICdPSydcbiAgTW9kYWwuY2FsbCh0aGlzKVxuICB0aGlzLm5vZGUuY2xhc3NMaXN0LmFkZCgnYW1mZS1hbGVydCcpXG59XG5cbkFsZXJ0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9kYWwucHJvdG90eXBlKVxuXG5BbGVydC5wcm90b3R5cGUuY3JlYXRlTm9kZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgY29udGVudC5jbGFzc0xpc3QuYWRkKENPTlRFTlRfQ0xBU1MpXG4gIHRoaXMubm9kZS5hcHBlbmRDaGlsZChjb250ZW50KVxuXG4gIHZhciBtc2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBtc2cuY2xhc3NMaXN0LmFkZChNU0dfQ0xBU1MpXG4gIG1zZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLm1zZykpXG4gIGNvbnRlbnQuYXBwZW5kQ2hpbGQobXNnKVxuXG4gIHZhciBidXR0b25Hcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGJ1dHRvbkdyb3VwLmNsYXNzTGlzdC5hZGQoQlVUVE9OX0dST1VQX0NMQVNTKVxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoYnV0dG9uR3JvdXApXG4gIHZhciBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidXR0b24uY2xhc3NMaXN0LmFkZChCVVRUT05fQ0xBU1MsICdhbGVydC1vaycpXG4gIGJ1dHRvbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLm9rVGl0bGUpKVxuICBidXR0b25Hcm91cC5hcHBlbmRDaGlsZChidXR0b24pXG59XG5cbkFsZXJ0LnByb3RvdHlwZS5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICBNb2RhbC5wcm90b3R5cGUuYmluZEV2ZW50cy5jYWxsKHRoaXMpXG4gIHZhciBidXR0b24gPSB0aGlzLm5vZGUucXVlcnlTZWxlY3RvcignLicgKyBCVVRUT05fQ0xBU1MpXG4gIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlc3Ryb3koKVxuICAgIHRoaXMuY2FsbGJhY2sgJiYgdGhpcy5jYWxsYmFjaygpXG4gIH0uYmluZCh0aGlzKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBbGVydFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbW9kYWxzL3NyYy9hbGVydC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnJlcXVpcmUoJy4uL3N0eWxlcy9tb2RhbC5jc3MnKVxuXG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIGluc3RhbmNlIG9mIG1vZGFsLlxudmFyIE1PREFMX1dSQVBfQ0xBU1MgPSAnYW1mZS1tb2RhbC13cmFwJ1xudmFyIE1PREFMX05PREVfQ0xBU1MgPSAnYW1mZS1tb2RhbC1ub2RlJ1xuXG5mdW5jdGlvbiBNb2RhbCgpIHtcbiAgdGhpcy53cmFwID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihNT0RBTF9XUkFQX0NMQVNTKVxuICB0aGlzLm5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKE1PREFMX05PREVfQ0xBU1MpXG4gIGlmICghdGhpcy53cmFwKSB7XG4gICAgdGhpcy5jcmVhdGVXcmFwKClcbiAgfVxuICBpZiAoIXRoaXMubm9kZSkge1xuICAgIHRoaXMuY3JlYXRlTm9kZSgpXG4gIH1cbiAgdGhpcy5jbGVhck5vZGUoKVxuICB0aGlzLmNyZWF0ZU5vZGVDb250ZW50KClcbiAgdGhpcy5iaW5kRXZlbnRzKClcbn1cblxuTW9kYWwucHJvdG90eXBlID0ge1xuXG4gIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLndyYXAuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZScpXG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy53cmFwKVxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5ub2RlKVxuICAgIHRoaXMud3JhcCA9IG51bGxcbiAgICB0aGlzLm5vZGUgPSBudWxsXG4gIH0sXG5cbiAgY3JlYXRlV3JhcDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMud3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgdGhpcy53cmFwLmNsYXNzTmFtZSA9IE1PREFMX1dSQVBfQ0xBU1NcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMud3JhcClcbiAgfSxcblxuICBjcmVhdGVOb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LmFkZChNT0RBTF9OT0RFX0NMQVNTLCAnaGlkZScpXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpXG4gIH0sXG5cbiAgY2xlYXJOb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ub2RlLmlubmVySFRNTCA9ICcnXG4gIH0sXG5cbiAgY3JlYXRlTm9kZUNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGRvIG5vdGhpbmcuXG4gICAgLy8gY2hpbGQgY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyBtZXRob2QuXG4gIH0sXG5cbiAgYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMud3JhcC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kYWxcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L21vZGFscy9zcmMvbW9kYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9tb2RhbC5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL21vZGFsLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbW9kYWwuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9tb2RhbHMvc3R5bGVzL21vZGFsLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE5N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5hbWZlLW1vZGFsLXdyYXAge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDA7XFxuICBvcGFjaXR5OiAwLjU7XFxufVxcblxcbi5hbWZlLW1vZGFsLW5vZGUge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTtcXG4gIHRvcDogNTAlO1xcbiAgbGVmdDogNTAlO1xcbiAgd2lkdGg6IDYuNjY2NjY3cmVtO1xcbiAgbWluLWhlaWdodDogMi42NjY2NjdyZW07XFxuICBib3JkZXItcmFkaXVzOiAwLjA2NjY2N3JlbTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxufVxcbi5hbWZlLW1vZGFsLW5vZGUuaGlkZSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4uYW1mZS1tb2RhbC1ub2RlIC5jb250ZW50IHtcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIC13ZWJraXQtYm94LW9yaWVudDogdmVydGljYWw7XFxuICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcXG4gIC13ZWJraXQtYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAtd2Via2l0LWJveC1wYWNrOiBjZW50ZXI7XFxuICAtd2Via2l0LWp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1pbi1oZWlnaHQ6IDEuODY2NjY3cmVtO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGZvbnQtc2l6ZTogMC4zMnJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAwLjQyNjY2N3JlbTtcXG4gIHBhZGRpbmc6IDAuMjEzMzMzcmVtO1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNkZGQ7XFxufVxcbi5hbWZlLW1vZGFsLW5vZGUgLmJ0bi1ncm91cCB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMC44cmVtO1xcbiAgZm9udC1zaXplOiAwLjM3MzMzM3JlbTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICBib3JkZXI6IG5vbmU7XFxufVxcbi5hbWZlLW1vZGFsLW5vZGUgLmJ0bi1ncm91cCAuYnRuIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBoZWlnaHQ6IDAuOHJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAwLjhyZW07XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgYm9yZGVyOiBub25lO1xcbiAgYmFja2dyb3VuZDogbm9uZTtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL34vbW9kYWxzL3N0eWxlcy9tb2RhbC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9hbGVydC5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL2FsZXJ0LmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYWxlcnQuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9tb2RhbHMvc3R5bGVzL2FsZXJ0LmNzc1xuICoqIG1vZHVsZSBpZCA9IDE5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5hbWZlLWFsZXJ0IC5hbWZlLWFsZXJ0LW9rIHtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi9tb2RhbHMvc3R5bGVzL2FsZXJ0LmNzc1xuICoqIG1vZHVsZSBpZCA9IDIwMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBNb2RhbCA9IHJlcXVpcmUoJy4vbW9kYWwnKVxucmVxdWlyZSgnLi4vc3R5bGVzL2NvbmZpcm0uY3NzJylcblxudmFyIENPTlRFTlRfQ0xBU1MgPSAnY29udGVudCdcbnZhciBNU0dfQ0xBU1MgPSAnY29udGVudC1tc2cnXG52YXIgQlVUVE9OX0dST1VQX0NMQVNTID0gJ2J0bi1ncm91cCdcbnZhciBCVVRUT05fQ0xBU1MgPSAnYnRuJ1xuXG5mdW5jdGlvbiBDb25maXJtKGNvbmZpZykge1xuICB0aGlzLm1zZyA9IGNvbmZpZy5tZXNzYWdlIHx8ICcnXG4gIHRoaXMuY2FsbGJhY2sgPSBjb25maWcuY2FsbGJhY2tcbiAgdGhpcy5va1RpdGxlID0gY29uZmlnLm9rVGl0bGUgfHwgJ09LJ1xuICB0aGlzLmNhbmNlbFRpdGxlID0gY29uZmlnLmNhbmNlbFRpdGxlIHx8ICdDYW5jZWwnXG4gIE1vZGFsLmNhbGwodGhpcylcbiAgdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FtZmUtY29uZmlybScpXG59XG5cbkNvbmZpcm0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb2RhbC5wcm90b3R5cGUpXG5cbkNvbmZpcm0ucHJvdG90eXBlLmNyZWF0ZU5vZGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChDT05URU5UX0NMQVNTKVxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoY29udGVudClcblxuICB2YXIgbXNnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgbXNnLmNsYXNzTGlzdC5hZGQoTVNHX0NMQVNTKVxuICBtc2cuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5tc2cpKVxuICBjb250ZW50LmFwcGVuZENoaWxkKG1zZylcblxuICB2YXIgYnV0dG9uR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidXR0b25Hcm91cC5jbGFzc0xpc3QuYWRkKEJVVFRPTl9HUk9VUF9DTEFTUylcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGJ1dHRvbkdyb3VwKVxuICB2YXIgYnRuT2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidG5Pay5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLm9rVGl0bGUpKVxuICBidG5Pay5jbGFzc0xpc3QuYWRkKCdidG4tb2snLCBCVVRUT05fQ0xBU1MpXG4gIHZhciBidG5DYW5jZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidG5DYW5jZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5jYW5jZWxUaXRsZSkpXG4gIGJ0bkNhbmNlbC5jbGFzc0xpc3QuYWRkKCdidG4tY2FuY2VsJywgQlVUVE9OX0NMQVNTKVxuICBidXR0b25Hcm91cC5hcHBlbmRDaGlsZChidG5PaylcbiAgYnV0dG9uR3JvdXAuYXBwZW5kQ2hpbGQoYnRuQ2FuY2VsKVxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoYnV0dG9uR3JvdXApXG59XG5cbkNvbmZpcm0ucHJvdG90eXBlLmJpbmRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIE1vZGFsLnByb3RvdHlwZS5iaW5kRXZlbnRzLmNhbGwodGhpcylcbiAgdmFyIGJ0bk9rID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQlVUVE9OX0NMQVNTICsgJy5idG4tb2snKVxuICB2YXIgYnRuQ2FuY2VsID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQlVUVE9OX0NMQVNTICsgJy5idG4tY2FuY2VsJylcbiAgYnRuT2suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZXN0cm95KClcbiAgICB0aGlzLmNhbGxiYWNrICYmIHRoaXMuY2FsbGJhY2sodGhpcy5va1RpdGxlKVxuICB9LmJpbmQodGhpcykpXG4gIGJ0bkNhbmNlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlc3Ryb3koKVxuICAgIHRoaXMuY2FsbGJhY2sgJiYgdGhpcy5jYWxsYmFjayh0aGlzLmNhbmNlbFRpdGxlKVxuICB9LmJpbmQodGhpcykpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29uZmlybVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbW9kYWxzL3NyYy9jb25maXJtLmpzXG4gKiogbW9kdWxlIGlkID0gMjAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vY29uZmlybS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL2NvbmZpcm0uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9jb25maXJtLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbW9kYWxzL3N0eWxlcy9jb25maXJtLmNzc1xuICoqIG1vZHVsZSBpZCA9IDIwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5hbWZlLWNvbmZpcm0gLmJ0bi1ncm91cCAuYnRuIHtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgd2lkdGg6IDUwJTtcXG59XFxuLmFtZmUtY29uZmlybSAuYnRuLWdyb3VwIC5idG4uYnRuLW9rIHtcXG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNkZGQ7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9+L21vZGFscy9zdHlsZXMvY29uZmlybS5jc3NcbiAqKiBtb2R1bGUgaWQgPSAyMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgTW9kYWwgPSByZXF1aXJlKCcuL21vZGFsJylcbnJlcXVpcmUoJy4uL3N0eWxlcy9wcm9tcHQuY3NzJylcblxudmFyIENPTlRFTlRfQ0xBU1MgPSAnY29udGVudCdcbnZhciBNU0dfQ0xBU1MgPSAnY29udGVudC1tc2cnXG52YXIgQlVUVE9OX0dST1VQX0NMQVNTID0gJ2J0bi1ncm91cCdcbnZhciBCVVRUT05fQ0xBU1MgPSAnYnRuJ1xudmFyIElOUFVUX1dSQVBfQ0xBU1MgPSAnaW5wdXQtd3JhcCdcbnZhciBJTlBVVF9DTEFTUyA9ICdpbnB1dCdcblxuZnVuY3Rpb24gUHJvbXB0KGNvbmZpZykge1xuICB0aGlzLm1zZyA9IGNvbmZpZy5tZXNzYWdlIHx8ICcnXG4gIHRoaXMuZGVmYXVsdE1zZyA9IGNvbmZpZy5kZWZhdWx0IHx8ICcnXG4gIHRoaXMuY2FsbGJhY2sgPSBjb25maWcuY2FsbGJhY2tcbiAgdGhpcy5va1RpdGxlID0gY29uZmlnLm9rVGl0bGUgfHwgJ09LJ1xuICB0aGlzLmNhbmNlbFRpdGxlID0gY29uZmlnLmNhbmNlbFRpdGxlIHx8ICdDYW5jZWwnXG4gIE1vZGFsLmNhbGwodGhpcylcbiAgdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FtZmUtcHJvbXB0Jylcbn1cblxuUHJvbXB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9kYWwucHJvdG90eXBlKVxuXG5Qcm9tcHQucHJvdG90eXBlLmNyZWF0ZU5vZGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgY29udGVudC5jbGFzc0xpc3QuYWRkKENPTlRFTlRfQ0xBU1MpXG4gIHRoaXMubm9kZS5hcHBlbmRDaGlsZChjb250ZW50KVxuXG4gIHZhciBtc2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBtc2cuY2xhc3NMaXN0LmFkZChNU0dfQ0xBU1MpXG4gIG1zZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLm1zZykpXG4gIGNvbnRlbnQuYXBwZW5kQ2hpbGQobXNnKVxuXG4gIHZhciBpbnB1dFdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBpbnB1dFdyYXAuY2xhc3NMaXN0LmFkZChJTlBVVF9XUkFQX0NMQVNTKVxuICBjb250ZW50LmFwcGVuZENoaWxkKGlucHV0V3JhcClcbiAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICBpbnB1dC5jbGFzc0xpc3QuYWRkKElOUFVUX0NMQVNTKVxuICBpbnB1dC50eXBlID0gJ3RleHQnXG4gIGlucHV0LmF1dG9mb2N1cyA9IHRydWVcbiAgaW5wdXQucGxhY2Vob2xkZXIgPSB0aGlzLmRlZmF1bHRNc2dcbiAgaW5wdXRXcmFwLmFwcGVuZENoaWxkKGlucHV0KVxuXG4gIHZhciBidXR0b25Hcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGJ1dHRvbkdyb3VwLmNsYXNzTGlzdC5hZGQoQlVUVE9OX0dST1VQX0NMQVNTKVxuICB2YXIgYnRuT2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidG5Pay5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLm9rVGl0bGUpKVxuICBidG5Pay5jbGFzc0xpc3QuYWRkKCdidG4tb2snLCBCVVRUT05fQ0xBU1MpXG4gIHZhciBidG5DYW5jZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidG5DYW5jZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5jYW5jZWxUaXRsZSkpXG4gIGJ0bkNhbmNlbC5jbGFzc0xpc3QuYWRkKCdidG4tY2FuY2VsJywgQlVUVE9OX0NMQVNTKVxuICBidXR0b25Hcm91cC5hcHBlbmRDaGlsZChidG5PaylcbiAgYnV0dG9uR3JvdXAuYXBwZW5kQ2hpbGQoYnRuQ2FuY2VsKVxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoYnV0dG9uR3JvdXApXG59XG5cblByb21wdC5wcm90b3R5cGUuYmluZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgTW9kYWwucHJvdG90eXBlLmJpbmRFdmVudHMuY2FsbCh0aGlzKVxuICB2YXIgYnRuT2sgPSB0aGlzLm5vZGUucXVlcnlTZWxlY3RvcignLicgKyBCVVRUT05fQ0xBU1MgKyAnLmJ0bi1vaycpXG4gIHZhciBidG5DYW5jZWwgPSB0aGlzLm5vZGUucXVlcnlTZWxlY3RvcignLicgKyBCVVRUT05fQ0xBU1MgKyAnLmJ0bi1jYW5jZWwnKVxuICB2YXIgdGhhdCA9IHRoaXNcbiAgYnRuT2suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykudmFsdWVcbiAgICB0aGlzLmRlc3Ryb3koKVxuICAgIHRoaXMuY2FsbGJhY2sgJiYgdGhpcy5jYWxsYmFjayh7XG4gICAgICByZXN1bHQ6IHRoYXQub2tUaXRsZSxcbiAgICAgIGRhdGE6IHZhbFxuICAgIH0pXG4gIH0uYmluZCh0aGlzKSlcbiAgYnRuQ2FuY2VsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLnZhbHVlXG4gICAgdGhpcy5kZXN0cm95KClcbiAgICB0aGlzLmNhbGxiYWNrICYmIHRoaXMuY2FsbGJhY2soe1xuICAgICAgcmVzdWx0OiB0aGF0LmNhbmNlbFRpdGxlLFxuICAgICAgZGF0YTogdmFsXG4gICAgfSlcbiAgfS5iaW5kKHRoaXMpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21wdFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbW9kYWxzL3NyYy9wcm9tcHQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9wcm9tcHQuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9wcm9tcHQuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9wcm9tcHQuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9tb2RhbHMvc3R5bGVzL3Byb21wdC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAyMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuYW1mZS1wcm9tcHQgLmlucHV0LXdyYXAge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWFyZ2luLXRvcDogMC4xMzMzMzNyZW07XFxuICAvLyBwYWRkaW5nOiAwLjI0cmVtIDAuMjEzMzMzcmVtIDAuMjEzMzMzcmVtO1xcbiAgaGVpZ2h0OiAwLjk2cmVtO1xcbn1cXG4uYW1mZS1wcm9tcHQgLmlucHV0LXdyYXAgLmlucHV0IHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMC41NnJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAwLjU2cmVtO1xcbiAgZm9udC1zaXplOiAwLjMycmVtO1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzk5OTtcXG59XFxuLmFtZmUtcHJvbXB0IC5idG4tZ3JvdXAgLmJ0biB7XFxuICBmbG9hdDogbGVmdDtcXG4gIHdpZHRoOiA1MCU7XFxufVxcbi5hbWZlLXByb21wdCAuYnRuLWdyb3VwIC5idG4uYnRuLW9rIHtcXG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNkZGQ7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9+L21vZGFscy9zdHlsZXMvcHJvbXB0LmNzc1xuICoqIG1vZHVsZSBpZCA9IDIwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnJlcXVpcmUoJy4uL3N0eWxlcy90b2FzdC5jc3MnKVxuXG52YXIgcXVldWUgPSBbXVxudmFyIHRpbWVyXG52YXIgaXNQcm9jZXNzaW5nID0gZmFsc2VcbnZhciB0b2FzdFdpblxudmFyIFRPQVNUX1dJTl9DTEFTU19OQU1FID0gJ2FtZmUtdG9hc3QnXG5cbnZhciBERUZBVUxUX0RVUkFUSU9OID0gMC44XG5cbmZ1bmN0aW9uIHNob3dUb2FzdFdpbmRvdyhtc2csIGNhbGxiYWNrKSB7XG4gIHZhciBoYW5kbGVUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHRvYXN0V2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVUcmFuc2l0aW9uRW5kKVxuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgfVxuICBpZiAoIXRvYXN0V2luKSB7XG4gICAgdG9hc3RXaW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRvYXN0V2luLmNsYXNzTGlzdC5hZGQoVE9BU1RfV0lOX0NMQVNTX05BTUUsICdoaWRlJylcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRvYXN0V2luKVxuICB9XG4gIHRvYXN0V2luLmlubmVySFRNTCA9IG1zZ1xuICB0b2FzdFdpbi5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlVHJhbnNpdGlvbkVuZClcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdG9hc3RXaW4uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZScpXG4gIH0sIDApXG59XG5cbmZ1bmN0aW9uIGhpZGVUb2FzdFdpbmRvdyhjYWxsYmFjaykge1xuICB2YXIgaGFuZGxlVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2FzdFdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlVHJhbnNpdGlvbkVuZClcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gIH1cbiAgaWYgKCF0b2FzdFdpbikge1xuICAgIHJldHVyblxuICB9XG4gIHRvYXN0V2luLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVUcmFuc2l0aW9uRW5kKVxuICB0b2FzdFdpbi5jbGFzc0xpc3QuYWRkKCdoaWRlJylcbn1cblxudmFyIHRvYXN0ID0ge1xuXG4gIHB1c2g6IGZ1bmN0aW9uIChtc2csIGR1cmF0aW9uKSB7XG4gICAgcXVldWUucHVzaCh7XG4gICAgICBtc2c6IG1zZyxcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiB8fCBERUZBVUxUX0RVUkFUSU9OXG4gICAgfSlcbiAgICB0aGlzLnNob3coKVxuICB9LFxuXG4gIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcblxuICAgIC8vIEFsbCBtZXNzYWdlcyBoYWQgYmVlbiB0b2FzdGVkIGFscmVhZHksIHNvIHJlbW92ZSB0aGUgdG9hc3Qgd2luZG93LFxuICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICB0b2FzdFdpbiAmJiB0b2FzdFdpbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRvYXN0V2luKVxuICAgICAgdG9hc3RXaW4gPSBudWxsXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB0aGUgcHJldmlvdXMgdG9hc3QgaXMgbm90IGVuZGVkIHlldC5cbiAgICBpZiAoaXNQcm9jZXNzaW5nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaXNQcm9jZXNzaW5nID0gdHJ1ZVxuXG4gICAgdmFyIHRvYXN0SW5mbyA9IHF1ZXVlLnNoaWZ0KClcbiAgICBzaG93VG9hc3RXaW5kb3codG9hc3RJbmZvLm1zZywgZnVuY3Rpb24gKCkge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGltZXIgPSBudWxsXG4gICAgICAgIGhpZGVUb2FzdFdpbmRvdyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaXNQcm9jZXNzaW5nID0gZmFsc2VcbiAgICAgICAgICB0aGF0LnNob3coKVxuICAgICAgICB9KVxuICAgICAgfSwgdG9hc3RJbmZvLmR1cmF0aW9uICogMTAwMClcbiAgICB9KVxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHB1c2g6IHRvYXN0LnB1c2guYmluZCh0b2FzdClcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L21vZGFscy9zcmMvdG9hc3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi90b2FzdC5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3RvYXN0LmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vdG9hc3QuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9tb2RhbHMvc3R5bGVzL3RvYXN0LmNzc1xuICoqIG1vZHVsZSBpZCA9IDIwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5hbWZlLXRvYXN0IHtcXG4gIGZvbnQtc2l6ZTogMC4zMnJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAwLjQyNjY2N3JlbTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBtYXgtd2lkdGg6IDgwJTtcXG4gIGJvdHRvbTogMi42NjY2NjdyZW07XFxuICBsZWZ0OiA1MCU7XFxuICBwYWRkaW5nOiAwLjIxMzMzM3JlbTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDA7XFxuICBjb2xvcjogI2ZmZjtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIG9wYWNpdHk6IDAuNjtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjRzIGVhc2UtaW4tb3V0O1xcbiAgYm9yZGVyLXJhZGl1czogMC4wNjY2NjdyZW07XFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcXG59XFxuXFxuLmFtZmUtdG9hc3QuaGlkZSB7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi9tb2RhbHMvc3R5bGVzL3RvYXN0LmNzc1xuICoqIG1vZHVsZSBpZCA9IDIwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IHRyYW5zaXRpb25PbmNlIH0gZnJvbSAnLi9saWInXG5cbmNvbnN0IF9kYXRhID0ge31cblxuY29uc3QgYW5pbWF0aW9uID0ge1xuXG4gIC8qKlxuICAgKiB0cmFuc2l0aW9uXG4gICAqIEBwYXJhbSAge3N0cmluZ30gcmVmICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge29ian0gY29uZmlnICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge3N0cmluZ30gY2FsbGJhY2tJZCBbZGVzY3JpcHRpb25dXG4gICAqL1xuICB0cmFuc2l0aW9uOiBmdW5jdGlvbiAocmVmLCBjb25maWcsIGNhbGxiYWNrSWQpIHtcbiAgICBsZXQgcmVmRGF0YSA9IF9kYXRhW3JlZl1cbiAgICBjb25zdCBzdHlsZXNLZXkgPSBKU09OLnN0cmluZ2lmeShjb25maWcuc3R5bGVzKVxuICAgIGNvbnN0IHdlZXhJbnN0YW5jZSA9IHRoaXNcbiAgICAvLyBJZiB0aGUgc2FtZSBjb21wb25lbnQgcGVyZm9ybSBhIGFuaW1hdGlvbiB3aXRoIGV4YWN0bHkgdGhlIHNhbWVcbiAgICAvLyBzdHlsZXMgaW4gYSBzZXF1ZW5jZSB3aXRoIHNvIHNob3J0IGludGVydmFsIHRoYXQgdGhlIHByZXYgYW5pbWF0aW9uXG4gICAgLy8gaXMgc3RpbGwgaW4gcGxheWluZywgdGhlbiB0aGUgbmV4dCBhbmltYXRpb24gc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgaWYgKHJlZkRhdGEgJiYgcmVmRGF0YVtzdHlsZXNLZXldKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFyZWZEYXRhKSB7XG4gICAgICByZWZEYXRhID0gX2RhdGFbcmVmXSA9IHt9XG4gICAgfVxuICAgIHJlZkRhdGFbc3R5bGVzS2V5XSA9IHRydWVcblxuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpLmdldENvbXBvbmVudChyZWYpXG4gICAgcmV0dXJuIHRyYW5zaXRpb25PbmNlKGNvbXBvbmVudCwgY29uZmlnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIHN0eWxlc0tleSBpbiByZWZEYXRhIHNvIHRoYXQgdGhlIHNhbWUgYW5pbWF0aW9uXG4gICAgICAvLyBjYW4gYmUgcGxheWVkIGFnYWluIGFmdGVyIGN1cnJlbnQgYW5pbWF0aW9uIGlzIGFscmVhZHkgZmluaXNoZWQuXG4gICAgICBkZWxldGUgcmVmRGF0YVtzdHlsZXNLZXldXG4gICAgICB3ZWV4SW5zdGFuY2Uuc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkKVxuICAgIH0pXG4gIH1cbn1cblxuY29uc3QgbWV0YSA9IHtcbiAgYW5pbWF0aW9uOiBbe1xuICAgIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgICBhcmdzOiBbJ3N0cmluZycsICdvYmplY3QnLCAnZnVuY3Rpb24nXVxuICB9XVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGZ1bmN0aW9uIChXZWV4KSB7XG4gICAgV2VleC5yZWdpc3RlckFwaU1vZHVsZSgnYW5pbWF0aW9uJywgYW5pbWF0aW9uLCBtZXRhKVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2FwaS9hbmltYXRpb24vaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqIGNvbmZpZzpcbiAgICogICAtIHN0eWxlc1xuICAgKiAgIC0gZHVyYXRpb24gW051bWJlcl0gbWlsbGlzZWNvbmRzKG1zKVxuICAgKiAgIC0gdGltaW5nRnVuY3Rpb24gW3N0cmluZ11cbiAgICogICAtIGRlYWx5IFtOdW1iZXJdIG1pbGxpc2Vjb25kcyhtcylcbiAgICovXG4gIHRyYW5zaXRpb25PbmNlOiBmdW5jdGlvbiAoY29tcCwgY29uZmlnLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHN0eWxlcyA9IGNvbmZpZy5zdHlsZXMgfHwge31cbiAgICBjb25zdCBkdXJhdGlvbiA9IGNvbmZpZy5kdXJhdGlvbiB8fCAxMDAwIC8vIG1zXG4gICAgY29uc3QgdGltaW5nRnVuY3Rpb24gPSBjb25maWcudGltaW5nRnVuY3Rpb24gfHwgJ2Vhc2UnXG4gICAgY29uc3QgZGVsYXkgPSBjb25maWcuZGVsYXkgfHwgMCAgLy8gbXNcbiAgICBjb25zdCB0cmFuc2l0aW9uVmFsdWUgPSAnYWxsICcgKyBkdXJhdGlvbiArICdtcyAnXG4gICAgICAgICsgdGltaW5nRnVuY3Rpb24gKyAnICcgKyBkZWxheSArICdtcydcbiAgICBjb25zdCBkb20gPSBjb21wLm5vZGVcbiAgICBjb25zdCB0cmFuc2l0aW9uRW5kSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0VHJhbnNpdGlvbkVuZCcsIHRyYW5zaXRpb25FbmRIYW5kbGVyKVxuICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0cmFuc2l0aW9uRW5kSGFuZGxlcilcbiAgICAgIGRvbS5zdHlsZS50cmFuc2l0aW9uID0gJydcbiAgICAgIGRvbS5zdHlsZS53ZWJraXRUcmFuc2l0aW9uID0gJydcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gICAgZG9tLnN0eWxlLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uVmFsdWVcbiAgICBkb20uc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25WYWx1ZVxuICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRUcmFuc2l0aW9uRW5kJywgdHJhbnNpdGlvbkVuZEhhbmRsZXIpXG4gICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0cmFuc2l0aW9uRW5kSGFuZGxlcilcbiAgICBjb21wLnVwZGF0ZVN0eWxlKHN0eWxlcylcbiAgfVxuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2FwaS9hbmltYXRpb24vbGliLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHdlYnZpZXcgPSB7XG5cbiAgLy8gcmVmOiByZWYgb2YgdGhlIHdlYiBjb21wb25lbnQuXG4gIGdvQmFjazogZnVuY3Rpb24gKHJlZikge1xuICAgIGNvbnN0IHdlYkNvbXAgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKS5nZXRDb21wb25lbnQocmVmKVxuICAgIGlmICghd2ViQ29tcC5nb0JhY2spIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yOiB0aGUgc3BlY2lmaWVkIGNvbXBvbmVudCBoYXMgbm8gbWV0aG9kIG9mJ1xuICAgICAgICAgICsgJyBnb0JhY2suIFBsZWFzZSBtYWtlIHN1cmUgaXQgaXMgYSB3ZWJ2aWV3IGNvbXBvbmVudC4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHdlYkNvbXAuZ29CYWNrKClcbiAgfSxcblxuICAvLyByZWY6IHJlZiBvZiB0aGUgd2ViIGNvbXBvbmVudC5cbiAgZ29Gb3J3YXJkOiBmdW5jdGlvbiAocmVmKSB7XG4gICAgY29uc3Qgd2ViQ29tcCA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpLmdldENvbXBvbmVudChyZWYpXG4gICAgaWYgKCF3ZWJDb21wLmdvRm9yd2FyZCkge1xuICAgICAgY29uc29sZS5lcnJvcignZXJyb3I6IHRoZSBzcGVjaWZpZWQgY29tcG9uZW50IGhhcyBubyBtZXRob2Qgb2YnXG4gICAgICAgICAgKyAnIGdvRm9yd2FyZC4gUGxlYXNlIG1ha2Ugc3VyZSBpdCBpcyBhIHdlYnZpZXcgY29tcG9uZW50LicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgd2ViQ29tcC5nb0ZvcndhcmQoKVxuICB9LFxuXG4gIC8vIHJlZjogcmVmIG9mIHRoZSB3ZWIgY29tcG9uZW50LlxuICByZWxvYWQ6IGZ1bmN0aW9uIChyZWYpIHtcbiAgICBjb25zdCB3ZWJDb21wID0gdGhpcy5nZXRDb21wb25lbnRNYW5hZ2VyKCkuZ2V0Q29tcG9uZW50KHJlZilcbiAgICBpZiAoIXdlYkNvbXAucmVsb2FkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdlcnJvcjogdGhlIHNwZWNpZmllZCBjb21wb25lbnQgaGFzIG5vIG1ldGhvZCBvZidcbiAgICAgICAgICArICcgcmVsb2FkLiBQbGVhc2UgbWFrZSBzdXJlIGl0IGlzIGEgd2VidmlldyBjb21wb25lbnQuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB3ZWJDb21wLnJlbG9hZCgpXG4gIH1cblxufVxuXG5jb25zdCBtZXRhID0ge1xuICB3ZWJ2aWV3OiBbe1xuICAgIG5hbWU6ICdnb0JhY2snLFxuICAgIGFyZ3M6IFsnc3RyaW5nJ11cbiAgfSwge1xuICAgIG5hbWU6ICdnb0ZvcndhcmQnLFxuICAgIGFyZ3M6IFsnc3RyaW5nJ11cbiAgfSwge1xuICAgIG5hbWU6ICdyZWxvYWQnLFxuICAgIGFyZ3M6IFsnc3RyaW5nJ11cbiAgfV1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBmdW5jdGlvbiAoV2VleCkge1xuICAgIFdlZXgucmVnaXN0ZXJBcGlNb2R1bGUoJ3dlYnZpZXcnLCB3ZWJ2aWV3LCBtZXRhKVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2FwaS93ZWJ2aWV3LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG5hdmlnYXRvciA9IHtcblxuICAvLyBjb25maWdcbiAgLy8gIC0gdXJsOiB0aGUgdXJsIHRvIHB1c2hcbiAgLy8gIC0gYW5pbWF0ZWQ6IHRoaXMgY29uZmlndXJhdGlvbiBpdGVtIGlzIG5hdGl2ZSBvbmx5XG4gIC8vICBjYWxsYmFjayBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZFxuICBwdXNoOiBmdW5jdGlvbiAoY29uZmlnLCBjYWxsYmFja0lkKSB7XG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBjb25maWcudXJsXG4gICAgdGhpcy5zZW5kZXIucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQpXG4gIH0sXG5cbiAgLy8gY29uZmlnXG4gIC8vICAtIGFuaW1hdGVkOiB0aGlzIGNvbmZpZ3VyYXRpb24gaXRlbSBpcyBuYXRpdmUgb25seVxuICAvLyAgY2FsbGJhY2sgaXMgbm90ZSBjdXJyZW50bHkgc3VwcG9ydGVkXG4gIHBvcDogZnVuY3Rpb24gKGNvbmZpZywgY2FsbGJhY2tJZCkge1xuICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKVxuICAgIHRoaXMuc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkKVxuICB9XG5cbn1cblxuY29uc3QgbWV0YSA9IHtcbiAgbmF2aWdhdG9yOiBbe1xuICAgIG5hbWU6ICdwdXNoJyxcbiAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbiddXG4gIH0sIHtcbiAgICBuYW1lOiAncG9wJyxcbiAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbiddXG4gIH1dXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogZnVuY3Rpb24gKFdlZXgpIHtcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCduYXZpZ2F0b3InLCBuYXZpZ2F0b3IsIG1ldGEpXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvYXBpL25hdmlnYXRvci5qc1xuICoqLyIsIi8qIGdsb2JhbCBsb2NhbFN0b3JhZ2UgKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzdXBwb3J0TG9jYWxTdG9yYWdlID0gdHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCdcbmNvbnN0IFNVQ0NFU1MgPSAnc3VjY2VzcydcbmNvbnN0IEZBSUxFRCA9ICdmYWlsZWQnXG5jb25zdCBJTlZBTElEX1BBUkFNID0gJ2ludmFsaWRfcGFyYW0nXG5jb25zdCBVTkRFRklORUQgPSAndW5kZWZpbmVkJ1xuXG5jb25zdCBzdG9yYWdlID0ge1xuXG4gIC8qKlxuICAgKiBXaGVuIHBhc3NlZCBhIGtleSBuYW1lIGFuZCB2YWx1ZSwgd2lsbCBhZGQgdGhhdCBrZXkgdG8gdGhlIHN0b3JhZ2UsXG4gICAqIG9yIHVwZGF0ZSB0aGF0IGtleSdzIHZhbHVlIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja0lkXG4gICAqL1xuICBzZXRJdGVtOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgY2FsbGJhY2tJZCkge1xuICAgIGlmICghc3VwcG9ydExvY2FsU3RvcmFnZSkge1xuICAgICAgY29uc29sZS5lcnJvcigneW91ciBicm93c2VyIGlzIG5vdCBzdXBwb3J0IGxvY2FsU3RvcmFnZSB5ZXQuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBzZW5kZXIgPSB0aGlzLnNlbmRlclxuICAgIGlmICgha2V5IHx8ICF2YWx1ZSkge1xuICAgICAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCB7XG4gICAgICAgIHJlc3VsdDogJ2ZhaWxlZCcsXG4gICAgICAgIGRhdGE6IElOVkFMSURfUEFSQU1cbiAgICAgIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpXG4gICAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQsIHtcbiAgICAgICAgcmVzdWx0OiBTVUNDRVNTLFxuICAgICAgICBkYXRhOiBVTkRFRklORURcbiAgICAgIH0pXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAvLyBhY2NlcHQgYW55IGV4Y2VwdGlvbiB0aHJvd24gZHVyaW5nIGEgc3RvcmFnZSBhdHRlbXB0IGFzIGEgcXVvdGEgZXJyb3JcbiAgICAgIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwge1xuICAgICAgICByZXN1bHQ6IEZBSUxFRCxcbiAgICAgICAgZGF0YTogVU5ERUZJTkVEXG4gICAgICB9KVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogV2hlbiBwYXNzZWQgYSBrZXkgbmFtZSwgd2lsbCByZXR1cm4gdGhhdCBrZXkncyB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja0lkXG4gICAqL1xuICBnZXRJdGVtOiBmdW5jdGlvbiAoa2V5LCBjYWxsYmFja0lkKSB7XG4gICAgaWYgKCFzdXBwb3J0TG9jYWxTdG9yYWdlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCd5b3VyIGJyb3dzZXIgaXMgbm90IHN1cHBvcnQgbG9jYWxTdG9yYWdlIHlldC4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHNlbmRlciA9IHRoaXMuc2VuZGVyXG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwge1xuICAgICAgICByZXN1bHQ6IEZBSUxFRCxcbiAgICAgICAgZGF0YTogSU5WQUxJRF9QQVJBTVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCB2YWwgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpXG4gICAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCB7XG4gICAgICByZXN1bHQ6IHZhbCA/IFNVQ0NFU1MgOiBGQUlMRUQsXG4gICAgICBkYXRhOiB2YWwgfHwgVU5ERUZJTkVEXG4gICAgfSlcbiAgfSxcblxuICAvKipcbiAgICpXaGVuIHBhc3NlZCBhIGtleSBuYW1lLCB3aWxsIHJlbW92ZSB0aGF0IGtleSBmcm9tIHRoZSBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrSWRcbiAgICovXG4gIHJlbW92ZUl0ZW06IGZ1bmN0aW9uIChrZXksIGNhbGxiYWNrSWQpIHtcbiAgICBpZiAoIXN1cHBvcnRMb2NhbFN0b3JhZ2UpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3lvdXIgYnJvd3NlciBpcyBub3Qgc3VwcG9ydCBsb2NhbFN0b3JhZ2UgeWV0LicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3Qgc2VuZGVyID0gdGhpcy5zZW5kZXJcbiAgICBpZiAoIWtleSkge1xuICAgICAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCB7XG4gICAgICAgIHJlc3VsdDogRkFJTEVELFxuICAgICAgICBkYXRhOiBJTlZBTElEX1BBUkFNXG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcbiAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQsIHtcbiAgICAgIHJlc3VsdDogU1VDQ0VTUyxcbiAgICAgIGRhdGE6IFVOREVGSU5FRFxuICAgIH0pXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaW50ZWdlciByZXByZXNlbnRpbmcgdGhlIG51bWJlciBvZiBkYXRhIGl0ZW1zIHN0b3JlZCBpbiB0aGUgU3RvcmFnZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrSWRcbiAgICovXG4gIGxlbmd0aDogZnVuY3Rpb24gKGNhbGxiYWNrSWQpIHtcbiAgICBpZiAoIXN1cHBvcnRMb2NhbFN0b3JhZ2UpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3lvdXIgYnJvd3NlciBpcyBub3Qgc3VwcG9ydCBsb2NhbFN0b3JhZ2UgeWV0LicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3Qgc2VuZGVyID0gdGhpcy5zZW5kZXJcbiAgICBjb25zdCBsZW4gPSBsb2NhbFN0b3JhZ2UubGVuZ3RoXG4gICAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCB7XG4gICAgICByZXN1bHQ6IFNVQ0NFU1MsXG4gICAgICBkYXRhOiBsZW5cbiAgICB9KVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IHRoYXQgY29udGFpbnMgYWxsIGtleXMgc3RvcmVkIGluIFN0b3JhZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja0lkXG4gICAqL1xuICBnZXRBbGxLZXlzOiBmdW5jdGlvbiAoY2FsbGJhY2tJZCkge1xuICAgIGlmICghc3VwcG9ydExvY2FsU3RvcmFnZSkge1xuICAgICAgY29uc29sZS5lcnJvcigneW91ciBicm93c2VyIGlzIG5vdCBzdXBwb3J0IGxvY2FsU3RvcmFnZSB5ZXQuJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBzZW5kZXIgPSB0aGlzLnNlbmRlclxuICAgIGNvbnN0IF9hcnIgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBfYXJyLnB1c2gobG9jYWxTdG9yYWdlLmtleShpKSlcbiAgICB9XG4gICAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCB7XG4gICAgICByZXN1bHQ6IFNVQ0NFU1MsXG4gICAgICBkYXRhOiBfYXJyXG4gICAgfSlcbiAgfVxufVxuXG5jb25zdCBtZXRhID0ge1xuICBzdG9yYWdlOiBbe1xuICAgIG5hbWU6ICdzZXRJdGVtJyxcbiAgICBhcmdzOiBbJ3N0cmluZycsICdzdHJpbmcnLCAnZnVuY3Rpb24nXVxuICB9LCB7XG4gICAgbmFtZTogJ2dldEl0ZW0nLFxuICAgIGFyZ3M6IFsnc3RyaW5nJywgJ2Z1bmN0aW9uJ11cbiAgfSwge1xuICAgIG5hbWU6ICdyZW1vdmVJdGVtJyxcbiAgICBhcmdzOiBbJ3N0cmluZycsICdmdW5jdGlvbiddXG4gIH0sIHtcbiAgICBuYW1lOiAnbGVuZ3RoJyxcbiAgICBhcmdzOiBbJ2Z1bmN0aW9uJ11cbiAgfSwge1xuICAgIG5hbWU6ICdnZXRBbGxLZXlzJyxcbiAgICBhcmdzOiBbJ2Z1bmN0aW9uJ11cbiAgfV1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0OiBmdW5jdGlvbiAoV2VleCkge1xuICAgIFdlZXgucmVnaXN0ZXJBcGlNb2R1bGUoJ3N0b3JhZ2UnLCBzdG9yYWdlLCBtZXRhKVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2h0bWw1L2Jyb3dzZXIvZXh0ZW5kL2FwaS9zdG9yYWdlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuXG5BVUNUSU9OOlxudGFza1F1ZXVlXG5DbGlwYm9hcmQuc2V0U3RyaW5nKCkgIE5PVyBub3Qgd29ya3MsIGZhY2luZyB0byB1c2VyLWFjdCBsb3NlIG9mIHRhc2tRdWV1ZS5cblxud29ya3MgaW4gQ2hyb21lIEZpcmVmb3ggT3BlcmEuIGJ1dCBub3QgaW4gU2FmYXJpLlxuQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvZXhlY0NvbW1hbmQjQnJvd3Nlcl9jb21wYXRpYmlsaXR5XG5cbkNsaXBib2FyZC5nZXRTdHJpbmcoKSB1bmltcGxlbWVudGVkLiBUaGVyZSBpcyBubyBlYXN5IHdheSB0byBkbyBwYXN0ZSBmcm9tIGNsaXBib2FyZCB0byBqcyB2YXJpYWJsZS5cblxuU28gbG9vayBvdXQgeW91ciBhcHAgYmVoYXZpb3IsIHdoZW4gZG93bmdyYWRlIHRvIGh0bWw1IHJlbmRlci5cbkFueSBpZGVhIGlzIHdlbGNvbWUuXG4qKi9cblxuY29uc3QgV0VFWF9DTElQQk9BUkRfSUQgPSAnX193ZWV4X2NsaXBib2FyZF9pZF9fJ1xuXG5jb25zdCBjbGlwYm9hcmQgPSB7XG5cbiAgZ2V0U3RyaW5nOiBmdW5jdGlvbiAoY2FsbGJhY2tJZCkge1xuICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gaHRtbDVcbiAgICBjb25zb2xlLmxvZygnY2xpcGJvYXJkLmdldFN0cmluZygpIGlzIG5vdCBzdXBwb3J0ZWQgbm93LicpXG4gIH0sXG5cbiAgc2V0U3RyaW5nOiBmdW5jdGlvbiAodGV4dCkge1xuICAgIC8vIG5vdCBzdXBwb3J0IHNhZmFyaVxuICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycgJiYgdGV4dCAhPT0gJycgJiYgZG9jdW1lbnQuZXhlY0NvbW1hbmQpIHtcbiAgICAgIGNvbnN0IHRlbXBJbnB1dCA9IGVsZW1lbnQoKVxuICAgICAgdGVtcElucHV0LnZhbHVlID0gdGV4dFxuXG4gICAgICB0ZW1wSW5wdXQuc2VsZWN0KClcbiAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5JylcbiAgICAgIC8vIHZhciBvdXQgPSBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICAgICAgLy8gY29uc29sZS5sb2coXCJleGVjQ29tbWFuZCBvdXQgaXMgXCIgKyBvdXQpO1xuICAgICAgdGVtcElucHV0LnZhbHVlID0gJydcbiAgICAgIHRlbXBJbnB1dC5ibHVyKClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnb25seSBzdXBwb3J0IHN0cmluZyBpbnB1dCBub3cnKVxuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGVsZW1lbnQgKCkge1xuICBsZXQgdGVtcElucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoV0VFWF9DTElQQk9BUkRfSUQpXG4gIGlmICh0ZW1wSW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRlbXBJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICB0ZW1wSW5wdXQuc2V0QXR0cmlidXRlKCdpZCcsIFdFRVhfQ0xJUEJPQVJEX0lEKVxuICAgIHRlbXBJbnB1dC5zdHlsZS5jc3NUZXh0ID0gJ2hlaWdodDoxcHg7d2lkdGg6MXB4O2JvcmRlcjpub25lOydcbiAgICAvLyB0ZW1wSW5wdXQuc3R5bGUuY3NzVGV4dCA9IFwiaGVpZ2h0OjQwcHg7d2lkdGg6MzAwcHg7Ym9yZGVyOnNvbGlkO1wiXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wSW5wdXQpXG4gIH1cbiAgcmV0dXJuIHRlbXBJbnB1dFxufVxuXG5jb25zdCBtZXRhID0ge1xuICBjbGlwYm9hcmQ6IFt7XG4gICAgbmFtZTogJ2dldFN0cmluZycsXG4gICAgYXJnczogWydmdW5jdGlvbiddXG4gIH0sIHtcbiAgICBuYW1lOiAnc2V0U3RyaW5nJyxcbiAgICBhcmdzOiBbJ3N0cmluZyddXG4gIH1dXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogZnVuY3Rpb24gKFdlZXgpIHtcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCdjbGlwYm9hcmQnLCBjbGlwYm9hcmQsIG1ldGEpXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaHRtbDUvYnJvd3Nlci9leHRlbmQvYXBpL2NsaXBib2FyZC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=